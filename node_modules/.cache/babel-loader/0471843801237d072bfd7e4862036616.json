{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst MessagePayload = require('../structures/MessagePayload');\n\nconst Sticker = require('../structures/Sticker');\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Options for creating a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @param {?string} [description] The description for the sticker\n   * @param {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} file The file for the sticker\n   * @param {string} name The name for the sticker\n   * @param {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @param {GuildStickerCreateOptions} [options] Options\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a url\n   * guild.stickers.create('https://i.imgur.com/w3duR07.png', 'rip')\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create('./memes/banana.png', 'banana')\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n\n\n  async create(file, name, tags) {\n    let {\n      description,\n      reason\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    file = { ...(await MessagePayload.resolveFile(file)),\n      key: 'file'\n    };\n    if (!file) throw new TypeError('REQ_RESOURCE_TYPE');\n    const data = {\n      name,\n      tags,\n      description: description ?? ''\n    };\n    const sticker = await this.client.api.guilds(this.guild.id).stickers.post({\n      data,\n      files: [file],\n      reason,\n      dontUsePayloadJSON: true\n    });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditData} [data] The new data for the sticker\n   * @param {string} [reason] Reason for editing this sticker\n   * @returns {Promise<Sticker>}\n   */\n\n\n  async edit(sticker, data, reason) {\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new TypeError('INVALID_TYPE', 'sticker', 'StickerResolvable');\n    const d = await this.client.api.guilds(this.guild.id).stickers(stickerId).patch({\n      data,\n      reason\n    });\n    const existing = this.cache.get(stickerId);\n\n    if (existing) {\n      const clone = existing._clone();\n\n      clone._patch(d);\n\n      return clone;\n    }\n\n    return this._add(d);\n  }\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new TypeError('INVALID_TYPE', 'sticker', 'StickerResolvable');\n    await this.client.api.guilds(this.guild.id).stickers(sticker).delete({\n      reason\n    });\n  }\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const sticker = await this.client.api.guilds(this.guild.id).stickers(id).get();\n      return this._add(sticker, cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).stickers.get();\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n\n}\n\nmodule.exports = GuildStickerManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","MessagePayload","Sticker","GuildStickerManager","constructor","guild","iterable","client","_add","data","cache","extras","create","file","name","tags","description","reason","resolveFile","key","sticker","api","guilds","id","stickers","post","files","dontUsePayloadJSON","actions","GuildStickerCreate","handle","edit","stickerId","resolveId","d","patch","existing","get","clone","_clone","_patch","delete","fetch","force","map","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/GuildStickerManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst MessagePayload = require('../structures/MessagePayload');\nconst Sticker = require('../structures/Sticker');\n\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options for creating a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @param {?string} [description] The description for the sticker\n   * @param {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} file The file for the sticker\n   * @param {string} name The name for the sticker\n   * @param {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @param {GuildStickerCreateOptions} [options] Options\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a url\n   * guild.stickers.create('https://i.imgur.com/w3duR07.png', 'rip')\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create('./memes/banana.png', 'banana')\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n  async create(file, name, tags, { description, reason } = {}) {\n    file = { ...(await MessagePayload.resolveFile(file)), key: 'file' };\n    if (!file) throw new TypeError('REQ_RESOURCE_TYPE');\n\n    const data = { name, tags, description: description ?? '' };\n\n    const sticker = await this.client.api\n      .guilds(this.guild.id)\n      .stickers.post({ data, files: [file], reason, dontUsePayloadJSON: true });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditData} [data] The new data for the sticker\n   * @param {string} [reason] Reason for editing this sticker\n   * @returns {Promise<Sticker>}\n   */\n  async edit(sticker, data, reason) {\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new TypeError('INVALID_TYPE', 'sticker', 'StickerResolvable');\n\n    const d = await this.client.api.guilds(this.guild.id).stickers(stickerId).patch({\n      data,\n      reason,\n    });\n\n    const existing = this.cache.get(stickerId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new TypeError('INVALID_TYPE', 'sticker', 'StickerResolvable');\n\n    await this.client.api.guilds(this.guild.id).stickers(sticker).delete({ reason });\n  }\n\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const sticker = await this.client.api.guilds(this.guild.id).stickers(id).get();\n      return this._add(sticker, cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).stickers.get();\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n}\n\nmodule.exports = GuildStickerManager;\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAAiBC,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAM;EAAEE;AAAF,IAAgBF,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,8BAAD,CAA9B;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,uBAAD,CAAvB;AAEA;AACA;AACA;AACA;;;AACA,MAAMK,mBAAN,SAAkCJ,aAAlC,CAAgD;EAC9CK,WAAW,CAACC,KAAD,EAAQC,QAAR,EAAkB;IAC3B,MAAMD,KAAK,CAACE,MAAZ,EAAoBL,OAApB,EAA6BI,QAA7B;IAEA;AACJ;AACA;AACA;;IACI,KAAKD,KAAL,GAAaA,KAAb;EACD;EAED;AACF;AACA;AACA;AACA;;;EAEEG,IAAI,CAACC,IAAD,EAAOC,KAAP,EAAc;IAChB,OAAO,MAAMF,IAAN,CAAWC,IAAX,EAAiBC,KAAjB,EAAwB;MAAEC,MAAM,EAAE,CAAC,KAAKN,KAAN;IAAV,CAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACc,MAANO,MAAM,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAiD;IAAA,IAA9B;MAAEC,WAAF;MAAeC;IAAf,CAA8B,uEAAJ,EAAI;IAC3DJ,IAAI,GAAG,EAAE,IAAI,MAAMZ,cAAc,CAACiB,WAAf,CAA2BL,IAA3B,CAAV,CAAF;MAA+CM,GAAG,EAAE;IAApD,CAAP;IACA,IAAI,CAACN,IAAL,EAAW,MAAM,IAAIb,SAAJ,CAAc,mBAAd,CAAN;IAEX,MAAMS,IAAI,GAAG;MAAEK,IAAF;MAAQC,IAAR;MAAcC,WAAW,EAAEA,WAAW,IAAI;IAA1C,CAAb;IAEA,MAAMI,OAAO,GAAG,MAAM,KAAKb,MAAL,CAAYc,GAAZ,CACnBC,MADmB,CACZ,KAAKjB,KAAL,CAAWkB,EADC,EAEnBC,QAFmB,CAEVC,IAFU,CAEL;MAAEhB,IAAF;MAAQiB,KAAK,EAAE,CAACb,IAAD,CAAf;MAAuBI,MAAvB;MAA+BU,kBAAkB,EAAE;IAAnD,CAFK,CAAtB;IAGA,OAAO,KAAKpB,MAAL,CAAYqB,OAAZ,CAAoBC,kBAApB,CAAuCC,MAAvC,CAA8C,KAAKzB,KAAnD,EAA0De,OAA1D,EAAmEA,OAA1E;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;;EACY,MAAJW,IAAI,CAACX,OAAD,EAAUX,IAAV,EAAgBQ,MAAhB,EAAwB;IAChC,MAAMe,SAAS,GAAG,KAAKC,SAAL,CAAeb,OAAf,CAAlB;IACA,IAAI,CAACY,SAAL,EAAgB,MAAM,IAAIhC,SAAJ,CAAc,cAAd,EAA8B,SAA9B,EAAyC,mBAAzC,CAAN;IAEhB,MAAMkC,CAAC,GAAG,MAAM,KAAK3B,MAAL,CAAYc,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKjB,KAAL,CAAWkB,EAAlC,EAAsCC,QAAtC,CAA+CQ,SAA/C,EAA0DG,KAA1D,CAAgE;MAC9E1B,IAD8E;MAE9EQ;IAF8E,CAAhE,CAAhB;IAKA,MAAMmB,QAAQ,GAAG,KAAK1B,KAAL,CAAW2B,GAAX,CAAeL,SAAf,CAAjB;;IACA,IAAII,QAAJ,EAAc;MACZ,MAAME,KAAK,GAAGF,QAAQ,CAACG,MAAT,EAAd;;MACAD,KAAK,CAACE,MAAN,CAAaN,CAAb;;MACA,OAAOI,KAAP;IACD;;IACD,OAAO,KAAK9B,IAAL,CAAU0B,CAAV,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACc,MAANO,MAAM,CAACrB,OAAD,EAAUH,MAAV,EAAkB;IAC5BG,OAAO,GAAG,KAAKa,SAAL,CAAeb,OAAf,CAAV;IACA,IAAI,CAACA,OAAL,EAAc,MAAM,IAAIpB,SAAJ,CAAc,cAAd,EAA8B,SAA9B,EAAyC,mBAAzC,CAAN;IAEd,MAAM,KAAKO,MAAL,CAAYc,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKjB,KAAL,CAAWkB,EAAlC,EAAsCC,QAAtC,CAA+CJ,OAA/C,EAAwDqB,MAAxD,CAA+D;MAAExB;IAAF,CAA/D,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACa,MAALyB,KAAK,CAACnB,EAAD,EAA2C;IAAA,IAAtC;MAAEb,KAAK,GAAG,IAAV;MAAgBiC,KAAK,GAAG;IAAxB,CAAsC,uEAAJ,EAAI;;IACpD,IAAIpB,EAAJ,EAAQ;MACN,IAAI,CAACoB,KAAL,EAAY;QACV,MAAMP,QAAQ,GAAG,KAAK1B,KAAL,CAAW2B,GAAX,CAAed,EAAf,CAAjB;QACA,IAAIa,QAAJ,EAAc,OAAOA,QAAP;MACf;;MACD,MAAMhB,OAAO,GAAG,MAAM,KAAKb,MAAL,CAAYc,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKjB,KAAL,CAAWkB,EAAlC,EAAsCC,QAAtC,CAA+CD,EAA/C,EAAmDc,GAAnD,EAAtB;MACA,OAAO,KAAK7B,IAAL,CAAUY,OAAV,EAAmBV,KAAnB,CAAP;IACD;;IAED,MAAMD,IAAI,GAAG,MAAM,KAAKF,MAAL,CAAYc,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKjB,KAAL,CAAWkB,EAAlC,EAAsCC,QAAtC,CAA+Ca,GAA/C,EAAnB;IACA,OAAO,IAAIxC,UAAJ,CAAeY,IAAI,CAACmC,GAAL,CAASxB,OAAO,IAAI,CAACA,OAAO,CAACG,EAAT,EAAa,KAAKf,IAAL,CAAUY,OAAV,EAAmBV,KAAnB,CAAb,CAApB,CAAf,CAAP;EACD;;AArJ6C;;AAwJhDmC,MAAM,CAACC,OAAP,GAAiB3C,mBAAjB"},"metadata":{},"sourceType":"script"}