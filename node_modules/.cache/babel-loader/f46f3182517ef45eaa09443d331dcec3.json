{"ast":null,"code":"'use strict';\n\nconst {\n  AsyncQueue\n} = require('@sapphire/async-queue');\n\nconst DiscordAPIError = require('./DiscordAPIError');\n\nconst HTTPError = require('./HTTPError');\n\nconst RateLimitError = require('./RateLimitError');\n\nconst {\n  Events: {\n    DEBUG,\n    RATE_LIMIT,\n    INVALID_REQUEST_WARNING\n  }\n} = require('../util/Constants');\n\nconst Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, resetAfter, serverDate) {\n  // Use direct reset time when available, server date becomes irrelevant in this case\n  if (resetAfter) {\n    return Date.now() + Number(resetAfter) * 1000;\n  }\n\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n/* Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\n\n\nlet invalidCount = 0;\nlet invalidCountResetTime = null;\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  globalDelayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        this.manager.globalDelay = null;\n        resolve();\n      }, ms).unref();\n    });\n  }\n  /*\n   * Determines whether the request should be queued or whether a RateLimitError should be thrown\n   */\n\n\n  async onRateLimit(request, limit, timeout, isGlobal) {\n    const {\n      options\n    } = this.manager.client;\n    if (!options.rejectOnRateLimit) return;\n    const rateLimitData = {\n      timeout,\n      limit,\n      method: request.method,\n      path: request.path,\n      route: request.route,\n      global: isGlobal\n    };\n    const shouldThrow = typeof options.rejectOnRateLimit === 'function' ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n\n    if (shouldThrow) {\n      throw new RateLimitError(rateLimitData);\n    }\n  }\n\n  async execute(request) {\n    /*\n     * After calculations have been done, pre-emptively stop further requests\n     * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n     */\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit, timeout, delayPromise;\n\n      if (isGlobal) {\n        // Set the variables based on the global rate limit\n        limit = this.manager.globalLimit;\n        timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n      } else {\n        // Set the variables based on the route-specific rate limit\n        limit = this.limit;\n        timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n      }\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {RateLimitData} rateLimitData Object containing the rate limit info\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit,\n          method: request.method,\n          path: request.path,\n          route: request.route,\n          global: isGlobal\n        });\n      }\n\n      if (isGlobal) {\n        // If this is the first task to reach the global timeout, set the global delay\n        if (!this.manager.globalDelay) {\n          // The global delay function should clear the global delay state when it is resolved\n          this.manager.globalDelay = this.globalDelayFor(timeout);\n        }\n\n        delayPromise = this.manager.globalDelay;\n      } else {\n        delayPromise = Util.delayFor(timeout);\n      } // Determine whether a RateLimitError should be thrown\n\n\n      await this.onRateLimit(request, limit, timeout, isGlobal); // eslint-disable-line no-await-in-loop\n      // Wait for the timeout to expire in order to avoid an actual 429\n\n      await delayPromise; // eslint-disable-line no-await-in-loop\n    } // As the request goes out, update the global usage information\n\n\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1000;\n      this.manager.globalRemaining = this.manager.globalLimit;\n    }\n\n    this.manager.globalRemaining--; // Perform the request\n\n    let res;\n\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    let sublimitTimeout;\n\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const resetAfter = res.headers.get('x-ratelimit-reset-after');\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset || resetAfter ? calculateReset(reset, resetAfter, serverDate) : Date.now(); // https://github.com/discord/discord-api-docs/issues/182\n\n      if (!resetAfter && request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      } // Handle retryAfter, which means we have actually hit a rate limit\n\n\n      let retryAfter = res.headers.get('retry-after');\n      retryAfter = retryAfter ? Number(retryAfter) * 1000 : -1;\n\n      if (retryAfter > 0) {\n        // If the global ratelimit header is set, that means we hit the global rate limit\n        if (res.headers.get('x-ratelimit-global')) {\n          this.manager.globalRemaining = 0;\n          this.manager.globalReset = Date.now() + retryAfter;\n        } else if (!this.localLimited) {\n          /*\n           * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n           * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n           * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n           */\n          sublimitTimeout = retryAfter;\n        }\n      }\n    } // Count the invalid requests\n\n\n    if (res.status === 401 || res.status === 403 || res.status === 429) {\n      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n        invalidCountResetTime = Date.now() + 1000 * 60 * 10;\n        invalidCount = 0;\n      }\n\n      invalidCount++;\n      const emitInvalid = this.manager.client.listenerCount(INVALID_REQUEST_WARNING) && this.manager.client.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.client.options.invalidRequestWarningInterval === 0;\n\n      if (emitInvalid) {\n        /**\n         * @typedef {Object} InvalidRequestWarningData\n         * @property {number} count Number of invalid requests that have been made in the window\n         * @property {number} remainingTime Time in ms remaining before the count resets\n         */\n\n        /**\n         * Emitted periodically when the process sends invalid requests to let users avoid the\n         * 10k invalid requests in 10 minutes threshold that causes a ban\n         * @event Client#invalidRequestWarning\n         * @param {InvalidRequestWarningData} invalidRequestWarningData Object containing the invalid request info\n         */\n        this.manager.client.emit(INVALID_REQUEST_WARNING, {\n          count: invalidCount,\n          remainingTime: invalidCountResetTime - Date.now()\n        });\n      }\n    } // Handle 2xx and 3xx responses\n\n\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    } // Handle 4xx responses\n\n\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        const isGlobal = this.globalLimited;\n        let limit, timeout;\n\n        if (isGlobal) {\n          // Set the variables based on the global rate limit\n          limit = this.manager.globalLimit;\n          timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n        } else {\n          // Set the variables based on the route-specific rate limit\n          limit = this.limit;\n          timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n        }\n\n        this.manager.client.emit(DEBUG, `Hit a 429 while executing a request.\n    Global  : ${isGlobal}\n    Method  : ${request.method}\n    Path    : ${request.path}\n    Route   : ${request.route}\n    Limit   : ${limit}\n    Timeout : ${timeout}ms\n    Sublimit: ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`);\n        await this.onRateLimit(request, limit, timeout, isGlobal); // If caused by a sublimit, wait it out here so other requests on the route can be handled\n\n        if (sublimitTimeout) {\n          await Util.delayFor(sublimitTimeout);\n        }\n\n        return this.execute(request);\n      } // Handle possible malformed requests\n\n\n      let data;\n\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request);\n      }\n\n      throw new DiscordAPIError(data, res.status, request);\n    } // Handle 5xx responses\n\n\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    } // Fallback in the rare case a status code outside the range 200..=599 is returned\n\n\n    return null;\n  }\n\n}\n\nmodule.exports = RequestHandler;","map":{"version":3,"names":["AsyncQueue","require","DiscordAPIError","HTTPError","RateLimitError","Events","DEBUG","RATE_LIMIT","INVALID_REQUEST_WARNING","Util","parseResponse","res","headers","get","startsWith","json","buffer","getAPIOffset","serverDate","Date","getTime","now","calculateReset","reset","resetAfter","Number","invalidCount","invalidCountResetTime","RequestHandler","constructor","manager","queue","remaining","limit","push","request","wait","execute","shift","globalLimited","globalRemaining","globalReset","localLimited","limited","_inactive","globalDelayFor","ms","Promise","resolve","setTimeout","globalDelay","unref","onRateLimit","timeout","isGlobal","options","client","rejectOnRateLimit","rateLimitData","method","path","route","global","shouldThrow","some","toLowerCase","delayPromise","globalLimit","restTimeOffset","listenerCount","emit","delayFor","make","error","retries","retryLimit","message","name","status","sublimitTimeout","Infinity","includes","retryAfter","emitInvalid","invalidRequestWarningInterval","count","remainingTime","ok","data","err","statusText","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/rest/RequestHandler.js"],"sourcesContent":["'use strict';\n\nconst { AsyncQueue } = require('@sapphire/async-queue');\nconst DiscordAPIError = require('./DiscordAPIError');\nconst HTTPError = require('./HTTPError');\nconst RateLimitError = require('./RateLimitError');\nconst {\n  Events: { DEBUG, RATE_LIMIT, INVALID_REQUEST_WARNING },\n} = require('../util/Constants');\nconst Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, resetAfter, serverDate) {\n  // Use direct reset time when available, server date becomes irrelevant in this case\n  if (resetAfter) {\n    return Date.now() + Number(resetAfter) * 1000;\n  }\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n\n/* Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime = null;\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  globalDelayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        this.manager.globalDelay = null;\n        resolve();\n      }, ms).unref();\n    });\n  }\n\n  /*\n   * Determines whether the request should be queued or whether a RateLimitError should be thrown\n   */\n  async onRateLimit(request, limit, timeout, isGlobal) {\n    const { options } = this.manager.client;\n    if (!options.rejectOnRateLimit) return;\n\n    const rateLimitData = {\n      timeout,\n      limit,\n      method: request.method,\n      path: request.path,\n      route: request.route,\n      global: isGlobal,\n    };\n    const shouldThrow =\n      typeof options.rejectOnRateLimit === 'function'\n        ? await options.rejectOnRateLimit(rateLimitData)\n        : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n    if (shouldThrow) {\n      throw new RateLimitError(rateLimitData);\n    }\n  }\n\n  async execute(request) {\n    /*\n     * After calculations have been done, pre-emptively stop further requests\n     * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n     */\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit, timeout, delayPromise;\n\n      if (isGlobal) {\n        // Set the variables based on the global rate limit\n        limit = this.manager.globalLimit;\n        timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n      } else {\n        // Set the variables based on the route-specific rate limit\n        limit = this.limit;\n        timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n      }\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {RateLimitData} rateLimitData Object containing the rate limit info\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit,\n          method: request.method,\n          path: request.path,\n          route: request.route,\n          global: isGlobal,\n        });\n      }\n\n      if (isGlobal) {\n        // If this is the first task to reach the global timeout, set the global delay\n        if (!this.manager.globalDelay) {\n          // The global delay function should clear the global delay state when it is resolved\n          this.manager.globalDelay = this.globalDelayFor(timeout);\n        }\n        delayPromise = this.manager.globalDelay;\n      } else {\n        delayPromise = Util.delayFor(timeout);\n      }\n\n      // Determine whether a RateLimitError should be thrown\n      await this.onRateLimit(request, limit, timeout, isGlobal); // eslint-disable-line no-await-in-loop\n\n      // Wait for the timeout to expire in order to avoid an actual 429\n      await delayPromise; // eslint-disable-line no-await-in-loop\n    }\n\n    // As the request goes out, update the global usage information\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1000;\n      this.manager.globalRemaining = this.manager.globalLimit;\n    }\n    this.manager.globalRemaining--;\n\n    // Perform the request\n    let res;\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    let sublimitTimeout;\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const resetAfter = res.headers.get('x-ratelimit-reset-after');\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n\n      this.reset = reset || resetAfter ? calculateReset(reset, resetAfter, serverDate) : Date.now();\n\n      // https://github.com/discord/discord-api-docs/issues/182\n      if (!resetAfter && request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      }\n\n      // Handle retryAfter, which means we have actually hit a rate limit\n      let retryAfter = res.headers.get('retry-after');\n      retryAfter = retryAfter ? Number(retryAfter) * 1000 : -1;\n      if (retryAfter > 0) {\n        // If the global ratelimit header is set, that means we hit the global rate limit\n        if (res.headers.get('x-ratelimit-global')) {\n          this.manager.globalRemaining = 0;\n          this.manager.globalReset = Date.now() + retryAfter;\n        } else if (!this.localLimited) {\n          /*\n           * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n           * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n           * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n           */\n          sublimitTimeout = retryAfter;\n        }\n      }\n    }\n\n    // Count the invalid requests\n    if (res.status === 401 || res.status === 403 || res.status === 429) {\n      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n        invalidCountResetTime = Date.now() + 1000 * 60 * 10;\n        invalidCount = 0;\n      }\n      invalidCount++;\n\n      const emitInvalid =\n        this.manager.client.listenerCount(INVALID_REQUEST_WARNING) &&\n        this.manager.client.options.invalidRequestWarningInterval > 0 &&\n        invalidCount % this.manager.client.options.invalidRequestWarningInterval === 0;\n      if (emitInvalid) {\n        /**\n         * @typedef {Object} InvalidRequestWarningData\n         * @property {number} count Number of invalid requests that have been made in the window\n         * @property {number} remainingTime Time in ms remaining before the count resets\n         */\n\n        /**\n         * Emitted periodically when the process sends invalid requests to let users avoid the\n         * 10k invalid requests in 10 minutes threshold that causes a ban\n         * @event Client#invalidRequestWarning\n         * @param {InvalidRequestWarningData} invalidRequestWarningData Object containing the invalid request info\n         */\n        this.manager.client.emit(INVALID_REQUEST_WARNING, {\n          count: invalidCount,\n          remainingTime: invalidCountResetTime - Date.now(),\n        });\n      }\n    }\n\n    // Handle 2xx and 3xx responses\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    }\n\n    // Handle 4xx responses\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        const isGlobal = this.globalLimited;\n        let limit, timeout;\n        if (isGlobal) {\n          // Set the variables based on the global rate limit\n          limit = this.manager.globalLimit;\n          timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();\n        } else {\n          // Set the variables based on the route-specific rate limit\n          limit = this.limit;\n          timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n        }\n\n        this.manager.client.emit(\n          DEBUG,\n          `Hit a 429 while executing a request.\n    Global  : ${isGlobal}\n    Method  : ${request.method}\n    Path    : ${request.path}\n    Route   : ${request.route}\n    Limit   : ${limit}\n    Timeout : ${timeout}ms\n    Sublimit: ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n        );\n\n        await this.onRateLimit(request, limit, timeout, isGlobal);\n\n        // If caused by a sublimit, wait it out here so other requests on the route can be handled\n        if (sublimitTimeout) {\n          await Util.delayFor(sublimitTimeout);\n        }\n        return this.execute(request);\n      }\n\n      // Handle possible malformed requests\n      let data;\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request);\n      }\n\n      throw new DiscordAPIError(data, res.status, request);\n    }\n\n    // Handle 5xx responses\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    // Fallback in the rare case a status code outside the range 200..=599 is returned\n    return null;\n  }\n}\n\nmodule.exports = RequestHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}