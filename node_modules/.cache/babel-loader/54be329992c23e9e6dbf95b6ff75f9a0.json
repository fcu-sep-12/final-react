{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst MessageManager = require('../managers/MessageManager');\n\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\n\nconst Permissions = require('../util/Permissions');\n/**\n * Represents a thread channel on Discord.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass ThreadChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the thread channel is part of\n   * @param {APIChannel} data The data for the thread channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   * @param {boolean} [fromInteraction=false] Whether the data was from an interaction (partial)\n   */\n  constructor(guild, data, client) {\n    let fromInteraction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(guild?.client ?? client, data, false);\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n\n    this.guildId = guild?.id ?? data.guild_id;\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n\n  _patch(data) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    super._patch(data);\n    /**\n     * The name of the thread\n     * @type {string}\n     */\n\n\n    this.name = data.name;\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else if (!this.parentId) {\n      this.parentId = null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n\n      this.archived = data.thread_metadata.archived;\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?number}\n       */\n\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n\n      this.archiveTimestamp = new Date(data.thread_metadata.archive_timestamp).getTime();\n    } else {\n      if (!this.locked) {\n        this.locked = null;\n      }\n\n      if (!this.archived) {\n        this.archived = null;\n      }\n\n      if (!this.autoArchiveDuration) {\n        this.autoArchiveDuration = null;\n      }\n\n      if (!this.archiveTimestamp) {\n        this.archiveTimestamp = null;\n      }\n    }\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else if (!this.ownerId) {\n      this.ownerId = null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else if (!this.lastMessageId) {\n      this.lastMessageId = null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    } else if (!this.lastPinTimestamp) {\n      this.lastPinTimestamp = null;\n    }\n\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The ratelimit per user for this thread (in seconds)\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else if (!this.rateLimitPerUser) {\n      this.rateLimitPerUser = null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else if (!this.messageCount) {\n      this.messageCount = null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else if (!this.memberCount) {\n      this.memberCount = null;\n    }\n\n    if (data.member && this.client.user) this.members._add({\n      user_id: this.client.user.id,\n      ...data.member\n    });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n  }\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get archivedAt() {\n    if (!this.archiveTimestamp) return null;\n    return new Date(this.archiveTimestamp);\n  }\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel)}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n\n\n  permissionsFor(memberOrRole) {\n    return this.parent?.permissionsFor(memberOrRole) ?? null;\n  }\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {FetchOwnerOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n\n\n  async fetchOwner() {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    } // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n\n\n    const members = await this.members.fetch(cache);\n    return members.get(this.ownerId) ?? null;\n  }\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @param {string} [reason] Reason for editing this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    let autoArchiveDuration = data.autoArchiveDuration;\n\n    if (data.autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n\n      if (this.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked\n      },\n      reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n\n\n  setArchived() {\n    let archived = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      archived\n    }, reason);\n  }\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(60)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n\n\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({\n      autoArchiveDuration\n    }, reason);\n  }\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with `SEND_MESSAGES` permission.\n   * When a thread is locked only members with `MANAGE_THREADS` can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n\n\n  setLocked() {\n    let locked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      locked\n    }, reason);\n  }\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets the rate limit per user for this thread.\n   * @param {number} rateLimitPerUser The new ratelimit in seconds\n   * @param {string} [reason] Reason for changing the thread's ratelimits\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser\n    }, reason);\n  }\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.ownerId === this.client.user.id && (this.type !== 'private_thread' || this.joined) || this.manageable;\n  }\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joinable() {\n    return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === 'GUILD_PRIVATE_THREAD' ? Permissions.FLAGS.MANAGE_THREADS : Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    return this.permissionsFor(this.client.user)?.has(Permissions.FLAGS.MANAGE_THREADS, false);\n  }\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get sendable() {\n    return !this.archived && (this.type !== 'private_thread' || this.joined || this.manageable) && this.permissionsFor(this.client.user)?.any([Permissions.FLAGS.SEND_MESSAGES, this.type === 'GUILD_PRIVATE_THREAD' ? Permissions.FLAGS.USE_PRIVATE_THREADS : Permissions.FLAGS.USE_PUBLIC_THREADS], false);\n  }\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get unarchivable() {\n    return this.archived && (this.locked ? this.manageable : this.sendable);\n  }\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n\n\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({\n      reason\n    });\n    return this;\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendTyping() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentCollector() {}\n\n  awaitMessageComponent() {}\n\n  bulkDelete() {}\n\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true);\nmodule.exports = ThreadChannel;","map":{"version":3,"names":["Channel","require","TextBasedChannel","MessageManager","ThreadMemberManager","Permissions","ThreadChannel","constructor","guild","data","client","fromInteraction","guildId","id","guild_id","messages","members","_patch","partial","name","parentId","parent_id","locked","thread_metadata","archived","autoArchiveDuration","auto_archive_duration","archiveTimestamp","Date","archive_timestamp","getTime","ownerId","owner_id","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","rateLimitPerUser","rate_limit_per_user","messageCount","message_count","memberCount","member_count","member","user","_add","user_id","message","guildMembers","cache","mapValues","guildMember","archivedAt","parent","channels","resolve","join","add","leave","remove","permissionsFor","memberOrRole","fetchOwner","force","existing","get","fetch","edit","reason","features","includes","newData","api","patch","trim","actions","ChannelUpdate","handle","updated","setArchived","setAutoArchiveDuration","setLocked","setName","setRateLimitPerUser","joined","has","editable","type","manageable","joinable","FLAGS","MANAGE_THREADS","VIEW_CHANNEL","sendable","any","SEND_MESSAGES","USE_PRIVATE_THREADS","USE_PUBLIC_THREADS","unarchivable","delete","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","applyToClass","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/ThreadChannel.js"],"sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the thread channel is part of\n   * @param {APIChannel} data The data for the thread channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   * @param {boolean} [fromInteraction=false] Whether the data was from an interaction (partial)\n   */\n  constructor(guild, data, client, fromInteraction = false) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n\n  _patch(data, partial = false) {\n    super._patch(data);\n\n    /**\n     * The name of the thread\n     * @type {string}\n     */\n    this.name = data.name;\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else if (!this.parentId) {\n      this.parentId = null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?number}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = new Date(data.thread_metadata.archive_timestamp).getTime();\n    } else {\n      if (!this.locked) {\n        this.locked = null;\n      }\n      if (!this.archived) {\n        this.archived = null;\n      }\n      if (!this.autoArchiveDuration) {\n        this.autoArchiveDuration = null;\n      }\n      if (!this.archiveTimestamp) {\n        this.archiveTimestamp = null;\n      }\n    }\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else if (!this.ownerId) {\n      this.ownerId = null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else if (!this.lastMessageId) {\n      this.lastMessageId = null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    } else if (!this.lastPinTimestamp) {\n      this.lastPinTimestamp = null;\n    }\n\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The ratelimit per user for this thread (in seconds)\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else if (!this.rateLimitPerUser) {\n      this.rateLimitPerUser = null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else if (!this.messageCount) {\n      this.messageCount = null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else if (!this.memberCount) {\n      this.memberCount = null;\n    }\n\n    if (data.member && this.client.user) this.members._add({ user_id: this.client.user.id, ...data.member });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    if (!this.archiveTimestamp) return null;\n    return new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole) {\n    return this.parent?.permissionsFor(memberOrRole) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {FetchOwnerOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner({ cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch(cache);\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @param {string} [reason] Reason for editing this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    let autoArchiveDuration = data.autoArchiveDuration;\n    if (data.autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n      if (this.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked,\n      },\n      reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived(archived = true, reason) {\n    return this.edit({ archived }, reason);\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(60)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({ autoArchiveDuration }, reason);\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with `SEND_MESSAGES` permission.\n   * When a thread is locked only members with `MANAGE_THREADS` can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked(locked = true, reason) {\n    return this.edit({ locked }, reason);\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets the rate limit per user for this thread.\n   * @param {number} rateLimitPerUser The new ratelimit in seconds\n   * @param {string} [reason] Reason for changing the thread's ratelimits\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({ rateLimitPerUser }, reason);\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return (this.ownerId === this.client.user.id && (this.type !== 'private_thread' || this.joined)) || this.manageable;\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return (\n      !this.archived &&\n      !this.joined &&\n      this.permissionsFor(this.client.user)?.has(\n        this.type === 'GUILD_PRIVATE_THREAD' ? Permissions.FLAGS.MANAGE_THREADS : Permissions.FLAGS.VIEW_CHANNEL,\n        false,\n      )\n    );\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    return this.permissionsFor(this.client.user)?.has(Permissions.FLAGS.MANAGE_THREADS, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    return (\n      !this.archived &&\n      (this.type !== 'private_thread' || this.joined || this.manageable) &&\n      this.permissionsFor(this.client.user)?.any(\n        [\n          Permissions.FLAGS.SEND_MESSAGES,\n          this.type === 'GUILD_PRIVATE_THREAD'\n            ? Permissions.FLAGS.USE_PRIVATE_THREADS\n            : Permissions.FLAGS.USE_PUBLIC_THREADS,\n        ],\n        false,\n      )\n    );\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && (this.locked ? this.manageable : this.sendable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({ reason });\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true);\n\nmodule.exports = ThreadChannel;\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,+BAAD,CAAhC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,4BAAD,CAA9B;;AACA,MAAMG,mBAAmB,GAAGH,OAAO,CAAC,iCAAD,CAAnC;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,qBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,aAAN,SAA4BN,OAA5B,CAAoC;EAClC;AACF;AACA;AACA;AACA;AACA;EACEO,WAAW,CAACC,KAAD,EAAQC,IAAR,EAAcC,MAAd,EAA+C;IAAA,IAAzBC,eAAyB,uEAAP,KAAO;IACxD,MAAMH,KAAK,EAAEE,MAAP,IAAiBA,MAAvB,EAA+BD,IAA/B,EAAqC,KAArC;IAEA;AACJ;AACA;AACA;;IACI,KAAKD,KAAL,GAAaA,KAAb;IAEA;AACJ;AACA;AACA;;IACI,KAAKI,OAAL,GAAeJ,KAAK,EAAEK,EAAP,IAAaJ,IAAI,CAACK,QAAjC;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,QAAL,GAAgB,IAAIZ,cAAJ,CAAmB,IAAnB,CAAhB;IAEA;AACJ;AACA;AACA;;IACI,KAAKa,OAAL,GAAe,IAAIZ,mBAAJ,CAAwB,IAAxB,CAAf;IACA,IAAIK,IAAJ,EAAU,KAAKQ,MAAL,CAAYR,IAAZ,EAAkBE,eAAlB;EACX;;EAEDM,MAAM,CAACR,IAAD,EAAwB;IAAA,IAAjBS,OAAiB,uEAAP,KAAO;;IAC5B,MAAMD,MAAN,CAAaR,IAAb;IAEA;AACJ;AACA;AACA;;;IACI,KAAKU,IAAL,GAAYV,IAAI,CAACU,IAAjB;;IAEA,IAAI,cAAcV,IAAlB,EAAwB;MACtB,KAAKG,OAAL,GAAeH,IAAI,CAACK,QAApB;IACD;;IAED,IAAI,eAAeL,IAAnB,EAAyB;MACvB;AACN;AACA;AACA;MACM,KAAKW,QAAL,GAAgBX,IAAI,CAACY,SAArB;IACD,CAND,MAMO,IAAI,CAAC,KAAKD,QAAV,EAAoB;MACzB,KAAKA,QAAL,GAAgB,IAAhB;IACD;;IAED,IAAI,qBAAqBX,IAAzB,EAA+B;MAC7B;AACN;AACA;AACA;MACM,KAAKa,MAAL,GAAcb,IAAI,CAACc,eAAL,CAAqBD,MAArB,IAA+B,KAA7C;MAEA;AACN;AACA;AACA;;MACM,KAAKE,QAAL,GAAgBf,IAAI,CAACc,eAAL,CAAqBC,QAArC;MAEA;AACN;AACA;AACA;;MACM,KAAKC,mBAAL,GAA2BhB,IAAI,CAACc,eAAL,CAAqBG,qBAAhD;MAEA;AACN;AACA;AACA;AACA;AACA;;MACM,KAAKC,gBAAL,GAAwB,IAAIC,IAAJ,CAASnB,IAAI,CAACc,eAAL,CAAqBM,iBAA9B,EAAiDC,OAAjD,EAAxB;IACD,CA1BD,MA0BO;MACL,IAAI,CAAC,KAAKR,MAAV,EAAkB;QAChB,KAAKA,MAAL,GAAc,IAAd;MACD;;MACD,IAAI,CAAC,KAAKE,QAAV,EAAoB;QAClB,KAAKA,QAAL,GAAgB,IAAhB;MACD;;MACD,IAAI,CAAC,KAAKC,mBAAV,EAA+B;QAC7B,KAAKA,mBAAL,GAA2B,IAA3B;MACD;;MACD,IAAI,CAAC,KAAKE,gBAAV,EAA4B;QAC1B,KAAKA,gBAAL,GAAwB,IAAxB;MACD;IACF;;IAED,IAAI,cAAclB,IAAlB,EAAwB;MACtB;AACN;AACA;AACA;MACM,KAAKsB,OAAL,GAAetB,IAAI,CAACuB,QAApB;IACD,CAND,MAMO,IAAI,CAAC,KAAKD,OAAV,EAAmB;MACxB,KAAKA,OAAL,GAAe,IAAf;IACD;;IAED,IAAI,qBAAqBtB,IAAzB,EAA+B;MAC7B;AACN;AACA;AACA;MACM,KAAKwB,aAAL,GAAqBxB,IAAI,CAACyB,eAA1B;IACD,CAND,MAMO,IAAI,CAAC,KAAKD,aAAV,EAAyB;MAC9B,KAAKA,aAAL,GAAqB,IAArB;IACD;;IAED,IAAI,wBAAwBxB,IAA5B,EAAkC;MAChC;AACN;AACA;AACA;MACM,KAAK0B,gBAAL,GAAwB1B,IAAI,CAAC2B,kBAAL,GAA0B,IAAIR,IAAJ,CAASnB,IAAI,CAAC2B,kBAAd,EAAkCN,OAAlC,EAA1B,GAAwE,IAAhG;IACD,CAND,MAMO,IAAI,CAAC,KAAKK,gBAAV,EAA4B;MACjC,KAAKA,gBAAL,GAAwB,IAAxB;IACD;;IAED,IAAI,yBAAyB1B,IAAzB,IAAiC,CAACS,OAAtC,EAA+C;MAC7C;AACN;AACA;AACA;MACM,KAAKmB,gBAAL,GAAwB5B,IAAI,CAAC6B,mBAAL,IAA4B,CAApD;IACD,CAND,MAMO,IAAI,CAAC,KAAKD,gBAAV,EAA4B;MACjC,KAAKA,gBAAL,GAAwB,IAAxB;IACD;;IAED,IAAI,mBAAmB5B,IAAvB,EAA6B;MAC3B;AACN;AACA;AACA;AACA;AACA;MACM,KAAK8B,YAAL,GAAoB9B,IAAI,CAAC+B,aAAzB;IACD,CARD,MAQO,IAAI,CAAC,KAAKD,YAAV,EAAwB;MAC7B,KAAKA,YAAL,GAAoB,IAApB;IACD;;IAED,IAAI,kBAAkB9B,IAAtB,EAA4B;MAC1B;AACN;AACA;AACA;AACA;AACA;MACM,KAAKgC,WAAL,GAAmBhC,IAAI,CAACiC,YAAxB;IACD,CARD,MAQO,IAAI,CAAC,KAAKD,WAAV,EAAuB;MAC5B,KAAKA,WAAL,GAAmB,IAAnB;IACD;;IAED,IAAIhC,IAAI,CAACkC,MAAL,IAAe,KAAKjC,MAAL,CAAYkC,IAA/B,EAAqC,KAAK5B,OAAL,CAAa6B,IAAb,CAAkB;MAAEC,OAAO,EAAE,KAAKpC,MAAL,CAAYkC,IAAZ,CAAiB/B,EAA5B;MAAgC,GAAGJ,IAAI,CAACkC;IAAxC,CAAlB;IACrC,IAAIlC,IAAI,CAACM,QAAT,EAAmB,KAAK,MAAMgC,OAAX,IAAsBtC,IAAI,CAACM,QAA3B,EAAqC,KAAKA,QAAL,CAAc8B,IAAd,CAAmBE,OAAnB;EACzD;EAED;AACF;AACA;AACA;AACA;;;EACkB,IAAZC,YAAY,GAAG;IACjB,OAAO,KAAKhC,OAAL,CAAaiC,KAAb,CAAmBC,SAAnB,CAA6BP,MAAM,IAAIA,MAAM,CAACQ,WAA9C,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACgB,IAAVC,UAAU,GAAG;IACf,IAAI,CAAC,KAAKzB,gBAAV,EAA4B,OAAO,IAAP;IAC5B,OAAO,IAAIC,IAAJ,CAAS,KAAKD,gBAAd,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACY,IAAN0B,MAAM,GAAG;IACX,OAAO,KAAK7C,KAAL,CAAW8C,QAAX,CAAoBC,OAApB,CAA4B,KAAKnC,QAAjC,CAAP;EACD;EAED;AACF;AACA;AACA;;;EACY,MAAJoC,IAAI,GAAG;IACX,MAAM,KAAKxC,OAAL,CAAayC,GAAb,CAAiB,KAAjB,CAAN;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;;;EACa,MAALC,KAAK,GAAG;IACZ,MAAM,KAAK1C,OAAL,CAAa2C,MAAb,CAAoB,KAApB,CAAN;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,cAAc,CAACC,YAAD,EAAe;IAC3B,OAAO,KAAKR,MAAL,EAAaO,cAAb,CAA4BC,YAA5B,KAA6C,IAApD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACkB,MAAVC,UAAU,GAAuC;IAAA,IAAtC;MAAEb,KAAK,GAAG,IAAV;MAAgBc,KAAK,GAAG;IAAxB,CAAsC,uEAAJ,EAAI;;IACrD,IAAI,CAACA,KAAL,EAAY;MACV,MAAMC,QAAQ,GAAG,KAAKhD,OAAL,CAAaiC,KAAb,CAAmBgB,GAAnB,CAAuB,KAAKlC,OAA5B,CAAjB;MACA,IAAIiC,QAAJ,EAAc,OAAOA,QAAP;IACf,CAJoD,CAMrD;;;IACA,MAAMhD,OAAO,GAAG,MAAM,KAAKA,OAAL,CAAakD,KAAb,CAAmBjB,KAAnB,CAAtB;IACA,OAAOjC,OAAO,CAACiD,GAAR,CAAY,KAAKlC,OAAjB,KAA6B,IAApC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACY,MAAJoC,IAAI,CAAC1D,IAAD,EAAO2D,MAAP,EAAe;IACvB,IAAI3C,mBAAmB,GAAGhB,IAAI,CAACgB,mBAA/B;;IACA,IAAIhB,IAAI,CAACgB,mBAAL,KAA6B,KAAjC,EAAwC;MACtCA,mBAAmB,GAAG,IAAtB;;MACA,IAAI,KAAKjB,KAAL,CAAW6D,QAAX,CAAoBC,QAApB,CAA6B,0BAA7B,CAAJ,EAA8D;QAC5D7C,mBAAmB,GAAG,KAAtB;MACD,CAFD,MAEO,IAAI,KAAKjB,KAAL,CAAW6D,QAAX,CAAoBC,QAApB,CAA6B,0BAA7B,CAAJ,EAA8D;QACnE7C,mBAAmB,GAAG,IAAtB;MACD;IACF;;IACD,MAAM8C,OAAO,GAAG,MAAM,KAAK7D,MAAL,CAAY8D,GAAZ,CAAgBlB,QAAhB,CAAyB,KAAKzC,EAA9B,EAAkC4D,KAAlC,CAAwC;MAC5DhE,IAAI,EAAE;QACJU,IAAI,EAAE,CAACV,IAAI,CAACU,IAAL,IAAa,KAAKA,IAAnB,EAAyBuD,IAAzB,EADF;QAEJlD,QAAQ,EAAEf,IAAI,CAACe,QAFX;QAGJE,qBAAqB,EAAED,mBAHnB;QAIJa,mBAAmB,EAAE7B,IAAI,CAAC4B,gBAJtB;QAKJf,MAAM,EAAEb,IAAI,CAACa;MALT,CADsD;MAQ5D8C;IAR4D,CAAxC,CAAtB;IAWA,OAAO,KAAK1D,MAAL,CAAYiE,OAAZ,CAAoBC,aAApB,CAAkCC,MAAlC,CAAyCN,OAAzC,EAAkDO,OAAzD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,WAAW,GAA0B;IAAA,IAAzBvD,QAAyB,uEAAd,IAAc;IAAA,IAAR4C,MAAQ;IACnC,OAAO,KAAKD,IAAL,CAAU;MAAE3C;IAAF,CAAV,EAAwB4C,MAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEY,sBAAsB,CAACvD,mBAAD,EAAsB2C,MAAtB,EAA8B;IAClD,OAAO,KAAKD,IAAL,CAAU;MAAE1C;IAAF,CAAV,EAAmC2C,MAAnC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEa,SAAS,GAAwB;IAAA,IAAvB3D,MAAuB,uEAAd,IAAc;IAAA,IAAR8C,MAAQ;IAC/B,OAAO,KAAKD,IAAL,CAAU;MAAE7C;IAAF,CAAV,EAAsB8C,MAAtB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEc,OAAO,CAAC/D,IAAD,EAAOiD,MAAP,EAAe;IACpB,OAAO,KAAKD,IAAL,CAAU;MAAEhD;IAAF,CAAV,EAAoBiD,MAApB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEe,mBAAmB,CAAC9C,gBAAD,EAAmB+B,MAAnB,EAA2B;IAC5C,OAAO,KAAKD,IAAL,CAAU;MAAE9B;IAAF,CAAV,EAAgC+B,MAAhC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACY,IAANgB,MAAM,GAAG;IACX,OAAO,KAAKpE,OAAL,CAAaiC,KAAb,CAAmBoC,GAAnB,CAAuB,KAAK3E,MAAL,CAAYkC,IAAZ,EAAkB/B,EAAzC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARyE,QAAQ,GAAG;IACb,OAAQ,KAAKvD,OAAL,KAAiB,KAAKrB,MAAL,CAAYkC,IAAZ,CAAiB/B,EAAlC,KAAyC,KAAK0E,IAAL,KAAc,gBAAd,IAAkC,KAAKH,MAAhF,CAAD,IAA6F,KAAKI,UAAzG;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARC,QAAQ,GAAG;IACb,OACE,CAAC,KAAKjE,QAAN,IACA,CAAC,KAAK4D,MADN,IAEA,KAAKxB,cAAL,CAAoB,KAAKlD,MAAL,CAAYkC,IAAhC,GAAuCyC,GAAvC,CACE,KAAKE,IAAL,KAAc,sBAAd,GAAuClF,WAAW,CAACqF,KAAZ,CAAkBC,cAAzD,GAA0EtF,WAAW,CAACqF,KAAZ,CAAkBE,YAD9F,EAEE,KAFF,CAHF;EAQD;EAED;AACF;AACA;AACA;AACA;;;EACgB,IAAVJ,UAAU,GAAG;IACf,OAAO,KAAK5B,cAAL,CAAoB,KAAKlD,MAAL,CAAYkC,IAAhC,GAAuCyC,GAAvC,CAA2ChF,WAAW,CAACqF,KAAZ,CAAkBC,cAA7D,EAA6E,KAA7E,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARE,QAAQ,GAAG;IACb,OACE,CAAC,KAAKrE,QAAN,KACC,KAAK+D,IAAL,KAAc,gBAAd,IAAkC,KAAKH,MAAvC,IAAiD,KAAKI,UADvD,KAEA,KAAK5B,cAAL,CAAoB,KAAKlD,MAAL,CAAYkC,IAAhC,GAAuCkD,GAAvC,CACE,CACEzF,WAAW,CAACqF,KAAZ,CAAkBK,aADpB,EAEE,KAAKR,IAAL,KAAc,sBAAd,GACIlF,WAAW,CAACqF,KAAZ,CAAkBM,mBADtB,GAEI3F,WAAW,CAACqF,KAAZ,CAAkBO,kBAJxB,CADF,EAOE,KAPF,CAHF;EAaD;EAED;AACF;AACA;AACA;AACA;;;EACkB,IAAZC,YAAY,GAAG;IACjB,OAAO,KAAK1E,QAAL,KAAkB,KAAKF,MAAL,GAAc,KAAKkE,UAAnB,GAAgC,KAAKK,QAAvD,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACc,MAANM,MAAM,CAAC/B,MAAD,EAAS;IACnB,MAAM,KAAK1D,MAAL,CAAY8D,GAAZ,CAAgBlB,QAAhB,CAAyB,KAAKzC,EAA9B,EAAkCsF,MAAlC,CAAyC;MAAE/B;IAAF,CAAzC,CAAN;IACA,OAAO,IAAP;EACD,CAhciC,CAkclC;;EACA;;;EACe,IAAXgC,WAAW,GAAG,CAAE;;EACP,IAATC,SAAS,GAAG,CAAE;;EAClBC,IAAI,GAAG,CAAE;;EACTC,UAAU,GAAG,CAAE;;EACfC,sBAAsB,GAAG,CAAE;;EAC3BC,aAAa,GAAG,CAAE;;EAClBC,+BAA+B,GAAG,CAAE;;EACpCC,qBAAqB,GAAG,CAAE;;EAC1BC,UAAU,GAAG,CAAE;;AA5cmB;;AA+cpC1G,gBAAgB,CAAC2G,YAAjB,CAA8BvG,aAA9B,EAA6C,IAA7C;AAEAwG,MAAM,CAACC,OAAP,GAAiBzG,aAAjB"},"metadata":{},"sourceType":"script"}