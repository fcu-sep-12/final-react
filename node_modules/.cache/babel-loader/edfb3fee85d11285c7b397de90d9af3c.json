{"ast":null,"code":"'use strict';\n\nconst {\n  RangeError\n} = require('../errors');\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\n\n\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.defaultBit] Bit(s) to read from\n   */\n  constructor() {\n    let bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.constructor.defaultBit;\n\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.defaultBit;\n  }\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  missing(bits) {\n    for (var _len = arguments.length, hasParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      hasParams[_key - 1] = arguments[_key];\n    }\n\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n\n\n  freeze() {\n    return Object.freeze(this);\n  }\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  add() {\n    let total = this.constructor.defaultBit;\n\n    for (var _len2 = arguments.length, bits = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      bits[_key2] = arguments[_key2];\n    }\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n\n\n  remove() {\n    let total = this.constructor.defaultBit;\n\n    for (var _len3 = arguments.length, bits = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      bits[_key3] = arguments[_key3];\n    }\n\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n\n\n  serialize() {\n    const serialized = {};\n\n    for (var _len4 = arguments.length, hasParams = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      hasParams[_key4] = arguments[_key4];\n    }\n\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n\n    return serialized;\n  }\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n\n\n  toArray() {\n    for (var _len5 = arguments.length, hasParams = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      hasParams[_key5] = arguments[_key5];\n    }\n\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.FLAGS})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] - bit(s) to resolve\n   * @returns {number|bigint}\n   */\n\n\n  static resolve(bit) {\n    const {\n      defaultBit\n    } = this;\n    if (typeof defaultBit === typeof bit && bit >= defaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, defaultBit);\n\n    if (typeof bit === 'string') {\n      if (typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n      if (!isNaN(bit)) return typeof defaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n    }\n\n    throw new RangeError('BITFIELD_INVALID', bit);\n  }\n\n}\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\n\n\nBitField.FLAGS = {};\n/**\n * @type {number|bigint}\n * @private\n */\n\nBitField.defaultBit = 0;\nmodule.exports = BitField;","map":{"version":3,"names":["RangeError","require","BitField","constructor","bits","defaultBit","bitfield","resolve","any","bit","equals","has","missing","hasParams","remove","toArray","freeze","Object","add","total","isFrozen","serialize","serialized","flag","entries","FLAGS","keys","filter","toJSON","toString","valueOf","Symbol","iterator","Array","isArray","map","p","reduce","prev","isNaN","BigInt","Number","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/util/BitField.js"],"sourcesContent":["'use strict';\n\nconst { RangeError } = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.defaultBit] Bit(s) to read from\n   */\n  constructor(bits = this.constructor.defaultBit) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.defaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = this.constructor.defaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = this.constructor.defaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.FLAGS})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] - bit(s) to resolve\n   * @returns {number|bigint}\n   */\n  static resolve(bit) {\n    const { defaultBit } = this;\n    if (typeof defaultBit === typeof bit && bit >= defaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, defaultBit);\n    if (typeof bit === 'string') {\n      if (typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n      if (!isNaN(bit)) return typeof defaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n    }\n    throw new RangeError('BITFIELD_INVALID', bit);\n  }\n}\n\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\nBitField.FLAGS = {};\n\n/**\n * @type {number|bigint}\n * @private\n */\nBitField.defaultBit = 0;\n\nmodule.exports = BitField;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}