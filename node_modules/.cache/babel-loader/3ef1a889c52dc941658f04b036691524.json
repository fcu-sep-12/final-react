{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst Role = require('../structures/Role');\n\nconst Permissions = require('../util/Permissions');\n\nconst {\n  resolveColor,\n  setPosition\n} = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\n\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n\n\n    this.guild = guild;\n  }\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    } // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n\n\n    const data = await this.client.api.guilds(this.guild.id).roles.get();\n    const roles = new Collection();\n\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n\n    return id ? roles.get(id) ?? null : roles;\n  }\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: 'BLUE',\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async create() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      name,\n      color,\n      hoist,\n      permissions,\n      position,\n      mentionable,\n      reason\n    } = options;\n    if (color) color = resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new Permissions(permissions);\n    const data = await this.client.api.guilds(this.guild.id).roles.post({\n      data: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable\n      },\n      reason\n    });\n    const {\n      role\n    } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data\n    });\n    if (position) return role.setPosition(position, reason);\n    return role;\n  }\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async edit(role, data, reason) {\n    role = this.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'RoleResolvable');\n\n    if (typeof data.position === 'number') {\n      const updatedRoles = await setPosition(role, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason);\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles\n      });\n    }\n\n    const _data = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new Permissions(data.permissions),\n      mentionable: data.mentionable\n    };\n    const d = await this.client.api.guilds(this.guild.id).roles(role.id).patch({\n      data: _data,\n      reason\n    });\n\n    const clone = role._clone();\n\n    clone._patch(d);\n\n    return clone;\n  }\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n\n\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n\n}\n\nmodule.exports = RoleManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","Role","Permissions","resolveColor","setPosition","cacheWarningEmitted","RoleManager","constructor","guild","iterable","client","_cache","name","process","emitWarning","_add","data","cache","extras","fetch","id","force","existing","get","api","guilds","roles","role","set","create","options","color","hoist","permissions","position","mentionable","reason","post","actions","GuildRoleCreate","handle","guild_id","edit","resolve","updatedRoles","_sortedRoles","GuildRolesPositionUpdate","_data","undefined","d","patch","clone","_clone","_patch","botRoleFor","user","userId","users","resolveId","find","tags","botId","everyone","premiumSubscriberRole","highest","reduce","prev","comparePositionTo","first","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/RoleManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst Role = require('../structures/Role');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor, setPosition } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.api.guilds(this.guild.id).roles.get();\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: 'BLUE',\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(options = {}) {\n    let { name, color, hoist, permissions, position, mentionable, reason } = options;\n    if (color) color = resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new Permissions(permissions);\n\n    const data = await this.client.api.guilds(this.guild.id).roles.post({\n      data: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n      },\n      reason,\n    });\n    const { role } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data,\n    });\n    if (position) return role.setPosition(position, reason);\n    return role;\n  }\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, data, reason) {\n    role = this.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'RoleResolvable');\n\n    if (typeof data.position === 'number') {\n      const updatedRoles = await setPosition(\n        role,\n        data.position,\n        false,\n        this.guild._sortedRoles(),\n        this.client.api.guilds(this.guild.id).roles,\n        reason,\n      );\n\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles,\n      });\n    }\n\n    const _data = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new Permissions(data.permissions),\n      mentionable: data.mentionable,\n    };\n\n    const d = await this.client.api.guilds(this.guild.id).roles(role.id).patch({ data: _data, reason });\n\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}