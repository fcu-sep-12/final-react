{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlashCommandBuilder = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst ts_mixer_1 = require(\"ts-mixer\");\n\nconst Assertions_1 = require(\"./Assertions\");\n\nconst NameAndDescription_1 = require(\"./mixins/NameAndDescription\");\n\nconst CommandOptions_1 = require(\"./mixins/CommandOptions\");\n\nconst SlashCommandSubcommands_1 = require(\"./SlashCommandSubcommands\");\n\nlet SlashCommandBuilder = class SlashCommandBuilder {\n  constructor() {\n    /**\n     * The name of this slash command\n     */\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: undefined\n    });\n    /**\n     * The description of this slash command\n     */\n\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: undefined\n    });\n    /**\n     * The options of this slash command\n     */\n\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  /**\n   * Returns the final data that should be sent to Discord.\n   *\n   * **Note:** Calling this function will validate required properties based on their conditions.\n   */\n\n\n  toJSON() {\n    Assertions_1.validateRequiredParameters(this.name, this.description, this.options);\n    return {\n      name: this.name,\n      description: this.description,\n      options: this.options.map(option => option.toJSON())\n    };\n  }\n  /**\n   * Adds a new subcommand group to this command\n   * @param input A function that returns a subcommand group builder, or an already built builder\n   */\n\n\n  addSubcommandGroup(input) {\n    const {\n      options\n    } = this; // First, assert options conditions - we cannot have more than 25 options\n\n    Assertions_1.validateMaxOptionsLength(options); // Make sure there is no subcommand at the root level - if there is, throw\n\n    const hasSubcommands = options.some(item => item instanceof SlashCommandSubcommands_1.SlashCommandSubcommandBuilder);\n    if (hasSubcommands) throw new RangeError(`You cannot mix subcommands and subcommand groups at the root level.`); // Get the final result\n\n    const result = typeof input === 'function' ? input(new SlashCommandSubcommands_1.SlashCommandSubcommandGroupBuilder()) : input;\n    Assertions_1.assertReturnOfBuilder(result, SlashCommandSubcommands_1.SlashCommandSubcommandGroupBuilder); // Push it\n\n    options.push(result);\n    return this;\n  }\n  /**\n   * Adds a new subcommand to this command\n   * @param input A function that returns a subcommand builder, or an already built builder\n   */\n\n\n  addSubcommand(input) {\n    const {\n      options\n    } = this; // First, assert options conditions - we cannot have more than 25 options\n\n    Assertions_1.validateMaxOptionsLength(options); // Make sure there is no subcommand at the root level - if there is, throw\n\n    const hasSubcommandGroups = options.some(item => item instanceof SlashCommandSubcommands_1.SlashCommandSubcommandGroupBuilder);\n    if (hasSubcommandGroups) throw new RangeError(`You cannot mix subcommands and subcommand groups at the root level.`); // Get the final result\n\n    const result = typeof input === 'function' ? input(new SlashCommandSubcommands_1.SlashCommandSubcommandBuilder()) : input;\n    Assertions_1.assertReturnOfBuilder(result, SlashCommandSubcommands_1.SlashCommandSubcommandBuilder); // Push it\n\n    options.push(result);\n    return this;\n  }\n\n};\nSlashCommandBuilder = tslib_1.__decorate([ts_mixer_1.mix(CommandOptions_1.SharedSlashCommandOptions, NameAndDescription_1.SharedNameAndDescription)], SlashCommandBuilder);\nexports.SlashCommandBuilder = SlashCommandBuilder;","map":{"version":3,"mappings":";;;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA,IAAaA,mBAAmB,GAAhC,MAAaA,mBAAb,CAAgC;EAAhCC;IACC;;;IAGAC;sBAAA;wBAAA;oBAAA;aAA+BC;IAA/B;IAEA;;;;IAGAD;sBAAA;wBAAA;oBAAA;aAAsCC;IAAtC;IAEA;;;;IAGAD;sBAAA;wBAAA;oBAAA;aAA4D;IAA5D;EA0EA;EAxEA;;;;;;;EAKOE,MAAM;IACZC,wCAA2B,KAAKC,IAAhC,EAAsC,KAAKC,WAA3C,EAAwD,KAAKC,OAA7D;IACA,OAAO;MACNF,IAAI,EAAE,KAAKA,IADL;MAENC,WAAW,EAAE,KAAKA,WAFZ;MAGNC,OAAO,EAAE,KAAKA,OAAL,CAAaC,GAAb,CAAkBC,MAAD,IAAYA,MAAM,CAACN,MAAP,EAA7B;IAHH,CAAP;EAKA;EAED;;;;;;EAIOO,kBAAkB,CACxBC,KADwB,EAGwE;IAEhG,MAAM;MAAEJ;IAAF,IAAc,IAApB,CAFgG,CAIhG;;IACAH,sCAAyBG,OAAzB,EALgG,CAOhG;;IACA,MAAMK,cAAc,GAAGL,OAAO,CAACM,IAAR,CAAcC,IAAD,IAAUA,IAAI,YAAYC,uDAAvC,CAAvB;IACA,IAAIH,cAAJ,EAAoB,MAAM,IAAII,UAAJ,CAAe,qEAAf,CAAN,CAT4E,CAWhG;;IACA,MAAMC,MAAM,GAAG,OAAON,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,CAAC,IAAII,4DAAJ,EAAD,CAAnC,GAAgFJ,KAA/F;IAEAP,mCAAsBa,MAAtB,EAA8BF,4DAA9B,EAdgG,CAgBhG;;IACAR,OAAO,CAACW,IAAR,CAAaD,MAAb;IAEA,OAAO,IAAP;EACA;EAED;;;;;;EAIOE,aAAa,CACnBR,KADmB,EAGmE;IAEtF,MAAM;MAAEJ;IAAF,IAAc,IAApB,CAFsF,CAItF;;IACAH,sCAAyBG,OAAzB,EALsF,CAOtF;;IACA,MAAMa,mBAAmB,GAAGb,OAAO,CAACM,IAAR,CAAcC,IAAD,IAAUA,IAAI,YAAYC,4DAAvC,CAA5B;IACA,IAAIK,mBAAJ,EACC,MAAM,IAAIJ,UAAJ,CAAe,qEAAf,CAAN,CAVqF,CAYtF;;IACA,MAAMC,MAAM,GAAG,OAAON,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,CAAC,IAAII,uDAAJ,EAAD,CAAnC,GAA2EJ,KAA1F;IAEAP,mCAAsBa,MAAtB,EAA8BF,uDAA9B,EAfsF,CAiBtF;;IACAR,OAAO,CAACW,IAAR,CAAaD,MAAb;IAEA,OAAO,IAAP;EACA;;AAvF8B,CAAhC;AAAalB,mBAAmB,uBAD/BsB,eAAIC,0CAAJ,EAA+BC,6CAA/B,CAC+B,GAAnBxB,mBAAmB,CAAnB;AAAAyB","names":["SlashCommandBuilder","constructor","Object","undefined","toJSON","Assertions_1","name","description","options","map","option","addSubcommandGroup","input","hasSubcommands","some","item","SlashCommandSubcommands_1","RangeError","result","push","addSubcommand","hasSubcommandGroups","ts_mixer_1","CommandOptions_1","NameAndDescription_1","exports"],"sources":["\\interactions\\slashCommands\\SlashCommandBuilder.ts"],"sourcesContent":["import type { APIApplicationCommandOption } from 'discord-api-types/v9';\nimport { mix } from 'ts-mixer';\nimport { assertReturnOfBuilder, validateMaxOptionsLength, validateRequiredParameters } from './Assertions';\nimport { SharedNameAndDescription } from './mixins/NameAndDescription';\nimport { SharedSlashCommandOptions } from './mixins/CommandOptions';\nimport { SlashCommandSubcommandBuilder, SlashCommandSubcommandGroupBuilder } from './SlashCommandSubcommands';\n\n@mix(SharedSlashCommandOptions, SharedNameAndDescription)\nexport class SlashCommandBuilder {\n\t/**\n\t * The name of this slash command\n\t */\n\tpublic readonly name: string = undefined!;\n\n\t/**\n\t * The description of this slash command\n\t */\n\tpublic readonly description: string = undefined!;\n\n\t/**\n\t * The options of this slash command\n\t */\n\tpublic readonly options: ToAPIApplicationCommandOptions[] = [];\n\n\t/**\n\t * Returns the final data that should be sent to Discord.\n\t *\n\t * **Note:** Calling this function will validate required properties based on their conditions.\n\t */\n\tpublic toJSON() {\n\t\tvalidateRequiredParameters(this.name, this.description, this.options);\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tdescription: this.description,\n\t\t\toptions: this.options.map((option) => option.toJSON()),\n\t\t};\n\t}\n\n\t/**\n\t * Adds a new subcommand group to this command\n\t * @param input A function that returns a subcommand group builder, or an already built builder\n\t */\n\tpublic addSubcommandGroup(\n\t\tinput:\n\t\t\t| SlashCommandSubcommandGroupBuilder\n\t\t\t| ((subcommandGroup: SlashCommandSubcommandGroupBuilder) => SlashCommandSubcommandGroupBuilder),\n\t): SlashCommandSubcommandGroupsOnlyBuilder {\n\t\tconst { options } = this;\n\n\t\t// First, assert options conditions - we cannot have more than 25 options\n\t\tvalidateMaxOptionsLength(options);\n\n\t\t// Make sure there is no subcommand at the root level - if there is, throw\n\t\tconst hasSubcommands = options.some((item) => item instanceof SlashCommandSubcommandBuilder);\n\t\tif (hasSubcommands) throw new RangeError(`You cannot mix subcommands and subcommand groups at the root level.`);\n\n\t\t// Get the final result\n\t\tconst result = typeof input === 'function' ? input(new SlashCommandSubcommandGroupBuilder()) : input;\n\n\t\tassertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);\n\n\t\t// Push it\n\t\toptions.push(result);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a new subcommand to this command\n\t * @param input A function that returns a subcommand builder, or an already built builder\n\t */\n\tpublic addSubcommand(\n\t\tinput:\n\t\t\t| SlashCommandSubcommandBuilder\n\t\t\t| ((subcommandGroup: SlashCommandSubcommandBuilder) => SlashCommandSubcommandBuilder),\n\t): SlashCommandSubcommandsOnlyBuilder {\n\t\tconst { options } = this;\n\n\t\t// First, assert options conditions - we cannot have more than 25 options\n\t\tvalidateMaxOptionsLength(options);\n\n\t\t// Make sure there is no subcommand at the root level - if there is, throw\n\t\tconst hasSubcommandGroups = options.some((item) => item instanceof SlashCommandSubcommandGroupBuilder);\n\t\tif (hasSubcommandGroups)\n\t\t\tthrow new RangeError(`You cannot mix subcommands and subcommand groups at the root level.`);\n\n\t\t// Get the final result\n\t\tconst result = typeof input === 'function' ? input(new SlashCommandSubcommandBuilder()) : input;\n\n\t\tassertReturnOfBuilder(result, SlashCommandSubcommandBuilder);\n\n\t\t// Push it\n\t\toptions.push(result);\n\n\t\treturn this;\n\t}\n}\n\nexport interface SlashCommandBuilder extends SharedNameAndDescription, SharedSlashCommandOptions {}\n\nexport interface SlashCommandSubcommandsOnlyBuilder\n\textends SharedNameAndDescription,\n\t\tPick<SlashCommandBuilder, 'toJSON' | 'addSubcommand'> {}\n\nexport interface SlashCommandSubcommandGroupsOnlyBuilder\n\textends SharedNameAndDescription,\n\t\tPick<SlashCommandBuilder, 'toJSON' | 'addSubcommandGroup'> {}\n\nexport interface SlashCommandOptionsOnlyBuilder\n\textends SharedNameAndDescription,\n\t\tSharedSlashCommandOptions,\n\t\tPick<SlashCommandBuilder, 'toJSON'> {}\n\nexport interface ToAPIApplicationCommandOptions {\n\ttoJSON(): APIApplicationCommandOption;\n}\n"]},"metadata":{},"sourceType":"script"}