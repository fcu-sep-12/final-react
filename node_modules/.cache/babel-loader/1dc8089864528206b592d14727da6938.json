{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n/**\n * The AsyncQueue class used to sequentialize burst requests\n */\n\nclass AsyncQueue {\n  constructor() {\n    /**\n     * The promises array\n     */\n    Object.defineProperty(this, \"promises\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  /**\n   * The remaining amount of queued promises\n   */\n\n\n  get remaining() {\n    return this.promises.length;\n  }\n  /**\n   * Waits for last promise and queues a new one\n   * @example\n   * ```\n   * const queue = new AsyncQueue();\n   * async function request(url, options) {\n   *     await queue.wait();\n   *     try {\n   *         const result = await fetch(url, options);\n   *         // Do some operations with 'result'\n   *     } finally {\n   *         // Remove first entry from the queue and resolve for the next entry\n   *         queue.shift();\n   *     }\n   * }\n   *\n   * request(someUrl1, someOptions1); // Will call fetch() immediately\n   * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n   * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n   * ```\n   */\n\n\n  wait() {\n    const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();\n    let resolve;\n    const promise = new Promise(res => {\n      resolve = res;\n    });\n    this.promises.push({\n      resolve: resolve,\n      promise\n    });\n    return next;\n  }\n  /**\n   * Frees the queue's lock for the next item to process\n   */\n\n\n  shift() {\n    const deferred = this.promises.shift();\n    if (typeof deferred !== 'undefined') deferred.resolve();\n  }\n\n}\n\nexports.AsyncQueue = AsyncQueue;","map":{"version":3,"mappings":";;;;;AAAA;;;;MAGaA,WAAU;EAAvBC;;;;IAWCC;sBAAA;wBAAA;oBAAA;aAAwD;IAAxD;EA6CA;;;;;;EApDoB,IAATC,SAAS;IACnB,OAAO,KAAKC,QAAL,CAAcC,MAArB;EACA;;;;;;;;;;;;;;;;;;;;;;;;EA4BMC,IAAI;IACV,MAAMC,IAAI,GAAG,KAAKH,QAAL,CAAcC,MAAd,GAAuB,KAAKD,QAAL,CAAc,KAAKA,QAAL,CAAcC,MAAd,GAAuB,CAArC,EAAwCG,OAA/D,GAAyEC,OAAO,CAACC,OAAR,EAAtF;IACA,IAAIA,OAAJ;IACA,MAAMF,OAAO,GAAG,IAAIC,OAAJ,CAAmBE,GAAD,IAAI;MACrCD,OAAO,GAAGC,GAAV;IACA,CAFe,CAAhB;IAIA,KAAKP,QAAL,CAAcQ,IAAd,CAAmB;MAClBF,OAAO,EAAEA,OADS;MAElBF;IAFkB,CAAnB;IAKA,OAAOD,IAAP;EACA;;;;;;EAKMM,KAAK;IACX,MAAMC,QAAQ,GAAG,KAAKV,QAAL,CAAcS,KAAd,EAAjB;IACA,IAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqCA,QAAQ,CAACJ,OAAT;EACrC;;AAvDqB","names":["AsyncQueue","constructor","Object","remaining","promises","length","wait","next","promise","Promise","resolve","res","push","shift","deferred"],"sources":["C:\\Users\\ROUSER6\\node_modules\\@sapphire\\async-queue\\src\\lib\\AsyncQueue.ts"],"sourcesContent":["/**\n * The AsyncQueue class used to sequentialize burst requests\n */\nexport class AsyncQueue {\n\t/**\n\t * The remaining amount of queued promises\n\t */\n\tpublic get remaining(): number {\n\t\treturn this.promises.length;\n\t}\n\n\t/**\n\t * The promises array\n\t */\n\tprivate promises: InternalAsyncQueueDeferredPromise[] = [];\n\n\t/**\n\t * Waits for last promise and queues a new one\n\t * @example\n\t * ```\n\t * const queue = new AsyncQueue();\n\t * async function request(url, options) {\n\t *     await queue.wait();\n\t *     try {\n\t *         const result = await fetch(url, options);\n\t *         // Do some operations with 'result'\n\t *     } finally {\n\t *         // Remove first entry from the queue and resolve for the next entry\n\t *         queue.shift();\n\t *     }\n\t * }\n\t *\n\t * request(someUrl1, someOptions1); // Will call fetch() immediately\n\t * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n\t * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n\t * ```\n\t */\n\tpublic wait(): Promise<void> {\n\t\tconst next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();\n\t\tlet resolve: () => void;\n\t\tconst promise = new Promise<void>((res) => {\n\t\t\tresolve = res;\n\t\t});\n\n\t\tthis.promises.push({\n\t\t\tresolve: resolve!,\n\t\t\tpromise\n\t\t});\n\n\t\treturn next;\n\t}\n\n\t/**\n\t * Frees the queue's lock for the next item to process\n\t */\n\tpublic shift(): void {\n\t\tconst deferred = this.promises.shift();\n\t\tif (typeof deferred !== 'undefined') deferred.resolve();\n\t}\n}\n\n/**\n * @internal\n */\ninterface InternalAsyncQueueDeferredPromise {\n\tresolve(): void;\n\tpromise: Promise<void>;\n}\n"]},"metadata":{},"sourceType":"script"}