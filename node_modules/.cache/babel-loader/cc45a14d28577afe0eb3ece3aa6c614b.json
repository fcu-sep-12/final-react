{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Shard = require('./Shard');\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\n\nconst Util = require('../util/Util');\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\n\n\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    options = Util.mergeDefault({\n      totalShards: 'auto',\n      mode: 'process',\n      respawn: true,\n      shardArgs: [],\n      execArgv: [],\n      token: process.env.DISCORD_TOKEN\n    }, options);\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n\n    this.file = file;\n    if (!file) throw new Error('CLIENT_INVALID_OPTION', 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION', 'File', 'a file');\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n\n    this.shardList = options.shardList ?? 'auto';\n\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array.');\n      }\n\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'shardList', 'at least 1 id.');\n\n      if (this.shardList.some(shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array of positive integers.');\n      }\n    }\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n\n\n    this.totalShards = options.totalShards || 'auto';\n\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n\n      if (this.totalShards < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n\n      if (!Number.isInteger(this.totalShards)) {\n        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n\n\n    this.mode = options.mode;\n\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Sharding mode', '\"process\" or \"worker\"');\n    }\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n\n\n    this.respawn = options.respawn;\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.shardArgs = options.shardArgs;\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.execArgv = options.execArgv;\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n\n    this.shards = new Collection();\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n\n\n  createShard() {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.shards.size;\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n  /**\n   * Option used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n\n\n  async spawn() {\n    let {\n      amount = this.totalShards,\n      delay = 5500,\n      timeout = 30000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await Util.fetchRecommendedShards(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n\n      if (amount < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n\n      if (!Number.isInteger(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    } // Make sure this many shards haven't already been spawned\n\n\n    if (this.shards.size >= amount) throw new Error('SHARDING_ALREADY_SPAWNED', this.shards.size);\n\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'bigger than the highest shardId in the shardList option.');\n    } // Spawn the shards\n\n\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(Util.delayFor(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n\n\n  broadcast(message) {\n    const promises = [];\n\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n\n    return Promise.all(promises);\n  }\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n\n\n  broadcastEval(script) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof script !== 'function') return Promise.reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n\n\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n\n\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new Error('SHARDING_NO_SHARDS'));\n\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new Error('SHARDING_SHARD_NOT_FOUND', shard));\n    }\n\n    if (this.shards.size !== this.shardList.length) return Promise.reject(new Error('SHARDING_IN_PROCESS'));\n    const promises = [];\n\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n\n    return Promise.all(promises);\n  }\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<string, Shard>>}\n   */\n\n\n  async respawnAll() {\n    let {\n      shardDelay = 5000,\n      respawnDelay = 500,\n      timeout = 30000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let s = 0;\n\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({\n        respawnDelay,\n        timeout\n      })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(Util.delayFor(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n}\n\nmodule.exports = ShardingManager;","map":{"version":3,"names":["EventEmitter","require","fs","path","Collection","Shard","Error","TypeError","RangeError","Util","ShardingManager","constructor","file","options","mergeDefault","totalShards","mode","respawn","shardArgs","execArgv","token","process","env","DISCORD_TOKEN","isAbsolute","resolve","cwd","stats","statSync","isFile","shardList","Array","isArray","Set","length","some","shardId","isNaN","Number","isInteger","replace","shards","SHARDING_MANAGER","SHARDING_MANAGER_MODE","createShard","id","size","shard","set","emit","spawn","amount","delay","timeout","fetchRecommendedShards","keys","promises","push","delayFor","Promise","all","broadcast","message","values","send","broadcastEval","script","reject","_performOnShards","JSON","stringify","context","fetchClientValues","prop","method","args","has","get","sh","respawnAll","shardDelay","respawnDelay","s","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/sharding/ShardingManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst path = require('path');\nconst { Collection } = require('@discordjs/collection');\nconst Shard = require('./Shard');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst Util = require('../util/Util');\n\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file, options = {}) {\n    super();\n    options = Util.mergeDefault(\n      {\n        totalShards: 'auto',\n        mode: 'process',\n        respawn: true,\n        shardArgs: [],\n        execArgv: [],\n        token: process.env.DISCORD_TOKEN,\n      },\n      options,\n    );\n\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n    this.file = file;\n    if (!file) throw new Error('CLIENT_INVALID_OPTION', 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION', 'File', 'a file');\n\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n    this.shardList = options.shardList ?? 'auto';\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array.');\n      }\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'shardList', 'at least 1 id.');\n      if (\n        this.shardList.some(\n          shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0,\n        )\n      ) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array of positive integers.');\n      }\n    }\n\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n    this.totalShards = options.totalShards || 'auto';\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n      if (this.totalShards < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(this.totalShards)) {\n        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = options.mode;\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Sharding mode', '\"process\" or \"worker\"');\n    }\n\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n    this.respawn = options.respawn;\n\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.shardArgs = options.shardArgs;\n\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = options.execArgv;\n\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n    this.shards = new Collection();\n\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n  createShard(id = this.shards.size) {\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n\n  /**\n   * Option used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await Util.fetchRecommendedShards(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n      if (amount < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n\n    // Make sure this many shards haven't already been spawned\n    if (this.shards.size >= amount) throw new Error('SHARDING_ALREADY_SPAWNED', this.shards.size);\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new RangeError(\n        'CLIENT_INVALID_OPTION',\n        'Amount of shards',\n        'bigger than the highest shardId in the shardList option.',\n      );\n    }\n\n    // Spawn the shards\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(Util.delayFor(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n  broadcast(message) {\n    const promises = [];\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n  broadcastEval(script, options = {}) {\n    if (typeof script !== 'function') return Promise.reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new Error('SHARDING_NO_SHARDS'));\n\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new Error('SHARDING_SHARD_NOT_FOUND', shard));\n    }\n\n    if (this.shards.size !== this.shardList.length) return Promise.reject(new Error('SHARDING_IN_PROCESS'));\n\n    const promises = [];\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<string, Shard>>}\n   */\n  async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {\n    let s = 0;\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({ respawnDelay, timeout })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(Util.delayFor(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n    return this.shards;\n  }\n}\n\nmodule.exports = ShardingManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}