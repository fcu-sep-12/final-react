{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst DataManager = require('./DataManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst Role = require('../structures/Role');\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n * @extends {DataManager}\n */\n\n\nclass GuildMemberRoleManager extends DataManager {\n  constructor(member) {\n    super(member.client, Role);\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = member.guild;\n  }\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get cache() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get hoist() {\n    const hoistedRoles = this.cache.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get color() {\n    const coloredRoles = this.cache.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n  /**\n   * The premium subscriber role of the guild, if present on the member\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n  /**\n   * The managed role this member created when joining the guild, if any\n   * <info>Only ever available on bots</info>\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get botRole() {\n    if (!this.member.user.bot) return null;\n    return this.cache.find(role => role.tags?.botId === this.member.user.id) ?? null;\n  }\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveId(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].put({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      clone._roles = [...this.cache.keys(), roleOrRoles];\n      return clone;\n    }\n  }\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = this.cache.filter(role => !resolvedRoles.includes(role.id));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveId(roleOrRoles);\n\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].delete({\n        reason\n      });\n\n      const clone = this.member._clone();\n\n      const newRoles = this.cache.filter(role => role.id !== roleOrRoles);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n\n\n  set(roles, reason) {\n    return this.member.edit({\n      roles\n    }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this.cache.keys()];\n    return clone;\n  }\n\n}\n\nmodule.exports = GuildMemberRoleManager;","map":{"version":3,"names":["Collection","require","DataManager","TypeError","Role","GuildMemberRoleManager","constructor","member","client","guild","cache","everyone","roles","filter","role","_roles","includes","id","set","hoist","hoistedRoles","size","reduce","prev","comparePositionTo","color","coloredRoles","highest","first","premiumSubscriberRole","find","tags","botRole","user","bot","botId","add","roleOrRoles","reason","Array","isArray","resolvedRoles","values","resolvedRole","resolveId","push","newRoles","Set","concat","api","guilds","members","put","clone","_clone","keys","remove","delete","edit","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/GuildMemberRoleManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst DataManager = require('./DataManager');\nconst { TypeError } = require('../errors');\nconst Role = require('../structures/Role');\n\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n * @extends {DataManager}\n */\nclass GuildMemberRoleManager extends DataManager {\n  constructor(member) {\n    super(member.client, Role);\n\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = member.guild;\n  }\n\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n  get cache() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n  get hoist() {\n    const hoistedRoles = this.cache.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n  get color() {\n    const coloredRoles = this.cache.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n\n  /**\n   * The premium subscriber role of the guild, if present on the member\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The managed role this member created when joining the guild, if any\n   * <info>Only ever available on bots</info>\n   * @type {?Role}\n   * @readonly\n   */\n  get botRole() {\n    if (!this.member.user.bot) return null;\n    return this.cache.find(role => role.tags?.botId === this.member.user.id) ?? null;\n  }\n\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveId(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].put({ reason });\n\n      const clone = this.member._clone();\n      clone._roles = [...this.cache.keys(), roleOrRoles];\n      return clone;\n    }\n  }\n\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      const resolvedRoles = [];\n      for (const role of roleOrRoles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      const newRoles = this.cache.filter(role => !resolvedRoles.includes(role.id));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolveId(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].delete({ reason });\n\n      const clone = this.member._clone();\n      const newRoles = this.cache.filter(role => role.id !== roleOrRoles);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n  set(roles, reason) {\n    return this.member.edit({ roles }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this.cache.keys()];\n    return clone;\n  }\n}\n\nmodule.exports = GuildMemberRoleManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}