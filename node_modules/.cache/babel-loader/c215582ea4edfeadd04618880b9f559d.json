{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst Permissions = require('../util/Permissions');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\nconst Util = require('../util/Util');\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\n\n\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIRole} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the role\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n\n    this.color = data.color;\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n\n    this.hoist = data.hoist;\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n\n    this.rawPosition = data.position;\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n\n    this.permissions = new Permissions(BigInt(data.permissions)).freeze();\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n\n    this.mentionable = data.mentionable;\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     */\n\n    this.tags = data.tags ? {} : null;\n\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n    }\n  }\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n\n\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedRoles();\n\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n\n\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    return this.guild.roles.edit(this, data, reason);\n  }\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n\n\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n\n\n  setColor(color, reason) {\n    return this.edit({\n      color\n    }, reason);\n  }\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n\n\n  setHoist(hoist, reason) {\n    return this.edit({\n      hoist\n    }, reason);\n  }\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([Permissions.FLAGS.KICK_MEMBERS, Permissions.FLAGS.BAN_MEMBERS])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n\n\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions\n    }, reason);\n  }\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setMentionable(mentionable, reason) {\n    return this.edit({\n      mentionable\n    }, reason);\n  }\n  /**\n   * Options used to set position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n\n\n  async setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const updatedRoles = await Util.setPosition(this, position, relative, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason);\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles\n    });\n    return this;\n  }\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async delete(reason) {\n    await this.client.api.guilds[this.guild.id].roles[this.id].delete({\n      reason\n    });\n    this.client.actions.GuildRoleDelete.handle({\n      guild_id: this.guild.id,\n      role_id: this.id\n    });\n    return this;\n  }\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed;\n  }\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n\n\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      createdTimestamp: true\n    });\n  }\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n\n\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n\n}\n\nmodule.exports = Role;\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */","map":{"version":3,"names":["Base","require","Error","TypeError","Permissions","SnowflakeUtil","Util","Role","constructor","client","data","guild","_patch","id","name","color","hoist","rawPosition","position","permissions","BigInt","freeze","managed","mentionable","deleted","tags","botId","bot_id","integrationId","integration_id","premiumSubscriberRole","createdTimestamp","deconstruct","timestamp","createdAt","Date","hexColor","toString","padStart","members","cache","filter","m","roles","has","editable","clientMember","resolve","user","FLAGS","MANAGE_ROLES","highest","comparePositionTo","sorted","_sortedRoles","values","indexOf","get","role","comparePositions","edit","reason","permissionsIn","channel","channels","rolePermissions","setName","setColor","setHoist","setPermissions","setMentionable","setPosition","relative","updatedRoles","api","guilds","actions","GuildRolesPositionUpdate","handle","guild_id","delete","GuildRoleDelete","role_id","equals","bitfield","toJSON","role1","role2","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/Role.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst { Error, TypeError } = require('../errors');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\nconst Util = require('../util/Util');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIRole} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The name of the role\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n    this.color = data.color;\n\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n    this.hoist = data.hoist;\n\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n    this.permissions = new Permissions(BigInt(data.permissions)).freeze();\n\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n    this.managed = data.managed;\n\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n    this.mentionable = data.mentionable;\n\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     */\n    this.tags = data.tags ? {} : null;\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n    }\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  edit(data, reason) {\n    return this.guild.roles.edit(this, data, reason);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({ color }, reason);\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist, reason) {\n    return this.edit({ hoist }, reason);\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([Permissions.FLAGS.KICK_MEMBERS, Permissions.FLAGS.BAN_MEMBERS])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({ permissions }, reason);\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable, reason) {\n    return this.edit({ mentionable }, reason);\n  }\n\n  /**\n   * Options used to set position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(position, { relative, reason } = {}) {\n    const updatedRoles = await Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedRoles(),\n      this.client.api.guilds(this.guild.id).roles,\n      reason,\n    );\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles,\n    });\n    return this;\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.client.api.guilds[this.guild.id].roles[this.id].delete({ reason });\n    this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: this.id });\n    return this;\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return (\n      role &&\n      this.id === role.id &&\n      this.name === role.name &&\n      this.color === role.color &&\n      this.hoist === role.hoist &&\n      this.position === role.position &&\n      this.permissions.bitfield === role.permissions.bitfield &&\n      this.managed === role.managed\n    );\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({ createdTimestamp: true });\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n}\n\nmodule.exports = Role;\n\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */\n"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,MAAM;EAAEC,KAAF;EAASC;AAAT,IAAuBF,OAAO,CAAC,WAAD,CAApC;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,uBAAD,CAA7B;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,cAAD,CAApB;AAEA;AACA;AACA;AACA;;;AACA,MAAMM,IAAN,SAAmBP,IAAnB,CAAwB;EACtB;AACF;AACA;AACA;AACA;EACEQ,WAAW,CAACC,MAAD,EAASC,IAAT,EAAeC,KAAf,EAAsB;IAC/B,MAAMF,MAAN;IAEA;AACJ;AACA;AACA;;IACI,KAAKE,KAAL,GAAaA,KAAb;IAEA,IAAID,IAAJ,EAAU,KAAKE,MAAL,CAAYF,IAAZ;EACX;;EAEDE,MAAM,CAACF,IAAD,EAAO;IACX;AACJ;AACA;AACA;IACI,KAAKG,EAAL,GAAUH,IAAI,CAACG,EAAf;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,IAAL,GAAYJ,IAAI,CAACI,IAAjB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,KAAL,GAAaL,IAAI,CAACK,KAAlB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,KAAL,GAAaN,IAAI,CAACM,KAAlB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,WAAL,GAAmBP,IAAI,CAACQ,QAAxB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,WAAL,GAAmB,IAAIf,WAAJ,CAAgBgB,MAAM,CAACV,IAAI,CAACS,WAAN,CAAtB,EAA0CE,MAA1C,EAAnB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,OAAL,GAAeZ,IAAI,CAACY,OAApB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,WAAL,GAAmBb,IAAI,CAACa,WAAxB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,OAAL,GAAe,KAAf;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;IACI,KAAKC,IAAL,GAAYf,IAAI,CAACe,IAAL,GAAY,EAAZ,GAAiB,IAA7B;;IACA,IAAIf,IAAI,CAACe,IAAT,EAAe;MACb,IAAI,YAAYf,IAAI,CAACe,IAArB,EAA2B;QACzB,KAAKA,IAAL,CAAUC,KAAV,GAAkBhB,IAAI,CAACe,IAAL,CAAUE,MAA5B;MACD;;MACD,IAAI,oBAAoBjB,IAAI,CAACe,IAA7B,EAAmC;QACjC,KAAKA,IAAL,CAAUG,aAAV,GAA0BlB,IAAI,CAACe,IAAL,CAAUI,cAApC;MACD;;MACD,IAAI,wBAAwBnB,IAAI,CAACe,IAAjC,EAAuC;QACrC,KAAKA,IAAL,CAAUK,qBAAV,GAAkC,IAAlC;MACD;IACF;EACF;EAED;AACF;AACA;AACA;AACA;;;EACsB,IAAhBC,gBAAgB,GAAG;IACrB,OAAO1B,aAAa,CAAC2B,WAAd,CAA0B,KAAKnB,EAA/B,EAAmCoB,SAA1C;EACD;EAED;AACF;AACA;AACA;AACA;;;EACe,IAATC,SAAS,GAAG;IACd,OAAO,IAAIC,IAAJ,CAAS,KAAKJ,gBAAd,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARK,QAAQ,GAAG;IACb,OAAQ,IAAG,KAAKrB,KAAL,CAAWsB,QAAX,CAAoB,EAApB,EAAwBC,QAAxB,CAAiC,CAAjC,EAAoC,GAApC,CAAyC,EAApD;EACD;EAED;AACF;AACA;AACA;AACA;;;EACa,IAAPC,OAAO,GAAG;IACZ,OAAO,KAAK5B,KAAL,CAAW4B,OAAX,CAAmBC,KAAnB,CAAyBC,MAAzB,CAAgCC,CAAC,IAAIA,CAAC,CAACC,KAAF,CAAQH,KAAR,CAAcI,GAAd,CAAkB,KAAK/B,EAAvB,CAArC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARgC,QAAQ,GAAG;IACb,IAAI,KAAKvB,OAAT,EAAkB,OAAO,KAAP;IAClB,MAAMwB,YAAY,GAAG,KAAKnC,KAAL,CAAW4B,OAAX,CAAmBQ,OAAnB,CAA2B,KAAKtC,MAAL,CAAYuC,IAAvC,CAArB;IACA,IAAI,CAACF,YAAY,CAAC3B,WAAb,CAAyByB,GAAzB,CAA6BxC,WAAW,CAAC6C,KAAZ,CAAkBC,YAA/C,CAAL,EAAmE,OAAO,KAAP;IACnE,OAAOJ,YAAY,CAACH,KAAb,CAAmBQ,OAAnB,CAA2BC,iBAA3B,CAA6C,IAA7C,IAAqD,CAA5D;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,IAARlC,QAAQ,GAAG;IACb,MAAMmC,MAAM,GAAG,KAAK1C,KAAL,CAAW2C,YAAX,EAAf;;IACA,OAAO,CAAC,GAAGD,MAAM,CAACE,MAAP,EAAJ,EAAqBC,OAArB,CAA6BH,MAAM,CAACI,GAAP,CAAW,KAAK5C,EAAhB,CAA7B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEuC,iBAAiB,CAACM,IAAD,EAAO;IACtBA,IAAI,GAAG,KAAK/C,KAAL,CAAWgC,KAAX,CAAiBI,OAAjB,CAAyBW,IAAzB,CAAP;IACA,IAAI,CAACA,IAAL,EAAW,MAAM,IAAIvD,SAAJ,CAAc,cAAd,EAA8B,MAA9B,EAAsC,sBAAtC,CAAN;IACX,OAAO,KAAKK,WAAL,CAAiBmD,gBAAjB,CAAkC,IAAlC,EAAwCD,IAAxC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEE,IAAI,CAAClD,IAAD,EAAOmD,MAAP,EAAe;IACjB,OAAO,KAAKlD,KAAL,CAAWgC,KAAX,CAAiBiB,IAAjB,CAAsB,IAAtB,EAA4BlD,IAA5B,EAAkCmD,MAAlC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,aAAa,CAACC,OAAD,EAAU;IACrBA,OAAO,GAAG,KAAKpD,KAAL,CAAWqD,QAAX,CAAoBjB,OAApB,CAA4BgB,OAA5B,CAAV;IACA,IAAI,CAACA,OAAL,EAAc,MAAM,IAAI7D,KAAJ,CAAU,uBAAV,CAAN;IACd,OAAO6D,OAAO,CAACE,eAAR,CAAwB,IAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,OAAO,CAACpD,IAAD,EAAO+C,MAAP,EAAe;IACpB,OAAO,KAAKD,IAAL,CAAU;MAAE9C;IAAF,CAAV,EAAoB+C,MAApB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEM,QAAQ,CAACpD,KAAD,EAAQ8C,MAAR,EAAgB;IACtB,OAAO,KAAKD,IAAL,CAAU;MAAE7C;IAAF,CAAV,EAAqB8C,MAArB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEO,QAAQ,CAACpD,KAAD,EAAQ6C,MAAR,EAAgB;IACtB,OAAO,KAAKD,IAAL,CAAU;MAAE5C;IAAF,CAAV,EAAqB6C,MAArB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEQ,cAAc,CAAClD,WAAD,EAAc0C,MAAd,EAAsB;IAClC,OAAO,KAAKD,IAAL,CAAU;MAAEzC;IAAF,CAAV,EAA2B0C,MAA3B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACES,cAAc,CAAC/C,WAAD,EAAcsC,MAAd,EAAsB;IAClC,OAAO,KAAKD,IAAL,CAAU;MAAErC;IAAF,CAAV,EAA2BsC,MAA3B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACmB,MAAXU,WAAW,CAACrD,QAAD,EAAsC;IAAA,IAA3B;MAAEsD,QAAF;MAAYX;IAAZ,CAA2B,uEAAJ,EAAI;IACrD,MAAMY,YAAY,GAAG,MAAMnE,IAAI,CAACiE,WAAL,CACzB,IADyB,EAEzBrD,QAFyB,EAGzBsD,QAHyB,EAIzB,KAAK7D,KAAL,CAAW2C,YAAX,EAJyB,EAKzB,KAAK7C,MAAL,CAAYiE,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKhE,KAAL,CAAWE,EAAlC,EAAsC8B,KALb,EAMzBkB,MANyB,CAA3B;IAQA,KAAKpD,MAAL,CAAYmE,OAAZ,CAAoBC,wBAApB,CAA6CC,MAA7C,CAAoD;MAClDC,QAAQ,EAAE,KAAKpE,KAAL,CAAWE,EAD6B;MAElD8B,KAAK,EAAE8B;IAF2C,CAApD;IAIA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACc,MAANO,MAAM,CAACnB,MAAD,EAAS;IACnB,MAAM,KAAKpD,MAAL,CAAYiE,GAAZ,CAAgBC,MAAhB,CAAuB,KAAKhE,KAAL,CAAWE,EAAlC,EAAsC8B,KAAtC,CAA4C,KAAK9B,EAAjD,EAAqDmE,MAArD,CAA4D;MAAEnB;IAAF,CAA5D,CAAN;IACA,KAAKpD,MAAL,CAAYmE,OAAZ,CAAoBK,eAApB,CAAoCH,MAApC,CAA2C;MAAEC,QAAQ,EAAE,KAAKpE,KAAL,CAAWE,EAAvB;MAA2BqE,OAAO,EAAE,KAAKrE;IAAzC,CAA3C;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEsE,MAAM,CAACzB,IAAD,EAAO;IACX,OACEA,IAAI,IACJ,KAAK7C,EAAL,KAAY6C,IAAI,CAAC7C,EADjB,IAEA,KAAKC,IAAL,KAAc4C,IAAI,CAAC5C,IAFnB,IAGA,KAAKC,KAAL,KAAe2C,IAAI,CAAC3C,KAHpB,IAIA,KAAKC,KAAL,KAAe0C,IAAI,CAAC1C,KAJpB,IAKA,KAAKE,QAAL,KAAkBwC,IAAI,CAACxC,QALvB,IAMA,KAAKC,WAAL,CAAiBiE,QAAjB,KAA8B1B,IAAI,CAACvC,WAAL,CAAiBiE,QAN/C,IAOA,KAAK9D,OAAL,KAAiBoC,IAAI,CAACpC,OARxB;EAUD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEe,QAAQ,GAAG;IACT,IAAI,KAAKxB,EAAL,KAAY,KAAKF,KAAL,CAAWE,EAA3B,EAA+B,OAAO,WAAP;IAC/B,OAAQ,MAAK,KAAKA,EAAG,GAArB;EACD;;EAEDwE,MAAM,GAAG;IACP,OAAO,MAAMA,MAAN,CAAa;MAAEtD,gBAAgB,EAAE;IAApB,CAAb,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACyB,OAAhB4B,gBAAgB,CAAC2B,KAAD,EAAQC,KAAR,EAAe;IACpC,IAAID,KAAK,CAACpE,QAAN,KAAmBqE,KAAK,CAACrE,QAA7B,EAAuC,OAAOqE,KAAK,CAAC1E,EAAN,GAAWyE,KAAK,CAACzE,EAAxB;IACvC,OAAOyE,KAAK,CAACpE,QAAN,GAAiBqE,KAAK,CAACrE,QAA9B;EACD;;AA1XqB;;AA6XxBsE,MAAM,CAACC,OAAP,GAAiBlF,IAAjB;AAEA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}