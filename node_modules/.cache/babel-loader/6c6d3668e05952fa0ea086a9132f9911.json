{"ast":null,"code":"'use strict';\n\nconst {\n  parse\n} = require('path');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst fetch = require('node-fetch');\n\nconst {\n  Colors,\n  Endpoints\n} = require('./Constants');\n\nconst Options = require('./Options');\n\nconst {\n  Error: DiscordError,\n  RangeError,\n  TypeError\n} = require('../errors');\n\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\n\nconst isObject = d => typeof d === 'object' && d !== null;\n/**\n * Contains various general-purpose utility methods.\n */\n\n\nclass Util extends null {\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj) {\n    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      props[_key - 1] = arguments[_key];\n    }\n\n    if (!isObject(obj)) return obj;\n    const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n      [k]: true\n    }));\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null; // If it's a Collection, make the array of keys\n\n      if (element instanceof Collection) out[newProp] = Array.from(element.keys()); // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys()); // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e)); // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf; // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string|string[]|RegExp|RegExp[]} [char='\\n'] Character(s) or Regex(s) to split the message with,\n   * an array can be used to split multiple times\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n\n\n  static splitMessage(text) {\n    let {\n      maxLength = 2000,\n      char = '\\n',\n      prepend = '',\n      append = ''\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    text = Util.verifyString(text, RangeError, 'MESSAGE_CONTENT_TYPE', false);\n    if (text.length <= maxLength) return [text];\n    let splitText = [text];\n\n    if (Array.isArray(char)) {\n      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {\n        const currentChar = char.shift();\n\n        if (currentChar instanceof RegExp) {\n          splitText = splitText.flatMap(chunk => chunk.match(currentChar));\n        } else {\n          splitText = splitText.flatMap(chunk => chunk.split(currentChar));\n        }\n      }\n    } else {\n      splitText = text.split(char);\n    }\n\n    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n\n    return messages.concat(msg).filter(m => m);\n  }\n  /**\n   * Options used to escape markdown.\n   * @typedef {Object} EscapeMarkdownOptions\n   * @property {boolean} [codeBlock=true] Whether to escape code blocks or not\n   * @property {boolean} [inlineCode=true] Whether to escape inline code or not\n   * @property {boolean} [bold=true] Whether to escape bolds or not\n   * @property {boolean} [italic=true] Whether to escape italics or not\n   * @property {boolean} [underline=true] Whether to escape underlines or not\n   * @property {boolean} [strikethrough=true] Whether to escape strikethroughs or not\n   * @property {boolean} [spoiler=true] Whether to escape spoilers or not\n   * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code or not\n   */\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n   * @returns {string}\n   */\n\n\n  static escapeMarkdown(text) {\n    let {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!codeBlockContent) {\n      return text.split('```').map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent\n        });\n      }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n\n    if (!inlineCodeContent) {\n      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler\n        });\n      }).join(inlineCode ? '\\\\`' : '`');\n    }\n\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n  /**\n   * @typedef {Object} FetchRecommendedShardsOptions\n   * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n   * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n   */\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {FetchRecommendedShardsOptions} [options] Options for fetching the recommended shard count\n   * @returns {Promise<number>} The recommended number of shards\n   */\n\n\n  static async fetchRecommendedShards(token) {\n    let {\n      guildsPerShard = 1000,\n      multipleOf = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    const defaults = Options.createDefault();\n    const response = await fetch(`${defaults.http.api}/v${defaults.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n      }\n    });\n\n    if (!response.ok) {\n      if (response.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw response;\n    }\n\n    const {\n      shards\n    } = await response.json();\n    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;\n  }\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no id)\n   * * A URL-encoded UTF-8 emoji (no id)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n\n\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    return match && {\n      animated: Boolean(match[1]),\n      name: match[2],\n      id: match[3] ?? null\n    };\n  }\n  /**\n   * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n   * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n   * @returns {?RawEmoji}\n   * @private\n   */\n\n\n  static resolvePartialEmoji(emoji) {\n    if (!emoji) return null;\n    if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? {\n      id: emoji\n    } : Util.parseEmoji(emoji);\n    const {\n      id,\n      name,\n      animated\n    } = emoji;\n    if (!id && !name) return null;\n    return {\n      id,\n      name,\n      animated\n    };\n  }\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n\n\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n\n\n  static mergeDefault(def, given) {\n    if (!given) return def;\n\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n  /**\n   * Options used to make an error object.\n   * @typedef {Object} MakeErrorOptions\n   * @property {string} name Error type\n   * @property {string} message Message for the error\n   * @property {string} stack Stack for the error\n   */\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {MakeErrorOptions} obj Error info\n   * @returns {Error}\n   * @private\n   */\n\n\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {MakeErrorOptions}\n   * @private\n   */\n\n\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  }\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n\n\n  static moveElementInArray(array, element, newIndex) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n\n    return array.indexOf(element);\n  }\n  /**\n   * Verifies the provided data is a string, otherwise throws provided error.\n   * @param {string} data The string resolvable to resolve\n   * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n   * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n   * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n   * @returns {string}\n   */\n\n\n  static verifyString(data) {\n    let error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;\n    let errorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : `Expected a string, got ${data} instead.`;\n    let allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (typeof data !== 'string') throw new error(errorMessage);\n    if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n    return data;\n  }\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `FUCHSIA`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `DARKER_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n\n\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');\n    return color;\n  }\n  /**\n   * Sorts by Discord's position and id.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n\n\n  static discordSort(collection) {\n    return collection.sorted((a, b) => a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)));\n  }\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n\n\n  static async setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = [...sorted.values()];\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({\n      id: r.id,\n      position: i\n    }));\n    await route.patch({\n      data: updatedItems,\n      reason\n    });\n    return updatedItems;\n  }\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n\n\n  static basename(path, ext) {\n    const res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n\n\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n\n    return bin;\n  }\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n\n\n  static binaryToId(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n      dec = (low % 10).toString() + dec;\n      num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n\n\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Channel} channel The channel the string was sent in\n   * @returns {string}\n   */\n\n\n  static cleanContent(str, channel) {\n    str = str.replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n\n      if (channel.type === 'DM') {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n\n      const member = channel.guild.members.cache.get(id);\n\n      if (member) {\n        return Util.removeMentions(`@${member.displayName}`);\n      } else {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n      return mentionedChannel ? `#${mentionedChannel.name}` : input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (channel.type === 'DM') return input;\n      const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n      return role ? `@${role.name}` : input;\n    });\n    return str;\n  }\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n\n\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {SweepFilter}\n   */\n\n\n  static archivedThreadSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n\n    const filter = require('./LimitedCollection').filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived\n    });\n\n    filter.isDefault = true;\n    return filter;\n  }\n\n}\n\nmodule.exports = Util;","map":{"version":3,"names":["parse","require","Collection","fetch","Colors","Endpoints","Options","Error","DiscordError","RangeError","TypeError","has","o","k","Object","prototype","hasOwnProperty","call","isObject","d","Util","flatten","obj","props","objProps","keys","filter","startsWith","map","length","assign","out","prop","newProp","entries","element","elemIsObj","valueOf","Array","from","isArray","e","splitMessage","text","maxLength","char","prepend","append","verifyString","splitText","some","elem","currentChar","shift","RegExp","flatMap","chunk","match","split","messages","msg","push","concat","m","escapeMarkdown","codeBlock","inlineCode","bold","italic","underline","strikethrough","spoiler","codeBlockContent","inlineCodeContent","subString","index","array","join","escapeInlineCode","escapeCodeBlock","escapeItalic","escapeBold","escapeUnderline","escapeStrikethrough","escapeSpoiler","replace","i","_","fetchRecommendedShards","token","guildsPerShard","multipleOf","defaults","createDefault","response","http","api","version","botGateway","method","headers","Authorization","ok","status","shards","json","Math","ceil","parseEmoji","includes","decodeURIComponent","animated","name","id","Boolean","resolvePartialEmoji","emoji","test","cloneObject","create","mergeDefault","def","given","key","undefined","makeError","err","message","stack","makePlainError","moveElementInArray","newIndex","offset","indexOf","removedElement","splice","data","error","errorMessage","allowEmpty","resolveColor","color","floor","random","parseInt","Number","isNaN","discordSort","collection","sorted","a","b","rawPosition","slice","setPosition","item","position","relative","route","reason","updatedItems","values","r","patch","basename","path","ext","res","base","idToBinary","num","bin","high","low","String","binaryToId","dec","toString","padStart","removeMentions","str","cleanContent","channel","input","type","user","client","users","cache","get","username","member","guild","members","displayName","mentionedChannel","channels","role","roles","cleanCodeBlockContent","delayFor","ms","Promise","resolve","setTimeout","archivedThreadSweepFilter","lifetime","filterByLifetime","getComparisonTimestamp","archiveTimestamp","excludeFromSweep","archived","isDefault","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/util/Util.js"],"sourcesContent":["'use strict';\n\nconst { parse } = require('path');\nconst { Collection } = require('@discordjs/collection');\nconst fetch = require('node-fetch');\nconst { Colors, Endpoints } = require('./Constants');\nconst Options = require('./Options');\nconst { Error: DiscordError, RangeError, TypeError } = require('../errors');\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Contains various general-purpose utility methods.\n */\nclass Util extends null {\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj, ...props) {\n    if (!isObject(obj)) return obj;\n\n    const objProps = Object.keys(obj)\n      .filter(k => !k.startsWith('_'))\n      .map(k => ({ [k]: true }));\n\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n\n      // If it's a Collection, make the array of keys\n      if (element instanceof Collection) out[newProp] = Array.from(element.keys());\n      // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys());\n      // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));\n      // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n      // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string|string[]|RegExp|RegExp[]} [char='\\n'] Character(s) or Regex(s) to split the message with,\n   * an array can be used to split multiple times\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n  static splitMessage(text, { maxLength = 2000, char = '\\n', prepend = '', append = '' } = {}) {\n    text = Util.verifyString(text, RangeError, 'MESSAGE_CONTENT_TYPE', false);\n    if (text.length <= maxLength) return [text];\n    let splitText = [text];\n    if (Array.isArray(char)) {\n      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {\n        const currentChar = char.shift();\n        if (currentChar instanceof RegExp) {\n          splitText = splitText.flatMap(chunk => chunk.match(currentChar));\n        } else {\n          splitText = splitText.flatMap(chunk => chunk.split(currentChar));\n        }\n      }\n    } else {\n      splitText = text.split(char);\n    }\n    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n    return messages.concat(msg).filter(m => m);\n  }\n\n  /**\n   * Options used to escape markdown.\n   * @typedef {Object} EscapeMarkdownOptions\n   * @property {boolean} [codeBlock=true] Whether to escape code blocks or not\n   * @property {boolean} [inlineCode=true] Whether to escape inline code or not\n   * @property {boolean} [bold=true] Whether to escape bolds or not\n   * @property {boolean} [italic=true] Whether to escape italics or not\n   * @property {boolean} [underline=true] Whether to escape underlines or not\n   * @property {boolean} [strikethrough=true] Whether to escape strikethroughs or not\n   * @property {boolean} [spoiler=true] Whether to escape spoilers or not\n   * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code or not\n   */\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n   * @returns {string}\n   */\n  static escapeMarkdown(\n    text,\n    {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true,\n    } = {},\n  ) {\n    if (!codeBlockContent) {\n      return text\n        .split('```')\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            inlineCode,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n            inlineCodeContent,\n          });\n        })\n        .join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n    if (!inlineCodeContent) {\n      return text\n        .split(/(?<=^|[^`])`(?=[^`]|$)/g)\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            codeBlock,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n          });\n        })\n        .join(inlineCode ? '\\\\`' : '`');\n    }\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n\n  /**\n   * @typedef {Object} FetchRecommendedShardsOptions\n   * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n   * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n   */\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {FetchRecommendedShardsOptions} [options] Options for fetching the recommended shard count\n   * @returns {Promise<number>} The recommended number of shards\n   */\n  static async fetchRecommendedShards(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    const defaults = Options.createDefault();\n    const response = await fetch(`${defaults.http.api}/v${defaults.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n    });\n    if (!response.ok) {\n      if (response.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw response;\n    }\n    const { shards } = await response.json();\n    return Math.ceil((shards * (1000 / guildsPerShard)) / multipleOf) * multipleOf;\n  }\n\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no id)\n   * * A URL-encoded UTF-8 emoji (no id)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return { animated: false, name: text, id: null };\n    const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] ?? null };\n  }\n\n  /**\n   * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n   * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n   * @returns {?RawEmoji}\n   * @private\n   */\n  static resolvePartialEmoji(emoji) {\n    if (!emoji) return null;\n    if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? { id: emoji } : Util.parseEmoji(emoji);\n    const { id, name, animated } = emoji;\n    if (!id && !name) return null;\n    return { id, name, animated };\n  }\n\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n  static mergeDefault(def, given) {\n    if (!given) return def;\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n\n  /**\n   * Options used to make an error object.\n   * @typedef {Object} MakeErrorOptions\n   * @property {string} name Error type\n   * @property {string} message Message for the error\n   * @property {string} stack Stack for the error\n   */\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {MakeErrorOptions} obj Error info\n   * @returns {Error}\n   * @private\n   */\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {MakeErrorOptions}\n   * @private\n   */\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack,\n    };\n  }\n\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n    return array.indexOf(element);\n  }\n\n  /**\n   * Verifies the provided data is a string, otherwise throws provided error.\n   * @param {string} data The string resolvable to resolve\n   * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n   * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n   * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n   * @returns {string}\n   */\n  static verifyString(\n    data,\n    error = Error,\n    errorMessage = `Expected a string, got ${data} instead.`,\n    allowEmpty = true,\n  ) {\n    if (typeof data !== 'string') throw new error(errorMessage);\n    if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n    return data;\n  }\n\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `FUCHSIA`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `DARKER_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');\n    else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');\n\n    return color;\n  }\n\n  /**\n   * Sorts by Discord's position and id.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n  static discordSort(collection) {\n    return collection.sorted(\n      (a, b) =>\n        a.rawPosition - b.rawPosition ||\n        parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) ||\n        parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)),\n    );\n  }\n\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n  static async setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = [...sorted.values()];\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));\n    await route.patch({ data: updatedItems, reason });\n    return updatedItems;\n  }\n\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n  static basename(path, ext) {\n    const res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n    return bin;\n  }\n\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n  static binaryToId(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n\n      dec = (low % 10).toString() + dec;\n      num =\n        Math.floor(high / 10).toString(2) +\n        Math.floor(low / 10)\n          .toString(2)\n          .padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Channel} channel The channel the string was sent in\n   * @returns {string}\n   */\n  static cleanContent(str, channel) {\n    str = str\n      .replace(/<@!?[0-9]+>/g, input => {\n        const id = input.replace(/<|!|>|@/g, '');\n        if (channel.type === 'DM') {\n          const user = channel.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n\n        const member = channel.guild.members.cache.get(id);\n        if (member) {\n          return Util.removeMentions(`@${member.displayName}`);\n        } else {\n          const user = channel.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n      })\n      .replace(/<#[0-9]+>/g, input => {\n        const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n        return mentionedChannel ? `#${mentionedChannel.name}` : input;\n      })\n      .replace(/<@&[0-9]+>/g, input => {\n        if (channel.type === 'DM') return input;\n        const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n        return role ? `@${role.name}` : input;\n      });\n    return str;\n  }\n\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {SweepFilter}\n   */\n  static archivedThreadSweepFilter(lifetime = 14400) {\n    const filter = require('./LimitedCollection').filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived,\n    });\n    filter.isDefault = true;\n    return filter;\n  }\n}\n\nmodule.exports = Util;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}