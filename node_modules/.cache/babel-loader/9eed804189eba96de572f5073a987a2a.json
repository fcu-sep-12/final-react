{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Collector = require('./interfaces/Collector');\n\nconst {\n  Events\n} = require('../util/Constants');\n/**\n * @typedef {CollectorOptions} ReactionCollectorOptions\n * @property {number} max The maximum total amount of reactions to collect\n * @property {number} maxEmojis The maximum number of emojis to collect\n * @property {number} maxUsers The maximum number of users to react\n */\n\n/**\n * Collects reactions on messages.\n * Will automatically stop if the message (`'messageDelete'`),\n * channel (`'channelDelete'`), or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nclass ReactionCollector extends Collector {\n  /**\n   * @param {Message} message The message upon which to collect reactions\n   * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  constructor(message) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(message.client, options);\n    /**\n     * The message upon which to collect reactions\n     * @type {Message}\n     */\n\n    this.message = message;\n    /**\n     * The users which have reacted to this message\n     * @type {Collection}\n     */\n\n    this.users = new Collection();\n    /**\n     * The total number of reactions collected\n     * @type {number}\n     */\n\n    this.total = 0;\n    this.empty = this.empty.bind(this);\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this._handleMessageDeletion = this._handleMessageDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n    this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n    this.on('collect', (reaction, user) => {\n      this.total++;\n      this.users.set(user.id, user);\n    });\n    this.on('remove', (reaction, user) => {\n      this.total--;\n      if (!this.collected.some(r => r.users.cache.has(user.id))) this.users.delete(user.id);\n    });\n  }\n  /**\n   * Handles an incoming reaction for possible collection.\n   * @param {MessageReaction} reaction The reaction to possibly collect\n   * @param {User} user The user that added the reaction\n   * @returns {Promise<?(Snowflake|string)>}\n   * @private\n   */\n\n\n  async collect(reaction, user) {\n    /**\n     * Emitted whenever a reaction is collected.\n     * @event ReactionCollector#collect\n     * @param {MessageReaction} reaction The reaction that was collected\n     * @param {User} user The user that added the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n    /**\n     * Emitted whenever a reaction is newly created on a message. Will emit only when a new reaction is\n     * added to the message, as opposed to {@link Collector#collect} which which will\n     * be emitted even when a reaction has already been added to the message.\n     * @event ReactionCollector#create\n     * @param {MessageReaction} reaction The reaction that was added\n     * @param {User} user The user that added the reaction\n     */\n\n    if (reaction.count === 1 && (await this.filter(reaction, user, this.collected))) {\n      this.emit('create', reaction, user);\n    }\n\n    return ReactionCollector.key(reaction);\n  }\n  /**\n   * Handles a reaction deletion for possible disposal.\n   * @param {MessageReaction} reaction The reaction to possibly dispose of\n   * @param {User} user The user that removed the reaction\n   * @returns {?(Snowflake|string)}\n   */\n\n\n  dispose(reaction, user) {\n    /**\n     * Emitted when the reaction had all the users removed and the `dispose` option is set to true.\n     * @event ReactionCollector#dispose\n     * @param {MessageReaction} reaction The reaction that was disposed of\n     * @param {User} user The user that removed the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n    /**\n     * Emitted when the reaction had one user removed and the `dispose` option is set to true.\n     * @event ReactionCollector#remove\n     * @param {MessageReaction} reaction The reaction that was removed\n     * @param {User} user The user that removed the reaction\n     */\n\n    if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {\n      this.emit('remove', reaction, user);\n    }\n\n    return reaction.count ? null : ReactionCollector.key(reaction);\n  }\n  /**\n   * Empties this reaction collector.\n   */\n\n\n  empty() {\n    this.total = 0;\n    this.collected.clear();\n    this.users.clear();\n    this.checkEnd();\n  }\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get endReason() {\n    if (this.options.max && this.total >= this.options.max) return 'limit';\n    if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return 'emojiLimit';\n    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n   * @private\n   * @param {Message} message The message that was deleted\n   * @returns {void}\n   */\n\n\n  _handleMessageDeletion(message) {\n    if (message.id === this.message.id) {\n      this.stop('messageDelete');\n    }\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.message.channelId) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.message.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n  /**\n   * Gets the collector key for a reaction.\n   * @param {MessageReaction} reaction The message reaction to get the key for\n   * @returns {Snowflake|string}\n   */\n\n\n  static key(reaction) {\n    return reaction.emoji.id ?? reaction.emoji.name;\n  }\n\n}\n\nmodule.exports = ReactionCollector;","map":{"version":3,"names":["Collection","require","Collector","Events","ReactionCollector","constructor","message","options","client","users","total","empty","bind","_handleChannelDeletion","_handleGuildDeletion","_handleMessageDeletion","incrementMaxListeners","on","MESSAGE_REACTION_ADD","handleCollect","MESSAGE_REACTION_REMOVE","handleDispose","MESSAGE_REACTION_REMOVE_ALL","MESSAGE_DELETE","CHANNEL_DELETE","GUILD_DELETE","once","removeListener","decrementMaxListeners","reaction","user","set","id","collected","some","r","cache","has","delete","collect","count","filter","emit","key","dispose","clear","checkEnd","endReason","max","maxEmojis","size","maxUsers","stop","channel","channelId","guild","emoji","name","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/ReactionCollector.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} ReactionCollectorOptions\n * @property {number} max The maximum total amount of reactions to collect\n * @property {number} maxEmojis The maximum number of emojis to collect\n * @property {number} maxUsers The maximum number of users to react\n */\n\n/**\n * Collects reactions on messages.\n * Will automatically stop if the message (`'messageDelete'`),\n * channel (`'channelDelete'`), or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\nclass ReactionCollector extends Collector {\n  /**\n   * @param {Message} message The message upon which to collect reactions\n   * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  constructor(message, options = {}) {\n    super(message.client, options);\n\n    /**\n     * The message upon which to collect reactions\n     * @type {Message}\n     */\n    this.message = message;\n\n    /**\n     * The users which have reacted to this message\n     * @type {Collection}\n     */\n    this.users = new Collection();\n\n    /**\n     * The total number of reactions collected\n     * @type {number}\n     */\n    this.total = 0;\n\n    this.empty = this.empty.bind(this);\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this._handleMessageDeletion = this._handleMessageDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n    this.client.on(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n    this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_REACTION_ADD, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);\n      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n\n    this.on('collect', (reaction, user) => {\n      this.total++;\n      this.users.set(user.id, user);\n    });\n\n    this.on('remove', (reaction, user) => {\n      this.total--;\n      if (!this.collected.some(r => r.users.cache.has(user.id))) this.users.delete(user.id);\n    });\n  }\n\n  /**\n   * Handles an incoming reaction for possible collection.\n   * @param {MessageReaction} reaction The reaction to possibly collect\n   * @param {User} user The user that added the reaction\n   * @returns {Promise<?(Snowflake|string)>}\n   * @private\n   */\n  async collect(reaction, user) {\n    /**\n     * Emitted whenever a reaction is collected.\n     * @event ReactionCollector#collect\n     * @param {MessageReaction} reaction The reaction that was collected\n     * @param {User} user The user that added the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n\n    /**\n     * Emitted whenever a reaction is newly created on a message. Will emit only when a new reaction is\n     * added to the message, as opposed to {@link Collector#collect} which which will\n     * be emitted even when a reaction has already been added to the message.\n     * @event ReactionCollector#create\n     * @param {MessageReaction} reaction The reaction that was added\n     * @param {User} user The user that added the reaction\n     */\n    if (reaction.count === 1 && (await this.filter(reaction, user, this.collected))) {\n      this.emit('create', reaction, user);\n    }\n\n    return ReactionCollector.key(reaction);\n  }\n\n  /**\n   * Handles a reaction deletion for possible disposal.\n   * @param {MessageReaction} reaction The reaction to possibly dispose of\n   * @param {User} user The user that removed the reaction\n   * @returns {?(Snowflake|string)}\n   */\n  dispose(reaction, user) {\n    /**\n     * Emitted when the reaction had all the users removed and the `dispose` option is set to true.\n     * @event ReactionCollector#dispose\n     * @param {MessageReaction} reaction The reaction that was disposed of\n     * @param {User} user The user that removed the reaction\n     */\n    if (reaction.message.id !== this.message.id) return null;\n\n    /**\n     * Emitted when the reaction had one user removed and the `dispose` option is set to true.\n     * @event ReactionCollector#remove\n     * @param {MessageReaction} reaction The reaction that was removed\n     * @param {User} user The user that removed the reaction\n     */\n    if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {\n      this.emit('remove', reaction, user);\n    }\n    return reaction.count ? null : ReactionCollector.key(reaction);\n  }\n\n  /**\n   * Empties this reaction collector.\n   */\n  empty() {\n    this.total = 0;\n    this.collected.clear();\n    this.users.clear();\n    this.checkEnd();\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.total >= this.options.max) return 'limit';\n    if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return 'emojiLimit';\n    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n   * @private\n   * @param {Message} message The message that was deleted\n   * @returns {void}\n   */\n  _handleMessageDeletion(message) {\n    if (message.id === this.message.id) {\n      this.stop('messageDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.message.channelId) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.message.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n\n  /**\n   * Gets the collector key for a reaction.\n   * @param {MessageReaction} reaction The message reaction to get the key for\n   * @returns {Snowflake|string}\n   */\n  static key(reaction) {\n    return reaction.emoji.id ?? reaction.emoji.name;\n  }\n}\n\nmodule.exports = ReactionCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}