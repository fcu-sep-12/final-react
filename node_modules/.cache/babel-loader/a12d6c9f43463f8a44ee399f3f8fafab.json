{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst ThreadChannel = require('../structures/ThreadChannel');\n\nconst {\n  ChannelTypes\n} = require('../util/Constants');\n/**\n * Manages API methods for {@link ThreadChannel} objects and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n    /**\n     * The channel this Manager belongs to\n     * @type {NewsChannel|TextChannel}\n     */\n\n    this.channel = channel;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * A number that is allowed to be the duration (in minutes) of inactivity after which a thread is automatically\n   * archived. This can be:\n   * * `60` (1 hour)\n   * * `1440` (1 day)\n   * * `4320` (3 days) <warn>This is only available when the guild has the `THREE_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `10080` (7 days) <warn>This is only available when the guild has the `SEVEN_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `'MAX'` Based on the guilds boost count\n   * @typedef {number|string} ThreadAutoArchiveDuration\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ThreadChannelTypes|number} [type] The type of thread to create. Defaults to `GUILD_PUBLIC_THREAD` if\n   * created in a {@link TextChannel} <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * `GUILD_NEWS_THREAD`</warn>\n   */\n\n  /**\n   * Creates a new thread in the channel.\n   * @param {ThreadCreateOptions} [options] Options to create a new thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Create a new public thread\n   * channel.threads\n   *   .create({\n   *     name: 'food-talk',\n   *     autoArchiveDuration: 60,\n   *     reason: 'Needed a separate thread for food',\n   *   })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   * @example\n   * // Create a new private thread\n   * channel.threads\n   *   .create({\n   *      name: 'mod-talk',\n   *      autoArchiveDuration: 60,\n   *      type: 'GUILD_PRIVATE_THREAD',\n   *      reason: 'Needed a separate thread for moderation',\n   *    })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   */\n\n\n  async create() {\n    let {\n      name,\n      autoArchiveDuration,\n      startMessage,\n      type,\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let path = this.client.api.channels(this.channel.id);\n\n    if (type && typeof type !== 'string' && typeof type !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'type', 'ThreadChannelType or Number');\n    }\n\n    let resolvedType = this.channel.type === 'GUILD_NEWS' ? ChannelTypes.GUILD_NEWS_THREAD : ChannelTypes.GUILD_PUBLIC_THREAD;\n\n    if (startMessage) {\n      const startMessageId = this.channel.messages.resolveId(startMessage);\n      if (!startMessageId) throw new TypeError('INVALID_TYPE', 'startMessage', 'MessageResolvable');\n      path = path.messages(startMessageId);\n    } else if (this.channel.type !== 'GUILD_NEWS') {\n      resolvedType = typeof type === 'string' ? ChannelTypes[type] : type ?? resolvedType;\n    }\n\n    if (autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n\n      if (this.channel.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.channel.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const data = await path.threads.post({\n      data: {\n        name,\n        auto_archive_duration: autoArchiveDuration,\n        type: resolvedType\n      },\n      reason\n    });\n    return this.client.actions.ThreadCreate.handle(data).thread;\n  }\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n\n\n  fetch(options) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n\n    return this.fetchActive(cache);\n  }\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch, either `public` or `private`\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when type is `private`.\n   * Requires `MANAGE_THREADS` if true\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake. <warn>Must be a {@link ThreadChannelResolvable} when type is `private` and fetchAll is `false`</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n\n\n  async fetchArchived() {\n    let {\n      type = 'public',\n      fetchAll = false,\n      before,\n      limit\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let path = this.client.api.channels(this.channel.id);\n\n    if (type === 'private' && !fetchAll) {\n      path = path.users('@me');\n    }\n\n    let timestamp;\n    let id;\n\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n        } catch {\n          throw new TypeError('INVALID_TYPE', 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n\n    const raw = await path.threads.archived(type).get({\n      query: {\n        before: type === 'private' && !fetchAll ? id : timestamp,\n        limit\n      }\n    });\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n  /**\n   * Obtains the accessible active threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n\n\n  async fetchActive() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.api.guilds(this.channel.guild.id).threads.active.get();\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n\n  static _mapThreads(rawThreads, client, _ref) {\n    let {\n      parent,\n      guild,\n      cache\n    } = _ref;\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, {\n        cache\n      });\n\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection()); // Discord sends the thread id as id in this object\n\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false\n    };\n  }\n\n}\n\nmodule.exports = ThreadManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","ThreadChannel","ChannelTypes","ThreadManager","constructor","channel","iterable","client","_add","thread","existing","cache","get","id","set","create","name","autoArchiveDuration","startMessage","type","reason","path","api","channels","resolvedType","GUILD_NEWS_THREAD","GUILD_PUBLIC_THREAD","startMessageId","messages","resolveId","guild","features","includes","data","threads","post","auto_archive_duration","actions","ThreadCreate","handle","fetch","options","force","fetchActive","archived","fetchArchived","fetchAll","before","limit","users","timestamp","test","String","resolve","archivedAt","toISOString","Date","raw","query","_mapThreads","parent","guilds","active","rawThreads","reduce","coll","parentId","rawMember","members","hasMore","has_more","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/ThreadManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst { ChannelTypes } = require('../util/Constants');\n\n/**\n * Manages API methods for {@link ThreadChannel} objects and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {NewsChannel|TextChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * A number that is allowed to be the duration (in minutes) of inactivity after which a thread is automatically\n   * archived. This can be:\n   * * `60` (1 hour)\n   * * `1440` (1 day)\n   * * `4320` (3 days) <warn>This is only available when the guild has the `THREE_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `10080` (7 days) <warn>This is only available when the guild has the `SEVEN_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `'MAX'` Based on the guilds boost count\n   * @typedef {number|string} ThreadAutoArchiveDuration\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ThreadChannelTypes|number} [type] The type of thread to create. Defaults to `GUILD_PUBLIC_THREAD` if\n   * created in a {@link TextChannel} <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * `GUILD_NEWS_THREAD`</warn>\n   */\n\n  /**\n   * Creates a new thread in the channel.\n   * @param {ThreadCreateOptions} [options] Options to create a new thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Create a new public thread\n   * channel.threads\n   *   .create({\n   *     name: 'food-talk',\n   *     autoArchiveDuration: 60,\n   *     reason: 'Needed a separate thread for food',\n   *   })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   * @example\n   * // Create a new private thread\n   * channel.threads\n   *   .create({\n   *      name: 'mod-talk',\n   *      autoArchiveDuration: 60,\n   *      type: 'GUILD_PRIVATE_THREAD',\n   *      reason: 'Needed a separate thread for moderation',\n   *    })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   */\n  async create({ name, autoArchiveDuration, startMessage, type, reason } = {}) {\n    let path = this.client.api.channels(this.channel.id);\n    if (type && typeof type !== 'string' && typeof type !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'type', 'ThreadChannelType or Number');\n    }\n    let resolvedType =\n      this.channel.type === 'GUILD_NEWS' ? ChannelTypes.GUILD_NEWS_THREAD : ChannelTypes.GUILD_PUBLIC_THREAD;\n    if (startMessage) {\n      const startMessageId = this.channel.messages.resolveId(startMessage);\n      if (!startMessageId) throw new TypeError('INVALID_TYPE', 'startMessage', 'MessageResolvable');\n      path = path.messages(startMessageId);\n    } else if (this.channel.type !== 'GUILD_NEWS') {\n      resolvedType = typeof type === 'string' ? ChannelTypes[type] : type ?? resolvedType;\n    }\n    if (autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n      if (this.channel.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.channel.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const data = await path.threads.post({\n      data: {\n        name,\n        auto_archive_duration: autoArchiveDuration,\n        type: resolvedType,\n      },\n      reason,\n    });\n\n    return this.client.actions.ThreadCreate.handle(data).thread;\n  }\n\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, { cache = true, force = false } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch, either `public` or `private`\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when type is `private`.\n   * Requires `MANAGE_THREADS` if true\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake. <warn>Must be a {@link ThreadChannelResolvable} when type is `private` and fetchAll is `false`</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchArchived({ type = 'public', fetchAll = false, before, limit } = {}, cache = true) {\n    let path = this.client.api.channels(this.channel.id);\n    if (type === 'private' && !fetchAll) {\n      path = path.users('@me');\n    }\n    let timestamp;\n    let id;\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n        } catch {\n          throw new TypeError('INVALID_TYPE', 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n    const raw = await path.threads\n      .archived(type)\n      .get({ query: { before: type === 'private' && !fetchAll ? id : timestamp, limit } });\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  /**\n   * Obtains the accessible active threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive(cache = true) {\n    const raw = await this.client.api.guilds(this.channel.guild.id).threads.active.get();\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  static _mapThreads(rawThreads, client, { parent, guild, cache }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n    // Discord sends the thread id as id in this object\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false,\n    };\n  }\n}\n\nmodule.exports = ThreadManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}