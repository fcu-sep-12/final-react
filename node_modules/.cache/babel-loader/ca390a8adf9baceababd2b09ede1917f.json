{"ast":null,"code":"'use strict';\n\nconst Collector = require('./interfaces/Collector');\n\nconst {\n  Events\n} = require('../util/Constants');\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(channel.client, options);\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n\n    this.channel = channel;\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n\n\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n\n\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n\n}\n\nmodule.exports = MessageCollector;","map":{"version":3,"names":["Collector","require","Events","MessageCollector","constructor","channel","options","client","received","bulkDeleteListener","messages","message","values","handleDispose","_handleChannelDeletion","bind","_handleGuildDeletion","incrementMaxListeners","on","MESSAGE_CREATE","handleCollect","MESSAGE_DELETE","MESSAGE_BULK_DELETE","CHANNEL_DELETE","GUILD_DELETE","once","removeListener","decrementMaxListeners","collect","channelId","id","dispose","endReason","max","collected","size","maxProcessed","stop","guild","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/MessageCollector.js"],"sourcesContent":["'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, options = {}) {\n    super(channel.client, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = MessageCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}