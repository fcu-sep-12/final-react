{"ast":null,"code":"'use strict';\n\nconst {\n  Error\n} = require('../../errors');\n\nconst {\n  InteractionResponseTypes\n} = require('../../util/Constants');\n\nconst MessageFlags = require('../../util/MessageFlags');\n\nconst MessagePayload = require('../MessagePayload');\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\n\n\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link Interaction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link ButtonInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to an {@link Interaction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for updating the message received from a {@link ButtonInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && options.ephemeral) throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,\n        data: {\n          flags: options.ephemeral ? MessageFlags.FLAGS.EPHEMERAL : undefined\n        }\n      }\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n  /**\n   * Creates a reply to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Reply to the interaction with an embed\n   * const embed = new MessageEmbed().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed] })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply\n   * interaction.reply({ content: 'Pong!', ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n\n\n  async reply(options) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && options.ephemeral) throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    this.ephemeral = options.ephemeral ?? false;\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      data,\n      files\n    } = await messagePayload.resolveData().resolveFiles();\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.CHANNEL_MESSAGE_WITH_SOURCE,\n        data\n      },\n      files\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n  /**\n   * Fetches the initial reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Fetch the reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchReply() {\n    if (this.ephemeral) throw new Error('INTERACTION_EPHEMERAL_REPLIED');\n    return this.webhook.fetchMessage('@original');\n  }\n  /**\n   * Edits the initial reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The new options for the message\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Edit the reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new Error('INTERACTION_NOT_REPLIED');\n    const message = await this.webhook.editMessage('@original', options);\n    this.replied = true;\n    return message;\n  }\n  /**\n   * Deletes the initial reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async deleteReply() {\n    if (this.ephemeral) throw new Error('INTERACTION_EPHEMERAL_REPLIED');\n    await this.webhook.deleteMessage('@original');\n  }\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|APIMessage>}\n   */\n\n\n  followUp(options) {\n    return this.webhook.send(options);\n  }\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async deferUpdate() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n\n    if (options.fetchReply && new MessageFlags(this.message.flags).has(MessageFlags.FLAGS.EPHEMERAL)) {\n      throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    }\n\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.DEFERRED_MESSAGE_UPDATE\n      }\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async update(options) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n\n    if (options.fetchReply && new MessageFlags(this.message.flags).has(MessageFlags.FLAGS.EPHEMERAL)) {\n      throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    }\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      data,\n      files\n    } = await messagePayload.resolveData().resolveFiles();\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.UPDATE_MESSAGE,\n        data\n      },\n      files\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const props = ['deferReply', 'reply', 'fetchReply', 'editReply', 'deleteReply', 'followUp', 'deferUpdate', 'update'];\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = InteractionResponses;","map":{"version":3,"names":["Error","require","InteractionResponseTypes","MessageFlags","MessagePayload","InteractionResponses","deferReply","options","deferred","replied","fetchReply","ephemeral","client","api","interactions","id","token","callback","post","data","type","DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE","flags","FLAGS","EPHEMERAL","undefined","reply","messagePayload","create","files","resolveData","resolveFiles","CHANNEL_MESSAGE_WITH_SOURCE","webhook","fetchMessage","editReply","message","editMessage","deleteReply","deleteMessage","followUp","send","deferUpdate","has","DEFERRED_MESSAGE_UPDATE","update","UPDATE_MESSAGE","applyToClass","structure","ignore","props","prop","includes","Object","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"],"sourcesContent":["'use strict';\n\nconst { Error } = require('../../errors');\nconst { InteractionResponseTypes } = require('../../util/Constants');\nconst MessageFlags = require('../../util/MessageFlags');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link Interaction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link ButtonInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to an {@link Interaction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for updating the message received from a {@link ButtonInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply(options = {}) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && options.ephemeral) throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,\n        data: {\n          flags: options.ephemeral ? MessageFlags.FLAGS.EPHEMERAL : undefined,\n        },\n      },\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n\n  /**\n   * Creates a reply to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Reply to the interaction with an embed\n   * const embed = new MessageEmbed().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed] })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply\n   * interaction.reply({ content: 'Pong!', ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n  async reply(options) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && options.ephemeral) throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    this.ephemeral = options.ephemeral ?? false;\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { data, files } = await messagePayload.resolveData().resolveFiles();\n\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.CHANNEL_MESSAGE_WITH_SOURCE,\n        data,\n      },\n      files,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n\n  /**\n   * Fetches the initial reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Fetch the reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n  fetchReply() {\n    if (this.ephemeral) throw new Error('INTERACTION_EPHEMERAL_REPLIED');\n    return this.webhook.fetchMessage('@original');\n  }\n\n  /**\n   * Edits the initial reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The new options for the message\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Edit the reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new Error('INTERACTION_NOT_REPLIED');\n    const message = await this.webhook.editMessage('@original', options);\n    this.replied = true;\n    return message;\n  }\n\n  /**\n   * Deletes the initial reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deleteReply() {\n    if (this.ephemeral) throw new Error('INTERACTION_EPHEMERAL_REPLIED');\n    await this.webhook.deleteMessage('@original');\n  }\n\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|APIMessage>}\n   */\n  followUp(options) {\n    return this.webhook.send(options);\n  }\n\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferUpdate(options = {}) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && new MessageFlags(this.message.flags).has(MessageFlags.FLAGS.EPHEMERAL)) {\n      throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    }\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.DEFERRED_MESSAGE_UPDATE,\n      },\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|APIMessage|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async update(options) {\n    if (this.deferred || this.replied) throw new Error('INTERACTION_ALREADY_REPLIED');\n    if (options.fetchReply && new MessageFlags(this.message.flags).has(MessageFlags.FLAGS.EPHEMERAL)) {\n      throw new Error('INTERACTION_FETCH_EPHEMERAL');\n    }\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { data, files } = await messagePayload.resolveData().resolveFiles();\n\n    await this.client.api.interactions(this.id, this.token).callback.post({\n      data: {\n        type: InteractionResponseTypes.UPDATE_MESSAGE,\n        data,\n      },\n      files,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : undefined;\n  }\n\n  static applyToClass(structure, ignore = []) {\n    const props = [\n      'deferReply',\n      'reply',\n      'fetchReply',\n      'editReply',\n      'deleteReply',\n      'followUp',\n      'deferUpdate',\n      'update',\n    ];\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = InteractionResponses;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}