{"ast":null,"code":"'use strict';\n\nconst CachedManager = require('./CachedManager');\n\nconst Channel = require('../structures/Channel');\n\nconst {\n  Events,\n  ThreadChannelTypes\n} = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\n/**\n * A manager of channels belonging to a client\n * @extends {CachedManager}\n */\n\nclass ChannelManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Channel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || (this._cache.maxSize === undefined || this._cache.maxSize === Infinity) && (this._cache.sweepFilter === undefined || this._cache.sweepFilter.isDefault);\n\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n\n  _add(data, guild) {\n    let {\n      cache = true,\n      allowUnknownGuild = false,\n      fromInteraction = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const existing = this.cache.get(data.id);\n\n    if (existing) {\n      if (cache) existing._patch(data, fromInteraction);\n      guild?.channels?._add(existing);\n\n      if (ThreadChannelTypes.includes(existing.type)) {\n        existing.parent?.threads?._add(existing);\n      }\n\n      return existing;\n    }\n\n    const channel = Channel.create(this.client, data, guild, {\n      allowUnknownGuild,\n      fromInteraction\n    });\n\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache && !allowUnknownGuild) this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  _remove(id) {\n    const channel = this.cache.get(id);\n    channel?.guild?.channels.cache.delete(id);\n    channel?.parent?.threads?.cache.delete(id);\n    this.cache.delete(id);\n  }\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel id string.\n   * @method resolveId\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for fetching a channel from discord\n   * @typedef {BaseFetchOptions} FetchChannelOptions\n   * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,\n   * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id The channel's id\n   * @param {FetchChannelOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      allowUnknownGuild = false,\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels(id).get();\n    return this._add(data, null, {\n      cache,\n      allowUnknownGuild\n    });\n  }\n\n}\n\nmodule.exports = ChannelManager;","map":{"version":3,"names":["CachedManager","require","Channel","Events","ThreadChannelTypes","cacheWarningEmitted","ChannelManager","constructor","client","iterable","defaultCaching","_cache","name","maxSize","undefined","Infinity","sweepFilter","isDefault","process","emitWarning","_add","data","guild","cache","allowUnknownGuild","fromInteraction","existing","get","id","_patch","channels","includes","type","parent","threads","channel","create","emit","DEBUG","set","_remove","delete","fetch","force","partial","api","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/ChannelManager.js"],"sourcesContent":["'use strict';\n\nconst CachedManager = require('./CachedManager');\nconst Channel = require('../structures/Channel');\nconst { Events, ThreadChannelTypes } = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\n\n/**\n * A manager of channels belonging to a client\n * @extends {CachedManager}\n */\nclass ChannelManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Channel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      ((this._cache.maxSize === undefined || this._cache.maxSize === Infinity) &&\n        (this._cache.sweepFilter === undefined || this._cache.sweepFilter.isDefault));\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n  _add(data, guild, { cache = true, allowUnknownGuild = false, fromInteraction = false } = {}) {\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (cache) existing._patch(data, fromInteraction);\n      guild?.channels?._add(existing);\n      if (ThreadChannelTypes.includes(existing.type)) {\n        existing.parent?.threads?._add(existing);\n      }\n      return existing;\n    }\n\n    const channel = Channel.create(this.client, data, guild, { allowUnknownGuild, fromInteraction });\n\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache && !allowUnknownGuild) this.cache.set(channel.id, channel);\n\n    return channel;\n  }\n\n  _remove(id) {\n    const channel = this.cache.get(id);\n    channel?.guild?.channels.cache.delete(id);\n    channel?.parent?.threads?.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel id string.\n   * @method resolveId\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for fetching a channel from discord\n   * @typedef {BaseFetchOptions} FetchChannelOptions\n   * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,\n   * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id The channel's id\n   * @param {FetchChannelOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels(id).get();\n    return this._add(data, null, { cache, allowUnknownGuild });\n  }\n}\n\nmodule.exports = ChannelManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}