{"ast":null,"code":"/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = function (dest, src) {\n  let exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const props = Object.getOwnPropertyDescriptors(src);\n\n  for (let prop of exclude) delete props[prop];\n\n  Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\n\n\nconst protoChain = function (obj) {\n  let currentChain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [obj];\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return currentChain;\n  return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\n\n\nconst nearestCommonProto = function () {\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n\n  if (objs.length === 0) return undefined;\n  let commonProto = undefined;\n  const protoChains = objs.map(obj => protoChain(obj));\n\n  while (protoChains.every(protoChain => protoChain.length > 0)) {\n    const protos = protoChains.map(protoChain => protoChain.pop());\n    const potentialCommonProto = protos[0];\n    if (protos.every(proto => proto === potentialCommonProto)) commonProto = potentialCommonProto;else break;\n  }\n\n  return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\n\n\nconst hardMixProtos = function (ingredients, constructor) {\n  let exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var _a;\n\n  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n  const mixedProto = Object.create(base); // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n  // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n  // when they will already be accessible via prototype access.\n\n  const visitedProtos = protoChain(base);\n\n  for (let prototype of ingredients) {\n    let protos = protoChain(prototype); // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n\n    for (let i = protos.length - 1; i >= 0; i--) {\n      let newProto = protos[i];\n\n      if (visitedProtos.indexOf(newProto) === -1) {\n        copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n        visitedProtos.push(newProto);\n      }\n    }\n  }\n\n  mixedProto.constructor = constructor;\n  return mixedProto;\n};\n\nconst unique = arr => arr.filter((e, i) => arr.indexOf(e) == i);\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\n\n\nconst getIngredientWithProp = (prop, ingredients) => {\n  const protoChains = ingredients.map(ingredient => protoChain(ingredient)); // since we search breadth-first, we need to keep track of our depth in the prototype chains\n\n  let protoDepth = 0; // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n\n  let protosAreLeftToSearch = true;\n\n  while (protosAreLeftToSearch) {\n    // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false; // scan through the ingredients right to left\n\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth];\n\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // if we find something, this is proof that this horizontal slice potentially more objects to search\n        protosAreLeftToSearch = true; // eureka, we found it\n\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0];\n        }\n      }\n    }\n\n    protoDepth++;\n  }\n\n  return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\n\n\nconst proxyMix = function (ingredients) {\n  let prototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.prototype;\n  return new Proxy({}, {\n    getPrototypeOf() {\n      return prototype;\n    },\n\n    setPrototypeOf() {\n      throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n\n    getOwnPropertyDescriptor(_, prop) {\n      return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n\n    defineProperty() {\n      throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n\n    has(_, prop) {\n      return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n\n    get(_, prop) {\n      return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n\n    set(_, prop, val) {\n      const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n      if (ingredientWithProp === undefined) throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n      ingredientWithProp[prop] = val;\n      return true;\n    },\n\n    deleteProperty() {\n      throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n\n    ownKeys() {\n      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    }\n\n  });\n};\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\n\n\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, {\n  constructor\n}]);\n\nconst settings = {\n  initFunction: null,\n  staticsStrategy: 'copy',\n  prototypeStrategy: 'copy',\n  decoratorInheritance: 'deep'\n}; // Keeps track of constituent classes for every mixin class created by ts-mixer.\n\nconst mixins = new Map();\n\nconst getMixinsForClass = clazz => mixins.get(clazz);\n\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\n\nconst hasMixin = (instance, mixin) => {\n  if (instance instanceof mixin) return true;\n  const constructor = instance.constructor;\n  const visited = new Set();\n  let frontier = new Set();\n  frontier.add(constructor);\n\n  while (frontier.size > 0) {\n    // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n    if (frontier.has(mixin)) return true;\n    frontier.forEach(item => visited.add(item)); // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n\n    const newFrontier = new Set();\n    frontier.forEach(item => {\n      var _a;\n\n      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);\n      if (itemConstituents) itemConstituents.forEach(constituent => {\n        if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n      });\n    }); // we have a new frontier, now search again\n\n    frontier = newFrontier;\n  } // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n\n\n  return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n  var _a, _b;\n\n  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n  const mergedObject = {};\n\n  for (let key of allKeys) mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n\n  return mergedObject;\n};\n\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n  var _a, _b, _c, _d;\n\n  return {\n    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n  };\n};\n\nconst mergeDecorators = (d1, d2) => {\n  var _a, _b, _c, _d, _e, _f;\n\n  return {\n    class: unique([...((_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : []), ...((_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : [])]),\n    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n  };\n};\n\nconst decorators = new Map();\n\nconst findAllConstituentClasses = function () {\n  var _a;\n\n  const allClasses = new Set();\n\n  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    classes[_key2] = arguments[_key2];\n  }\n\n  const frontier = new Set([...classes]);\n\n  while (frontier.size > 0) {\n    for (let clazz of frontier) {\n      const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n      const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n\n      for (let newClass of newClasses) frontier.add(newClass);\n\n      allClasses.add(clazz);\n      frontier.delete(clazz);\n    }\n  }\n\n  return [...allClasses];\n};\n\nconst deepDecoratorSearch = function () {\n  const decoratorsForClassChain = findAllConstituentClasses(...arguments).map(clazz => decorators.get(clazz)).filter(decorators => !!decorators);\n  if (decoratorsForClassChain.length == 0) return {};\n  if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\n\nconst directDecoratorSearch = function () {\n  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    classes[_key3] = arguments[_key3];\n  }\n\n  const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n  if (classDecorators.length === 0) return {};\n  if (classDecorators.length === 1) return classDecorators[1];\n  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\n\nconst getDecoratorsForClass = clazz => {\n  let decoratorsForClass = decorators.get(clazz);\n\n  if (!decoratorsForClass) {\n    decoratorsForClass = {};\n    decorators.set(clazz, decoratorsForClass);\n  }\n\n  return decoratorsForClass;\n};\n\nconst decorateClass = decorator => clazz => {\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  let classDecorators = decoratorsForClass.class;\n\n  if (!classDecorators) {\n    classDecorators = [];\n    decoratorsForClass.class = classDecorators;\n  }\n\n  classDecorators.push(decorator);\n  return decorator(clazz);\n};\n\nconst decorateMember = decorator => function (object, key) {\n  const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n  const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n  const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  let decoratorsForTargetType = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType];\n\n  if (!decoratorsForTargetType) {\n    decoratorsForTargetType = {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n  }\n\n  let decoratorsForType = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType];\n\n  if (!decoratorsForType) {\n    decoratorsForType = {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n  }\n\n  let decoratorsForKey = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key];\n\n  if (!decoratorsForKey) {\n    decoratorsForKey = [];\n    decoratorsForType[key] = decoratorsForKey;\n  }\n\n  decoratorsForKey.push(decorator); // @ts-ignore\n\n  for (var _len4 = arguments.length, otherArgs = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    otherArgs[_key4 - 2] = arguments[_key4];\n  }\n\n  return decorator(object, key, ...otherArgs);\n};\n\nconst decorate = decorator => function () {\n  if (arguments.length === 1) return decorateClass(decorator)(arguments.length <= 0 ? undefined : arguments[0]);\n  return decorateMember(decorator)(...arguments);\n};\n\nfunction Mixin() {\n  for (var _len5 = arguments.length, constructors = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    constructors[_key5] = arguments[_key5];\n  }\n\n  var _a, _b, _c;\n\n  const prototypes = constructors.map(constructor => constructor.prototype); // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n  // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n  // similarly to constructors -- not methods, which simply override each other.\n\n  const initFunctionName = settings.initFunction;\n\n  if (initFunctionName !== null) {\n    const initFunctions = prototypes.map(proto => proto[initFunctionName]).filter(func => typeof func === 'function');\n\n    const combinedInitFunction = function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      for (let initFunction of initFunctions) initFunction.apply(this, args);\n    };\n\n    const extraProto = {\n      [initFunctionName]: combinedInitFunction\n    };\n    prototypes.push(extraProto);\n  }\n\n  function MixedClass() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    for (const constructor of constructors) // @ts-ignore: potentially abstract class\n    copyProps(this, new constructor(...args));\n\n    if (initFunctionName !== null && typeof this[initFunctionName] === 'function') this[initFunctionName].apply(this, args);\n  }\n\n  MixedClass.prototype = settings.prototypeStrategy === 'copy' ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy' ? hardMixProtos(constructors, null, ['prototype']) : proxyMix(constructors, Function.prototype));\n  let DecoratedMixedClass = MixedClass;\n\n  if (settings.decoratorInheritance !== 'none') {\n    const classDecorators = settings.decoratorInheritance === 'deep' ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);\n\n    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) DecoratedMixedClass = decorator(DecoratedMixedClass);\n\n    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n  }\n\n  registerMixins(DecoratedMixedClass, constructors);\n  return DecoratedMixedClass;\n}\n\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n  const propDecorators = propAndMethodDecorators.property;\n  const methodDecorators = propAndMethodDecorators.method;\n  if (propDecorators) for (let key in propDecorators) for (let decorator of propDecorators[key]) decorator(target, key);\n  if (methodDecorators) for (let key in methodDecorators) for (let decorator of methodDecorators[key]) decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\n\n\nconst mix = function () {\n  for (var _len8 = arguments.length, ingredients = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    ingredients[_key8] = arguments[_key8];\n  }\n\n  return decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n      value: decoratedClass.name,\n      writable: false\n    });\n    return mixedClass;\n  };\n};\n\nexport { Mixin, decorate, hasMixin, mix, settings };","map":{"version":3,"names":["copyProps","dest","src","exclude","props","Object","getOwnPropertyDescriptors","prop","defineProperties","protoChain","obj","currentChain","proto","getPrototypeOf","nearestCommonProto","objs","length","undefined","commonProto","protoChains","map","every","protos","pop","potentialCommonProto","hardMixProtos","ingredients","constructor","_a","base","prototype","mixedProto","create","visitedProtos","i","newProto","indexOf","push","unique","arr","filter","e","getIngredientWithProp","ingredient","protoDepth","protosAreLeftToSearch","searchTarget","getOwnPropertyDescriptor","proxyMix","Proxy","setPrototypeOf","Error","_","defineProperty","has","get","set","val","ingredientWithProp","deleteProperty","ownKeys","getOwnPropertyNames","reduce","prev","curr","concat","key","softMixProtos","settings","initFunction","staticsStrategy","prototypeStrategy","decoratorInheritance","mixins","Map","getMixinsForClass","clazz","registerMixins","mixedClass","constituents","hasMixin","instance","mixin","visited","Set","frontier","add","size","forEach","item","newFrontier","itemConstituents","constituent","mergeObjectsOfDecorators","o1","o2","_b","allKeys","mergedObject","mergePropertyAndMethodDecorators","d1","d2","_c","_d","property","method","mergeDecorators","_e","_f","class","static","decorators","findAllConstituentClasses","allClasses","classes","protoChainClasses","mixinClasses","potentiallyNewClasses","newClasses","c","newClass","delete","deepDecoratorSearch","decoratorsForClassChain","directDecoratorSearch","classDecorators","getDecoratorsForClass","decoratorsForClass","decorateClass","decorator","decorateMember","object","decoratorTargetType","decoratorType","decoratorsForTargetType","decoratorsForType","decoratorsForKey","otherArgs","decorate","Mixin","constructors","prototypes","initFunctionName","initFunctions","func","combinedInitFunction","args","apply","extraProto","MixedClass","Function","DecoratedMixedClass","applyPropAndMethodDecorators","propAndMethodDecorators","target","propDecorators","methodDecorators","mix","decoratedClass","value","name","writable"],"sources":["C:/Users/ROUSER6/node_modules/ts-mixer/dist/esm/index.js"],"sourcesContent":["/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new Map();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach(item => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach(item => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach(constituent => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[1];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let decoratorsForTargetType = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType];\n    if (!decoratorsForTargetType) {\n        decoratorsForTargetType = {};\n        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    }\n    let decoratorsForType = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType];\n    if (!decoratorsForType) {\n        decoratorsForType = {};\n        decoratorsForTargetType[decoratorType] = decoratorsForType;\n    }\n    let decoratorsForKey = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key];\n    if (!decoratorsForKey) {\n        decoratorsForKey = [];\n        decoratorsForType[key] = decoratorsForKey;\n    }\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : [])\n            DecoratedMixedClass = decorator(DecoratedMixedClass);\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\nexport { Mixin, decorate, hasMixin, mix, settings };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}