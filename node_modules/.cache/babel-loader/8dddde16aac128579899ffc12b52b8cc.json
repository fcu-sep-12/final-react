{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\n\nconst PermissionOverwrites = require('./PermissionOverwrites');\n\nconst {\n  Error\n} = require('../errors');\n\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\n\nconst {\n  ChannelTypes,\n  VoiceBasedChannelTypes\n} = require('../util/Constants');\n\nconst Permissions = require('../util/Permissions');\n\nconst Util = require('../util/Util');\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * - {@link StageChannel}\n * @extends {Channel}\n * @abstract\n */\n\n\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {APIChannel} data The data for the guild channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   * @param {boolean} [immediatePatch=true] Control variable for patching\n   */\n  constructor(guild, data, client) {\n    let immediatePatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    super(guild?.client ?? client, data, false);\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n\n    this.guildId = guild?.id ?? data.guild_id;\n    this.parentId = this.parentId ?? null;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n    if (data && immediatePatch) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    }\n\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n\n  _clone() {\n    const clone = super._clone();\n\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get permissionsLocked() {\n    if (!this.parent) return null; // Get all overwrites\n\n    const overwriteIds = new Set([...this.permissionOverwrites.cache.keys(), ...this.parent.permissionOverwrites.cache.keys()]); // Compare all overwrites\n\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key); // Handle empty overwrite\n\n      if (!channelVal && parentVal.deny.bitfield === Permissions.defaultBit && parentVal.allow.bitfield === Permissions.defaultBit || !parentVal && channelVal.deny.bitfield === Permissions.defaultBit && channelVal.allow.bitfield === Permissions.defaultBit) {\n        return true;\n      } // Compare overwrites\n\n\n      return typeof channelVal !== 'undefined' && typeof parentVal !== 'undefined' && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;\n    });\n  }\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n\n\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role);\n  }\n\n  overwritesFor(member) {\n    let verified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n    if (!roles) roles = member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerId) return new Permissions(Permissions.ALL).freeze();\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone?.deny ?? Permissions.defaultBit).add(overwrites.everyone?.allow ?? Permissions.defaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : Permissions.defaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : Permissions.defaultBit).remove(overwrites.member?.deny ?? Permissions.defaultBit).add(overwrites.member?.allow ?? Permissions.defaultBit).freeze();\n  }\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n    return role.permissions.remove(everyoneOverwrites?.deny ?? Permissions.defaultBit).add(everyoneOverwrites?.allow ?? Permissions.defaultBit).remove(roleOverwrites?.deny ?? Permissions.defaultBit).add(roleOverwrites?.allow ?? Permissions.defaultBit).freeze();\n  }\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text based.\n   * Members in the channel, if the channel is voice based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(Permissions.FLAGS.VIEW_CHANNEL, false));\n  }\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    if (data.parent) data.parent = this.client.channels.resolveId(data.parent);\n\n    if (typeof data.position !== 'undefined') {\n      const updatedChannels = await Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason);\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parent) {\n        const newParent = this.guild.channels.resolve(data.parent);\n\n        if (newParent?.type === 'GUILD_CATEGORY') {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        type: ChannelTypes[data.type],\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? this.bitrate,\n        user_limit: data.userLimit ?? this.userLimit,\n        rtc_region: data.rtcRegion ?? this.rtcRegion,\n        parent_id: data.parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites\n      },\n      reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Options used to set parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setParent(channel) {\n    let {\n      lockPermissions = true,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.edit({\n      parent: channel ?? null,\n      lockPermissions\n    }, reason);\n  }\n  /**\n   * Options used to set position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @param {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @param {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n\n\n  async setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const updatedChannels = await Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason);\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels\n    });\n    return this;\n  }\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.guild.channels.create(options.name ?? this.name, {\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.position,\n      reason: null,\n      ...options\n    });\n  }\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false) && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;\n  }\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n\n    if (VoiceBasedChannelTypes.includes(this.type)) {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({\n      reason\n    });\n    return this;\n  }\n\n}\n\nmodule.exports = GuildChannel;","map":{"version":3,"names":["Channel","require","PermissionOverwrites","Error","PermissionOverwriteManager","ChannelTypes","VoiceBasedChannelTypes","Permissions","Util","GuildChannel","constructor","guild","data","client","immediatePatch","guildId","id","guild_id","parentId","permissionOverwrites","_patch","name","rawPosition","position","parent_id","cache","clear","overwrite","permission_overwrites","_add","_clone","clone","values","parent","channels","resolve","permissionsLocked","overwriteIds","Set","keys","every","key","channelVal","get","parentVal","deny","bitfield","defaultBit","allow","sorted","_sortedChannels","indexOf","permissionsFor","memberOrRole","member","members","memberPermissions","role","roles","rolePermissions","overwritesFor","verified","roleOverwrites","memberOverwrites","everyoneOverwrites","has","push","everyone","ownerId","ALL","freeze","permissions","map","FLAGS","ADMINISTRATOR","overwrites","remove","add","length","lockPermissions","Promise","reject","toJSON","edit","filter","m","VIEW_CHANNEL","reason","resolveId","updatedChannels","setPosition","api","guilds","actions","GuildChannelsPositionUpdate","handle","o","newParent","type","newData","patch","trim","topic","nsfw","bitrate","user_limit","userLimit","rtc_region","rtcRegion","lock_permissions","rate_limit_per_user","rateLimitPerUser","default_auto_archive_duration","defaultAutoArchiveDuration","ChannelUpdate","updated","setName","setParent","channel","relative","options","create","equals","equal","deletable","user","MANAGE_CHANNELS","rulesChannelId","publicUpdatesChannelId","manageable","includes","CONNECT","viewable","delete","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/GuildChannel.js"],"sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst PermissionOverwrites = require('./PermissionOverwrites');\nconst { Error } = require('../errors');\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\nconst { ChannelTypes, VoiceBasedChannelTypes } = require('../util/Constants');\nconst Permissions = require('../util/Permissions');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * - {@link StageChannel}\n * @extends {Channel}\n * @abstract\n */\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {APIChannel} data The data for the guild channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   * @param {boolean} [immediatePatch=true] Control variable for patching\n   */\n  constructor(guild, data, client, immediatePatch = true) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    this.parentId = this.parentId ?? null;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n\n    if (data && immediatePatch) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    }\n\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n\n  _clone() {\n    const clone = super._clone();\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n\n    // Get all overwrites\n    const overwriteIds = new Set([\n      ...this.permissionOverwrites.cache.keys(),\n      ...this.parent.permissionOverwrites.cache.keys(),\n    ]);\n\n    // Compare all overwrites\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key);\n\n      // Handle empty overwrite\n      if (\n        (!channelVal &&\n          parentVal.deny.bitfield === Permissions.defaultBit &&\n          parentVal.allow.bitfield === Permissions.defaultBit) ||\n        (!parentVal &&\n          channelVal.deny.bitfield === Permissions.defaultBit &&\n          channelVal.allow.bitfield === Permissions.defaultBit)\n      ) {\n        return true;\n      }\n\n      // Compare overwrites\n      return (\n        typeof channelVal !== 'undefined' &&\n        typeof parentVal !== 'undefined' &&\n        channelVal.deny.bitfield === parentVal.deny.bitfield &&\n        channelVal.allow.bitfield === parentVal.allow.bitfield\n      );\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role);\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n\n    if (!roles) roles = member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites,\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerId) return new Permissions(Permissions.ALL).freeze();\n\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const overwrites = this.overwritesFor(member, true, roles);\n\n    return permissions\n      .remove(overwrites.everyone?.deny ?? Permissions.defaultBit)\n      .add(overwrites.everyone?.allow ?? Permissions.defaultBit)\n      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : Permissions.defaultBit)\n      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : Permissions.defaultBit)\n      .remove(overwrites.member?.deny ?? Permissions.defaultBit)\n      .add(overwrites.member?.allow ?? Permissions.defaultBit)\n      .freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n\n    return role.permissions\n      .remove(everyoneOverwrites?.deny ?? Permissions.defaultBit)\n      .add(everyoneOverwrites?.allow ?? Permissions.defaultBit)\n      .remove(roleOverwrites?.deny ?? Permissions.defaultBit)\n      .add(roleOverwrites?.allow ?? Permissions.defaultBit)\n      .freeze();\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({ permissionOverwrites });\n  }\n\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text based.\n   * Members in the channel, if the channel is voice based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(Permissions.FLAGS.VIEW_CHANNEL, false));\n  }\n\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (data.parent) data.parent = this.client.channels.resolveId(data.parent);\n\n    if (typeof data.position !== 'undefined') {\n      const updatedChannels = await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedChannels(this),\n        this.client.api.guilds(this.guild.id).channels,\n        reason,\n      );\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels,\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parent) {\n        const newParent = this.guild.channels.resolve(data.parent);\n        if (newParent?.type === 'GUILD_CATEGORY') {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o =>\n            PermissionOverwrites.resolve(o, this.guild),\n          );\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.cache.map(o =>\n          PermissionOverwrites.resolve(o, this.guild),\n        );\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        type: ChannelTypes[data.type],\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? this.bitrate,\n        user_limit: data.userLimit ?? this.userLimit,\n        rtc_region: data.rtcRegion ?? this.rtcRegion,\n        parent_id: data.parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites,\n      },\n      reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Options used to set parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, { lockPermissions = true, reason } = {}) {\n    return this.edit(\n      {\n        parent: channel ?? null,\n        lockPermissions,\n      },\n      reason,\n    );\n  }\n\n  /**\n   * Options used to set position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @param {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @param {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(position, { relative, reason } = {}) {\n    const updatedChannels = await Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedChannels(this),\n      this.client.api.guilds(this.guild.id).channels,\n      reason,\n    );\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels,\n    });\n    return this;\n  }\n\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    return this.guild.channels.create(options.name ?? this.name, {\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.position,\n      reason: null,\n      ...options,\n    });\n  }\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal =\n      channel &&\n      this.id === channel.id &&\n      this.type === channel.type &&\n      this.topic === channel.topic &&\n      this.position === channel.position &&\n      this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return (\n      this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false) &&\n      this.guild.rulesChannelId !== this.id &&\n      this.guild.publicUpdatesChannelId !== this.id\n    );\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    if (VoiceBasedChannelTypes.includes(this.type)) {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({ reason });\n    return this;\n  }\n}\n\nmodule.exports = GuildChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}