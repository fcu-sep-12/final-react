{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\n\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\n\nconst GuildMember = require('../structures/GuildMember');\n\nconst Role = require('../structures/Role');\n\nconst {\n  Events,\n  Opcodes\n} = require('../util/Constants');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n\n  _add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return super._add(data, cache, {\n      id: data.user.id,\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n\n\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the\n   * bot's application\n   * @property {string} [nick] The nickname to give to the member (requires `MANAGE_NICKNAMES`)\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * (requires `MANAGE_ROLES`)\n   * @property {boolean} [mute] Whether the member should be muted (requires `MUTE_MEMBERS`)\n   * @property {boolean} [deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)\n   * @property {boolean} [force] Whehter to skip the cache check and call the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n\n\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');\n\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf\n    };\n\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const resolvedRoles = [];\n\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'options.roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n\n      resolvedOptions.roles = resolvedRoles;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).members(userId).put({\n      data: resolvedOptions\n    }); // Data is an empty buffer if the member is already part of the guild.\n\n    return data instanceof Buffer ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);\n  }\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveId(options);\n    if (user) return this._fetchSingle({\n      user,\n      cache: true\n    });\n\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveId(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveId(options.user);\n      }\n\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n\n    return this._fetchMany(options);\n  }\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit=1] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n\n\n  async search() {\n    let {\n      query,\n      limit = 1,\n      cache = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.api.guilds(this.guild.id).members.search.get({\n      query: {\n        query,\n        limit\n      }\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit=1] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n\n\n  async list() {\n    let {\n      after,\n      limit = 1,\n      cache = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.api.guilds(this.guild.id).members.get({\n      query: {\n        after,\n        limit\n      }\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n\n\n  async edit(user, data, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable'); // Clone the data object for immutability\n\n    const _data = { ...data\n    };\n\n    if (_data.channel) {\n      _data.channel = this.guild.channels.resolve(_data.channel);\n\n      if (!(_data.channel instanceof BaseGuildVoiceChannel)) {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n\n      _data.channel_id = _data.channel.id;\n      _data.channel = undefined;\n    } else if (_data.channel === null) {\n      _data.channel_id = null;\n      _data.channel = undefined;\n    }\n\n    if (_data.roles) _data.roles = _data.roles.map(role => role instanceof Role ? role.id : role);\n    let endpoint = this.client.api.guilds(this.guild.id);\n\n    if (id === this.client.user.id) {\n      const keys = Object.keys(_data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;else endpoint = endpoint.members(id);\n    } else {\n      endpoint = endpoint.members(id);\n    }\n\n    const d = await endpoint.patch({\n      data: _data,\n      reason\n    });\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days=7] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count=true] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n\n\n  async prune() {\n    let {\n      days = 7,\n      dry = false,\n      count: compute_prune_count = true,\n      roles = [],\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n    const query = {\n      days\n    };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n\n      if (!resolvedRole) {\n        throw new TypeError('INVALID_ELEMENT', 'Array', 'options.roles', role);\n      }\n\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n    const {\n      pruned\n    } = await (dry ? endpoint.get({\n      query,\n      reason\n    }) : endpoint.post({\n      data: { ...query,\n        compute_prune_count\n      },\n      reason\n    }));\n    return pruned;\n  }\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(banInfo => console.log(`Kicked ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n\n\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new TypeError('INVALID_TYPE', 'user', 'UserResolvable'));\n    await this.client.api.guilds(this.guild.id).members(id).delete({\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(kickInfo => console.log(`Banned ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n\n\n  ban(user) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      days: 0\n    };\n    return this.guild.bans.create(user, options);\n  }\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n\n\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  async _fetchSingle(_ref) {\n    let {\n      user,\n      cache,\n      force = false\n    } = _ref;\n\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).members(user).get();\n    return this._add(data, cache);\n  }\n\n  _fetchMany() {\n    let {\n      limit = 0,\n      withPresences: presences = false,\n      user: user_ids,\n      query,\n      time = 120e3,\n      nonce = SnowflakeUtil.generate()\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: Opcodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit\n        }\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n\n        if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = fetchedMembers;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n\n}\n\nmodule.exports = GuildMemberManager;","map":{"version":3,"names":["Collection","require","CachedManager","Error","TypeError","RangeError","BaseGuildVoiceChannel","GuildMember","Role","Events","Opcodes","SnowflakeUtil","GuildMemberManager","constructor","guild","iterable","client","_add","data","cache","id","user","extras","resolve","member","memberResolvable","userResolvable","users","resolveId","has","add","options","userId","force","cachedUser","get","resolvedOptions","access_token","accessToken","nick","mute","deaf","roles","Array","isArray","resolvedRoles","role","values","resolvedRole","push","api","guilds","members","put","Buffer","fetchWhenExisting","fetch","_fetchMany","_fetchSingle","map","u","limit","withPresences","search","query","reduce","col","set","list","after","edit","reason","_data","channel","channels","channel_id","undefined","endpoint","keys","Object","length","d","patch","clone","_clone","_patch","prune","days","dry","count","compute_prune_count","include_roles","join","pruned","post","kick","Promise","reject","delete","ban","bans","create","unban","remove","existing","partial","presences","user_ids","time","nonce","generate","shard","send","op","REQUEST_GUILD_MEMBERS","guild_id","fetchedMembers","i","handler","_","chunk","timeout","refresh","size","clearTimeout","removeListener","GUILD_MEMBERS_CHUNK","decrementMaxListeners","fetched","first","setTimeout","unref","incrementMaxListeners","on","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/GuildMemberManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\nconst GuildMember = require('../structures/GuildMember');\nconst Role = require('../structures/Role');\nconst { Events, Opcodes } = require('../util/Constants');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    return super._add(data, cache, { id: data.user.id, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the\n   * bot's application\n   * @property {string} [nick] The nickname to give to the member (requires `MANAGE_NICKNAMES`)\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * (requires `MANAGE_ROLES`)\n   * @property {boolean} [mute] Whether the member should be muted (requires `MUTE_MEMBERS`)\n   * @property {boolean} [deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)\n   * @property {boolean} [force] Whehter to skip the cache check and call the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf,\n    };\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      const resolvedRoles = [];\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'options.roles', role);\n        resolvedRoles.push(resolvedRole);\n      }\n      resolvedOptions.roles = resolvedRoles;\n    }\n    const data = await this.client.api.guilds(this.guild.id).members(userId).put({ data: resolvedOptions });\n    // Data is an empty buffer if the member is already part of the guild.\n    return data instanceof Buffer ? (options.fetchWhenExisting === false ? null : this.fetch(userId)) : this._add(data);\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveId(options);\n    if (user) return this._fetchSingle({ user, cache: true });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveId(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveId(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit=1] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async search({ query, limit = 1, cache = true } = {}) {\n    const data = await this.client.api.guilds(this.guild.id).members.search.get({ query: { query, limit } });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit=1] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async list({ after, limit = 1, cache = true } = {}) {\n    const data = await this.client.api.guilds(this.guild.id).members.get({ query: { after, limit } });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(user, data, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');\n\n    // Clone the data object for immutability\n    const _data = { ...data };\n    if (_data.channel) {\n      _data.channel = this.guild.channels.resolve(_data.channel);\n      if (!(_data.channel instanceof BaseGuildVoiceChannel)) {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n      _data.channel_id = _data.channel.id;\n      _data.channel = undefined;\n    } else if (_data.channel === null) {\n      _data.channel_id = null;\n      _data.channel = undefined;\n    }\n    if (_data.roles) _data.roles = _data.roles.map(role => (role instanceof Role ? role.id : role));\n    let endpoint = this.client.api.guilds(this.guild.id);\n    if (id === this.client.user.id) {\n      const keys = Object.keys(_data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;\n      else endpoint = endpoint.members(id);\n    } else {\n      endpoint = endpoint.members(id);\n    }\n    const d = await endpoint.patch({ data: _data, reason });\n\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days=7] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count=true] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  async prune({ days = 7, dry = false, count: compute_prune_count = true, roles = [], reason } = {}) {\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n\n    const query = { days };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n      if (!resolvedRole) {\n        throw new TypeError('INVALID_ELEMENT', 'Array', 'options.roles', role);\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n\n    const { pruned } = await (dry\n      ? endpoint.get({ query, reason })\n      : endpoint.post({ data: { ...query, compute_prune_count }, reason }));\n\n    return pruned;\n  }\n\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(banInfo => console.log(`Kicked ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new TypeError('INVALID_TYPE', 'user', 'UserResolvable'));\n\n    await this.client.api.guilds(this.guild.id).members(id).delete({ reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(kickInfo => console.log(`Banned ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n  ban(user, options = { days: 0 }) {\n    return this.guild.bans.create(user, options);\n  }\n\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  async _fetchSingle({ user, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).members(user).get();\n    return this._add(data, cache);\n  }\n\n  _fetchMany({\n    limit = 0,\n    withPresences: presences = false,\n    user: user_ids,\n    query,\n    time = 120e3,\n    nonce = SnowflakeUtil.generate(),\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: Opcodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit,\n        },\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n        if (members.size < 1000 || (limit && fetchedMembers.size >= limit) || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = fetchedMembers;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n}\n\nmodule.exports = GuildMemberManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}