{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst ApplicationCommandPermissionsManager = require('./ApplicationCommandPermissionsManager');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst ApplicationCommand = require('../structures/ApplicationCommand');\n\nconst {\n  ApplicationCommandTypes\n} = require('../util/Constants');\n/**\n * Manages API methods for application commands and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass ApplicationCommandManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, ApplicationCommand, iterable);\n    /**\n     * The manager for permissions of arbitrary commands on arbitrary guilds\n     * @type {ApplicationCommandPermissionsManager}\n     */\n\n    this.permissions = new ApplicationCommandPermissionsManager(this);\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, ApplicationCommand>}\n   * @name ApplicationCommandManager#cache\n   */\n\n\n  _add(data, cache, guildId) {\n    return super._add(data, cache, {\n      extras: [this.guild, guildId]\n    });\n  }\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} [options.id] The application command's id\n   * @param {Snowflake} [options.guildId] The guild's id to use in the path,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Object}\n   * @private\n   */\n\n\n  commandPath() {\n    let {\n      id,\n      guildId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let path = this.client.api.applications(this.client.application.id);\n    if (this.guild ?? guildId) path = path.guilds(this.guild?.id ?? guildId);\n    return id ? path.commands(id) : path.commands;\n  }\n  /**\n   * Data that resolves to give an ApplicationCommand object. This can be:\n   * * An ApplicationCommand object\n   * * A Snowflake\n   * @typedef {ApplicationCommand|Snowflake} ApplicationCommandResolvable\n   */\n\n  /**\n   * Options used to fetch data from discord\n   * @typedef {Object} BaseFetchOptions\n   * @property {boolean} [cache=true] Whether to cache the fetched data if it wasn't already\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch Application Commands from discord\n   * @typedef {BaseFetchOptions} FetchApplicationCommandOptions\n   * @property {Snowflake} [guildId] The guild's id to fetch commands for, for when the guild is not cached\n   */\n\n  /**\n   * Obtains one or multiple application commands from Discord, or the cache if it's already available.\n   * @param {Snowflake} [id] The application command's id\n   * @param {FetchApplicationCommandOptions} [options] Additional options for this fetch\n   * @returns {Promise<ApplicationCommand|Collection<Snowflake, ApplicationCommand>>}\n   * @example\n   * // Fetch a single command\n   * client.application.commands.fetch('123456789012345678')\n   *   .then(command => console.log(`Fetched command ${command.name}`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch all commands\n   * guild.commands.fetch()\n   *   .then(commands => console.log(`Fetched ${commands.size} commands`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      guildId,\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof id === 'object') {\n      ({\n        guildId,\n        cache = true\n      } = id);\n    } else if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const command = await this.commandPath({\n        id,\n        guildId\n      }).get();\n      return this._add(command, cache);\n    }\n\n    const data = await this.commandPath({\n      guildId\n    }).get();\n    return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection());\n  }\n  /**\n   * Creates an application command.\n   * @param {ApplicationCommandData} command The command\n   * @param {Snowflake} [guildId] The guild's id to create this command in,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Create a new command\n   * client.application.commands.create({\n   *   name: 'test',\n   *   description: 'A test command',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async create(command, guildId) {\n    const data = await this.commandPath({\n      guildId\n    }).post({\n      data: this.constructor.transformCommand(command)\n    });\n    return this._add(data, !guildId, guildId);\n  }\n  /**\n   * Sets all the commands for this application or guild.\n   * @param {ApplicationCommandData[]} commands The commands\n   * @param {Snowflake} [guildId] The guild's id to create the commands in,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<Collection<Snowflake, ApplicationCommand>>}\n   * @example\n   * // Set all commands to just this one\n   * client.application.commands.set([\n   *   {\n   *     name: 'test',\n   *     description: 'A test command',\n   *   },\n   * ])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all commands\n   * guild.commands.set([])\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async set(commands, guildId) {\n    const data = await this.commandPath({\n      guildId\n    }).put({\n      data: commands.map(c => this.constructor.transformCommand(c))\n    });\n    return data.reduce((coll, command) => coll.set(command.id, this._add(command, !guildId, guildId)), new Collection());\n  }\n  /**\n   * Edits an application command.\n   * @param {ApplicationCommandResolvable} command The command to edit\n   * @param {ApplicationCommandData} data The data to update the command with\n   * @param {Snowflake} [guildId] The guild's id where the command registered,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Edit an existing command\n   * client.application.commands.edit('123456789012345678', {\n   *   description: 'New description',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async edit(command, data, guildId) {\n    const id = this.resolveId(command);\n    if (!id) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n    const patched = await this.commandPath({\n      id,\n      guildId\n    }).patch({\n      data: this.constructor.transformCommand(data)\n    });\n    return this._add(patched, !guildId, guildId);\n  }\n  /**\n   * Deletes an application command.\n   * @param {ApplicationCommandResolvable} command The command to delete\n   * @param {Snowflake} [guildId] The guild's id where the command is registered,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<?ApplicationCommand>}\n   * @example\n   * // Delete a command\n   * guild.commands.delete('123456789012345678')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async delete(command, guildId) {\n    const id = this.resolveId(command);\n    if (!id) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n    await this.commandPath({\n      id,\n      guildId\n    }).delete();\n    const cached = this.cache.get(id);\n    if (!guildId) this.cache.delete(id);\n    return cached ?? null;\n  }\n  /**\n   * Transforms an {@link ApplicationCommandData} object into something that can be used with the API.\n   * @param {ApplicationCommandData} command The command to transform\n   * @returns {APIApplicationCommand}\n   * @private\n   */\n\n\n  static transformCommand(command) {\n    return {\n      name: command.name,\n      description: command.description,\n      type: typeof command.type === 'number' ? command.type : ApplicationCommandTypes[command.type],\n      options: command.options?.map(o => ApplicationCommand.transformOption(o)),\n      default_permission: command.defaultPermission\n    };\n  }\n\n}\n\nmodule.exports = ApplicationCommandManager;","map":{"version":3,"names":["Collection","require","ApplicationCommandPermissionsManager","CachedManager","TypeError","ApplicationCommand","ApplicationCommandTypes","ApplicationCommandManager","constructor","client","iterable","permissions","_add","data","cache","guildId","extras","guild","commandPath","id","path","api","applications","application","guilds","commands","fetch","force","existing","get","command","reduce","coll","set","create","post","transformCommand","put","map","c","edit","resolveId","patched","patch","delete","cached","name","description","type","options","o","transformOption","default_permission","defaultPermission","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/ApplicationCommandManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst ApplicationCommandPermissionsManager = require('./ApplicationCommandPermissionsManager');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst ApplicationCommand = require('../structures/ApplicationCommand');\nconst { ApplicationCommandTypes } = require('../util/Constants');\n\n/**\n * Manages API methods for application commands and stores their cache.\n * @extends {CachedManager}\n */\nclass ApplicationCommandManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, ApplicationCommand, iterable);\n\n    /**\n     * The manager for permissions of arbitrary commands on arbitrary guilds\n     * @type {ApplicationCommandPermissionsManager}\n     */\n    this.permissions = new ApplicationCommandPermissionsManager(this);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, ApplicationCommand>}\n   * @name ApplicationCommandManager#cache\n   */\n\n  _add(data, cache, guildId) {\n    return super._add(data, cache, { extras: [this.guild, guildId] });\n  }\n\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} [options.id] The application command's id\n   * @param {Snowflake} [options.guildId] The guild's id to use in the path,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Object}\n   * @private\n   */\n  commandPath({ id, guildId } = {}) {\n    let path = this.client.api.applications(this.client.application.id);\n    if (this.guild ?? guildId) path = path.guilds(this.guild?.id ?? guildId);\n    return id ? path.commands(id) : path.commands;\n  }\n\n  /**\n   * Data that resolves to give an ApplicationCommand object. This can be:\n   * * An ApplicationCommand object\n   * * A Snowflake\n   * @typedef {ApplicationCommand|Snowflake} ApplicationCommandResolvable\n   */\n\n  /**\n   * Options used to fetch data from discord\n   * @typedef {Object} BaseFetchOptions\n   * @property {boolean} [cache=true] Whether to cache the fetched data if it wasn't already\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch Application Commands from discord\n   * @typedef {BaseFetchOptions} FetchApplicationCommandOptions\n   * @property {Snowflake} [guildId] The guild's id to fetch commands for, for when the guild is not cached\n   */\n\n  /**\n   * Obtains one or multiple application commands from Discord, or the cache if it's already available.\n   * @param {Snowflake} [id] The application command's id\n   * @param {FetchApplicationCommandOptions} [options] Additional options for this fetch\n   * @returns {Promise<ApplicationCommand|Collection<Snowflake, ApplicationCommand>>}\n   * @example\n   * // Fetch a single command\n   * client.application.commands.fetch('123456789012345678')\n   *   .then(command => console.log(`Fetched command ${command.name}`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch all commands\n   * guild.commands.fetch()\n   *   .then(commands => console.log(`Fetched ${commands.size} commands`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { guildId, cache = true, force = false } = {}) {\n    if (typeof id === 'object') {\n      ({ guildId, cache = true } = id);\n    } else if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const command = await this.commandPath({ id, guildId }).get();\n      return this._add(command, cache);\n    }\n\n    const data = await this.commandPath({ guildId }).get();\n    return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection());\n  }\n\n  /**\n   * Creates an application command.\n   * @param {ApplicationCommandData} command The command\n   * @param {Snowflake} [guildId] The guild's id to create this command in,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Create a new command\n   * client.application.commands.create({\n   *   name: 'test',\n   *   description: 'A test command',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(command, guildId) {\n    const data = await this.commandPath({ guildId }).post({\n      data: this.constructor.transformCommand(command),\n    });\n    return this._add(data, !guildId, guildId);\n  }\n\n  /**\n   * Sets all the commands for this application or guild.\n   * @param {ApplicationCommandData[]} commands The commands\n   * @param {Snowflake} [guildId] The guild's id to create the commands in,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<Collection<Snowflake, ApplicationCommand>>}\n   * @example\n   * // Set all commands to just this one\n   * client.application.commands.set([\n   *   {\n   *     name: 'test',\n   *     description: 'A test command',\n   *   },\n   * ])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all commands\n   * guild.commands.set([])\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async set(commands, guildId) {\n    const data = await this.commandPath({ guildId }).put({\n      data: commands.map(c => this.constructor.transformCommand(c)),\n    });\n    return data.reduce(\n      (coll, command) => coll.set(command.id, this._add(command, !guildId, guildId)),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Edits an application command.\n   * @param {ApplicationCommandResolvable} command The command to edit\n   * @param {ApplicationCommandData} data The data to update the command with\n   * @param {Snowflake} [guildId] The guild's id where the command registered,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Edit an existing command\n   * client.application.commands.edit('123456789012345678', {\n   *   description: 'New description',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(command, data, guildId) {\n    const id = this.resolveId(command);\n    if (!id) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n\n    const patched = await this.commandPath({ id, guildId }).patch({ data: this.constructor.transformCommand(data) });\n    return this._add(patched, !guildId, guildId);\n  }\n\n  /**\n   * Deletes an application command.\n   * @param {ApplicationCommandResolvable} command The command to delete\n   * @param {Snowflake} [guildId] The guild's id where the command is registered,\n   * ignored when using a {@link GuildApplicationCommandManager}\n   * @returns {Promise<?ApplicationCommand>}\n   * @example\n   * // Delete a command\n   * guild.commands.delete('123456789012345678')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(command, guildId) {\n    const id = this.resolveId(command);\n    if (!id) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n\n    await this.commandPath({ id, guildId }).delete();\n\n    const cached = this.cache.get(id);\n    if (!guildId) this.cache.delete(id);\n    return cached ?? null;\n  }\n\n  /**\n   * Transforms an {@link ApplicationCommandData} object into something that can be used with the API.\n   * @param {ApplicationCommandData} command The command to transform\n   * @returns {APIApplicationCommand}\n   * @private\n   */\n  static transformCommand(command) {\n    return {\n      name: command.name,\n      description: command.description,\n      type: typeof command.type === 'number' ? command.type : ApplicationCommandTypes[command.type],\n      options: command.options?.map(o => ApplicationCommand.transformOption(o)),\n      default_permission: command.defaultPermission,\n    };\n  }\n}\n\nmodule.exports = ApplicationCommandManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}