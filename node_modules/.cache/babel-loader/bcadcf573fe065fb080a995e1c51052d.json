{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  ChannelTypes\n} = require('../util/Constants');\n\nconst Util = require('../util/Util');\n/**\n * Keeps track of mentions in a {@link Message}.\n */\n\n\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members._add(Object.assign(mention.member, {\n              user: mention\n            }));\n          }\n\n          const user = message.client.users._add(mention);\n\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles instanceof Collection) {\n      /**\n       * Any roles that were mentioned\n       * <info>Order as received from the API, not as they appear in the message content</info>\n       * @type {Collection<Snowflake, Role>}\n       */\n      this.roles = new Collection(roles);\n    } else if (roles) {\n      this.roles = new Collection();\n      const guild = message.guild;\n\n      if (guild) {\n        for (const mention of roles) {\n          const role = guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n\n\n    this._members = null;\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, Channel>}\n     * @private\n     */\n\n    this._channels = null;\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {Snowflake} channelId The mentioned channel's id\n     * @property {Snowflake} guildId The id of the guild that has the channel\n     * @property {ChannelType} type The channel's type\n     * @property {string} name The channel's name\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelId: d.id,\n            guildId: d.guild_id,\n            type: type ?? 'UNKNOWN',\n            name: d.name\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n    /**\n     * The author of the message that this message is a reply to\n     * @type {?User}\n     */\n\n\n    this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;\n  }\n  /**\n   * Any members that were mentioned (only in {@link Guild}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.members.resolve(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, Channel>}\n   * @readonly\n   */\n\n\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n\n    return this._channels;\n  }\n  /**\n   * Options used to check for a mention.\n   * @typedef {Object} MessageMentionsHasOptions\n   * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item\n   * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member\n   * @property {boolean} [ignoreEveryone=false] Whether to ignore everyone/here mentions\n   */\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and `@everyone`/`@here` mentions.\n   * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for\n   * @param {MessageMentionsHasOptions} [options] The options for the check\n   * @returns {boolean}\n   */\n\n\n  has(data) {\n    let {\n      ignoreDirect = false,\n      ignoreRoles = false,\n      ignoreEveryone = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ignoreEveryone && this.everyone) return true;\n\n    const GuildMember = require('./GuildMember');\n\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id = this.guild?.roles.resolveId(data) ?? this.client.channels.resolveId(data) ?? this.client.users.resolveId(data);\n      return typeof id === 'string' && (this.users.has(id) || this.channels.has(id) || this.roles.has(id));\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true\n    });\n  }\n\n}\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\n\n\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\n\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\n\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\n\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\nmodule.exports = MessageMentions;","map":{"version":3,"names":["Collection","require","ChannelTypes","Util","MessageMentions","constructor","message","users","roles","everyone","crosspostedChannels","repliedUser","Object","defineProperty","value","client","guild","content","Boolean","mention","member","members","_add","assign","user","set","id","role","cache","get","_members","_channels","channelTypes","keys","d","type","channelId","guildId","guild_id","name","forEach","resolve","channels","matches","CHANNELS_PATTERN","exec","_content","chan","has","data","ignoreDirect","ignoreRoles","ignoreEveryone","GuildMember","values","resolveId","toJSON","flatten","EVERYONE_PATTERN","USERS_PATTERN","ROLES_PATTERN","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/MessageMentions.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { ChannelTypes } = require('../util/Constants');\nconst Util = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: message.client });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', { value: message.guild });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', { value: message.content });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members._add(Object.assign(mention.member, { user: mention }));\n          }\n          const user = message.client.users._add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles instanceof Collection) {\n      /**\n       * Any roles that were mentioned\n       * <info>Order as received from the API, not as they appear in the message content</info>\n       * @type {Collection<Snowflake, Role>}\n       */\n      this.roles = new Collection(roles);\n    } else if (roles) {\n      this.roles = new Collection();\n      const guild = message.guild;\n      if (guild) {\n        for (const mention of roles) {\n          const role = guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, Channel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {Snowflake} channelId The mentioned channel's id\n     * @property {Snowflake} guildId The id of the guild that has the channel\n     * @property {ChannelType} type The channel's type\n     * @property {string} name The channel's name\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelId: d.id,\n            guildId: d.guild_id,\n            type: type ?? 'UNKNOWN',\n            name: d.name,\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n\n    /**\n     * The author of the message that this message is a reply to\n     * @type {?User}\n     */\n    this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link Guild}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.members.resolve(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, Channel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n    return this._channels;\n  }\n\n  /**\n   * Options used to check for a mention.\n   * @typedef {Object} MessageMentionsHasOptions\n   * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item\n   * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member\n   * @property {boolean} [ignoreEveryone=false] Whether to ignore everyone/here mentions\n   */\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and `@everyone`/`@here` mentions.\n   * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for\n   * @param {MessageMentionsHasOptions} [options] The options for the check\n   * @returns {boolean}\n   */\n  has(data, { ignoreDirect = false, ignoreRoles = false, ignoreEveryone = false } = {}) {\n    if (!ignoreEveryone && this.everyone) return true;\n    const GuildMember = require('./GuildMember');\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id =\n        this.guild?.roles.resolveId(data) ?? this.client.channels.resolveId(data) ?? this.client.users.resolveId(data);\n\n      return typeof id === 'string' && (this.users.has(id) || this.channels.has(id) || this.roles.has(id));\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true,\n    });\n  }\n}\n\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\n\nmodule.exports = MessageMentions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}