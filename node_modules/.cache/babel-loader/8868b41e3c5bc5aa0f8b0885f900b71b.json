{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst GuildChannel = require('./GuildChannel');\n\nconst Webhook = require('./Webhook');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst MessageManager = require('../managers/MessageManager');\n\nconst ThreadManager = require('../managers/ThreadManager');\n\nconst DataResolver = require('../util/DataResolver');\n/**\n * Represents a text-based guild channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\n\n\nclass BaseGuildTextChannel extends GuildChannel {\n  /**\n   * @param {Guild} guild The guild the text channel is part of\n   * @param {APIChannel} data The data for the text channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   */\n  constructor(guild, data, client) {\n    super(guild, data, client, false);\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    /**\n     * A manager of the threads belonging to this channel\n     * @type {ThreadManager}\n     */\n\n    this.threads = new ThreadManager(this);\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n\n    this.nsfw = Boolean(data.nsfw);\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('topic' in data) {\n      /**\n       * The topic of the text channel\n       * @type {?string}\n       */\n      this.topic = data.topic;\n    }\n\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in the channel, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    }\n\n    if ('default_auto_archive_duration' in data) {\n      /**\n       * The default auto archive duration for newly created threads in this channel\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.defaultAutoArchiveDuration = data.default_auto_archive_duration;\n    }\n\n    if ('messages' in data) {\n      for (const message of data.messages) this.messages._add(message);\n    }\n  }\n  /**\n   * Sets the default auto archive duration for all newly created threads in this channel.\n   * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration\n   * @param {string} [reason] Reason for changing the channel's default auto archive duration\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {\n    return this.edit({\n      defaultAutoArchiveDuration\n    }, reason);\n  }\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} nsfw Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setNSFW(nsfw, reason) {\n    return this.edit({\n      nsfw\n    }, reason);\n  }\n  /**\n   * Sets the type of this channel (only conversion between text and news is supported)\n   * @param {string} type The new channel type\n   * @param {string} [reason] Reason for changing the channel's type\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  setType(type, reason) {\n    return this.edit({\n      type\n    }, reason);\n  }\n  /**\n   * Fetches all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n\n\n  async fetchWebhooks() {\n    const data = await this.client.api.channels[this.id].webhooks.get();\n    const hooks = new Collection();\n\n    for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n\n    return hooks;\n  }\n  /**\n   * Options used to create a {@link Webhook} for {@link TextChannel} and {@link NewsChannel}.\n   * @typedef {Object} ChannelWebhookCreateOptions\n   * @property {BufferResolvable|Base64Resolvable} [avatar] Avatar for the webhook\n   * @property {string} [reason] Reason for creating the webhook\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {string} name The name of the webhook\n   * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * channel.createWebhook('Snek', {\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async createWebhook(name) {\n    let {\n      avatar,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n\n    const data = await this.client.api.channels[this.id].webhooks.post({\n      data: {\n        name,\n        avatar\n      },\n      reason\n    });\n    return new Webhook(this.client, data);\n  }\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n\n\n  setTopic(topic, reason) {\n    return this.edit({\n      topic\n    }, reason);\n  }\n  /**\n   * Options used to create an invite to a guild channel.\n   * @typedef {Object} CreateInviteOptions\n   * @property {boolean} [temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @property {number} [maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @property {number} [maxUses=0] Maximum number of uses\n   * @property {boolean} [unique=false] Create a unique invite, or use an existing one with similar settings\n   * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,\n   * required if `targetType` is 1, the user must be streaming in the channel\n   * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,\n   * required if `targetType` is 2, the application must have the `EMBEDDED` flag\n   * @property {TargetType} [targetType] The type of the target for this voice channel invite\n   * @property {string} [reason] The reason for creating the invite\n   */\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {CreateInviteOptions} [options={}] The options for creating the invite\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  createInvite(options) {\n    return this.guild.invites.create(this.id, options);\n  }\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @param {boolean} [cache=true] Whether or not to cache the fetched invites\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n\n\n  fetchInvites() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.guild.invites.fetch({\n      channelId: this.id,\n      cache\n    });\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendTyping() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentCollector() {}\n\n  awaitMessageComponent() {}\n\n  bulkDelete() {}\n\n}\n\nTextBasedChannel.applyToClass(BaseGuildTextChannel, true);\nmodule.exports = BaseGuildTextChannel;","map":{"version":3,"names":["Collection","require","GuildChannel","Webhook","TextBasedChannel","MessageManager","ThreadManager","DataResolver","BaseGuildTextChannel","constructor","guild","data","client","messages","threads","nsfw","Boolean","_patch","topic","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","Date","getTime","defaultAutoArchiveDuration","default_auto_archive_duration","message","_add","setDefaultAutoArchiveDuration","reason","edit","setNSFW","setType","type","fetchWebhooks","api","channels","id","webhooks","get","hooks","hook","set","createWebhook","name","avatar","startsWith","resolveImage","post","setTopic","createInvite","options","invites","create","fetchInvites","cache","fetch","channelId","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","applyToClass","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/BaseGuildTextChannel.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst GuildChannel = require('./GuildChannel');\nconst Webhook = require('./Webhook');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\nconst ThreadManager = require('../managers/ThreadManager');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Represents a text-based guild channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\nclass BaseGuildTextChannel extends GuildChannel {\n  /**\n   * @param {Guild} guild The guild the text channel is part of\n   * @param {APIChannel} data The data for the text channel\n   * @param {Client} [client] A safety parameter for the client that instantiated this\n   */\n  constructor(guild, data, client) {\n    super(guild, data, client, false);\n\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * A manager of the threads belonging to this channel\n     * @type {ThreadManager}\n     */\n    this.threads = new ThreadManager(this);\n\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n    this.nsfw = Boolean(data.nsfw);\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('topic' in data) {\n      /**\n       * The topic of the text channel\n       * @type {?string}\n       */\n      this.topic = data.topic;\n    }\n\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in the channel, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    }\n\n    if ('default_auto_archive_duration' in data) {\n      /**\n       * The default auto archive duration for newly created threads in this channel\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.defaultAutoArchiveDuration = data.default_auto_archive_duration;\n    }\n\n    if ('messages' in data) {\n      for (const message of data.messages) this.messages._add(message);\n    }\n  }\n\n  /**\n   * Sets the default auto archive duration for all newly created threads in this channel.\n   * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration\n   * @param {string} [reason] Reason for changing the channel's default auto archive duration\n   * @returns {Promise<TextChannel>}\n   */\n  setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {\n    return this.edit({ defaultAutoArchiveDuration }, reason);\n  }\n\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} nsfw Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<TextChannel>}\n   */\n  setNSFW(nsfw, reason) {\n    return this.edit({ nsfw }, reason);\n  }\n\n  /**\n   * Sets the type of this channel (only conversion between text and news is supported)\n   * @param {string} type The new channel type\n   * @param {string} [reason] Reason for changing the channel's type\n   * @returns {Promise<GuildChannel>}\n   */\n  setType(type, reason) {\n    return this.edit({ type }, reason);\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks() {\n    const data = await this.client.api.channels[this.id].webhooks.get();\n    const hooks = new Collection();\n    for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n    return hooks;\n  }\n\n  /**\n   * Options used to create a {@link Webhook} for {@link TextChannel} and {@link NewsChannel}.\n   * @typedef {Object} ChannelWebhookCreateOptions\n   * @property {BufferResolvable|Base64Resolvable} [avatar] Avatar for the webhook\n   * @property {string} [reason] Reason for creating the webhook\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {string} name The name of the webhook\n   * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * channel.createWebhook('Snek', {\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook(name, { avatar, reason } = {}) {\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.api.channels[this.id].webhooks.post({\n      data: {\n        name,\n        avatar,\n      },\n      reason,\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({ topic }, reason);\n  }\n\n  /**\n   * Options used to create an invite to a guild channel.\n   * @typedef {Object} CreateInviteOptions\n   * @property {boolean} [temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @property {number} [maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @property {number} [maxUses=0] Maximum number of uses\n   * @property {boolean} [unique=false] Create a unique invite, or use an existing one with similar settings\n   * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,\n   * required if `targetType` is 1, the user must be streaming in the channel\n   * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,\n   * required if `targetType` is 2, the application must have the `EMBEDDED` flag\n   * @property {TargetType} [targetType] The type of the target for this voice channel invite\n   * @property {string} [reason] The reason for creating the invite\n   */\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {CreateInviteOptions} [options={}] The options for creating the invite\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite(options) {\n    return this.guild.invites.create(this.id, options);\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @param {boolean} [cache=true] Whether or not to cache the fetched invites\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  fetchInvites(cache = true) {\n    return this.guild.invites.fetch({ channelId: this.id, cache });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(BaseGuildTextChannel, true);\n\nmodule.exports = BaseGuildTextChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}