{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst WebSocket = require('../../WebSocket');\n\nconst {\n  Status,\n  Events,\n  ShardEvents,\n  Opcodes,\n  WSEvents\n} = require('../../util/Constants');\n\nconst Intents = require('../../util/Intents');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nlet zlib;\n\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\n/**\n * Represents a Shard's WebSocket connection\n */\n\n\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The shard's id\n     * @type {number}\n     */\n\n    this.id = id;\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n\n    this.sequence = -1;\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n\n    this.closeSequence = 0;\n    /**\n     * The current session id of the shard\n     * @type {?string}\n     * @private\n     */\n\n    this.sessionId = null;\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n\n    this.ping = -1;\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n\n    this.lastPingTimestamp = -1;\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n\n    this.lastHeartbeatAcked = true;\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connection', {\n      value: null,\n      writable: true\n    });\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n\n    Object.defineProperty(this, 'inflate', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'helloTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n\n    Object.defineProperty(this, 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n\n    Object.defineProperty(this, 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n  }\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n\n\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n\n\n  connect() {\n    const {\n      gateway,\n      client\n    } = this.manager;\n\n    if (this.connection?.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup(); // eslint-disable-next-line prefer-promise-reject-errors\n\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection?.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({\n          emit: false\n        });\n      }\n\n      const wsQuery = {\n        v: client.options.ws.version\n      };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : ''\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(`[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`);\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n      this.connectedAt = Date.now();\n      const ws = this.connection = WebSocket.create(gateway, wsQuery);\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n\n\n  onOpen() {\n    this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n\n\n  onMessage(_ref) {\n    let {\n      data\n    } = _ref;\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n    if (zlib) {\n      const l = data.length;\n      const flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n\n    let packet;\n\n    try {\n      packet = WebSocket.unpack(raw);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n\n    this.manager.client.emit(Events.RAW, packet, this.id);\n    if (packet.op === Opcodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    this.onPacket(packet);\n  }\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n\n\n  onError(event) {\n    const error = event?.error ?? event;\n    if (!error) return;\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardId The shard that encountered this error\n     */\n\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n\n\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // If we still have a connection object, clean up its listeners\n\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.DISCONNECTED;\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n\n    this.emit(ShardEvents.CLOSE, event);\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n\n\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n        this.sessionId = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionId}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n\n      case WSEvents.RESUMED:\n        {\n          /**\n           * Emitted when the shard resumes successfully\n           * @event WebSocketShard#resumed\n           */\n          this.emit(ShardEvents.RESUMED);\n          this.status = Status.READY;\n          const replayed = packet.s - this.closeSequence;\n          this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ResumeHeartbeat');\n          break;\n        }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case Opcodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n\n      case Opcodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({\n          closeCode: 4000\n        });\n        break;\n\n      case Opcodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`); // If we can resume the session, do so immediately\n\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        } // Reset the sequence\n\n\n        this.sequence = -1; // Reset the session id as it's invalid\n\n        this.sessionId = null; // Set the status to reconnecting\n\n        this.status = Status.RECONNECTING; // Finally, emit the INVALID_SESSION event\n\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n\n      case Opcodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n\n      case Opcodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n\n      default:\n        this.manager.handlePacket(packet, this);\n\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n\n    }\n  }\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n\n\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    } // Step 1. If we don't have any other guilds pending, we are ready\n\n\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    }\n\n    const hasGuildsIntent = new Intents(this.manager.client.options.intents).has(Intents.FLAGS.GUILDS); // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n\n    this.readyTimeout = setTimeout(() => {\n      this.debug(`Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` + `${hasGuildsIntent ? ' in 15 seconds' : ''}.\\n   Unavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.READY;\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, hasGuildsIntent ? 15000 : 0).unref();\n  }\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n\n\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n\n      return;\n    }\n\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n    }, 20000).unref();\n  }\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n\n\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      return;\n    }\n\n    this.debug(`Setting a heartbeat interval for ${time}ms.`); // Sanity checks\n\n    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();\n  }\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n\n\n  sendHeartbeat() {\n    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HeartbeatTimer';\n    let ignoreHeartbeatAck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status);\n\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`);\n      this.destroy({\n        closeCode: 4009,\n        reset: true\n      });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: Opcodes.HEARTBEAT,\n      d: this.sequence\n    }, true);\n  }\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n\n\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n\n\n  identify() {\n    return this.sessionId ? this.identifyResume() : this.identifyNew();\n  }\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n\n\n  identifyNew() {\n    const {\n      client\n    } = this.manager;\n\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING; // Clone the identify payload and assign the token and shard info\n\n    const d = { ...client.options.ws,\n      intents: Intents.resolve(client.options.intents),\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)]\n    };\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);\n    this.send({\n      op: Opcodes.IDENTIFY,\n      d\n    }, true);\n  }\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n\n\n  identifyResume() {\n    if (!this.sessionId) {\n      this.debug('[RESUME] No session id was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n    this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionId,\n      seq: this.closeSequence\n    };\n    this.send({\n      op: Opcodes.RESUME,\n      d\n    }, true);\n  }\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n\n\n  send(data) {\n    let important = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n\n\n  _send(data) {\n    if (this.connection?.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({\n        closeCode: 4000\n      });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n\n\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time).unref();\n    }\n\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n\n      this._send(item);\n\n      this.ratelimit.remaining--;\n    }\n  }\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n\n\n  destroy() {\n    let {\n      closeCode = 1000,\n      reset = false,\n      emit = true,\n      log = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    } // Step 0: Remove all timers\n\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1); // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`); // Remove listeners from the connection\n\n        this._cleanupConnection(); // Attempt to close the connection just in case\n\n\n        try {\n          this.connection.close(closeCode);\n        } catch {// No-op\n        } // Emit the destroyed event if needed\n\n\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    } // Step 2: Null the connection object\n\n\n    this.connection = null; // Step 3: Set the shard status to DISCONNECTED\n\n    this.status = Status.DISCONNECTED; // Step 4: Cache the old sequence (use to attempt a resume)\n\n    if (this.sequence !== -1) this.closeSequence = this.sequence; // Step 5: Reset the sequence and session id if requested\n\n    if (reset) {\n      this.sequence = -1;\n      this.sessionId = null;\n    } // Step 6: reset the ratelimit data\n\n\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n\n    if (this.ratelimit.timer) {\n      clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n\n\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n\n\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n\n}\n\nmodule.exports = WebSocketShard;","map":{"version":3,"names":["EventEmitter","require","WebSocket","Status","Events","ShardEvents","Opcodes","WSEvents","Intents","STATUS_KEYS","Object","keys","CONNECTION_STATE","zlib","WebSocketShard","constructor","manager","id","status","IDLE","sequence","closeSequence","sessionId","ping","lastPingTimestamp","lastHeartbeatAcked","defineProperty","value","queue","total","remaining","time","timer","writable","debug","message","connect","gateway","client","connection","readyState","OPEN","READY","Promise","resolve","reject","cleanup","removeListener","CLOSE","onClose","onReady","RESUMED","onResumed","INVALID_SESSION","onInvalidOrDestroyed","DESTROYED","event","once","identify","destroy","emit","wsQuery","v","options","ws","version","inflate","Inflate","chunkSize","flush","Z_SYNC_FLUSH","to","encoding","compress","DISCONNECTED","RECONNECTING","CONNECTING","setHelloTimeout","connectedAt","Date","now","create","onopen","onOpen","bind","onmessage","onMessage","onerror","onError","onclose","NEARLY","data","raw","ArrayBuffer","Uint8Array","l","length","push","result","packet","unpack","err","SHARD_ERROR","RAW","op","DISPATCH","t","d","onPacket","error","code","wasClean","reason","setHeartbeatTimer","_cleanupConnection","session_id","expectedGuilds","Set","guilds","map","WAITING_FOR_GUILDS","sendHeartbeat","replayed","s","HELLO","heartbeat_interval","RECONNECT","closeCode","identifyResume","HEARTBEAT_ACK","ackHeartbeat","HEARTBEAT","handlePacket","GUILD_CREATE","delete","checkReady","readyTimeout","clearTimeout","size","ALL_READY","hasGuildsIntent","intents","has","FLAGS","GUILDS","setTimeout","unref","helloTimeout","reset","heartbeatInterval","clearInterval","setInterval","tag","ignoreHeartbeatAck","IDENTIFYING","RESUMING","includes","send","latency","identifyNew","token","shard","Number","shardCount","IDENTIFY","seq","RESUME","important","ratelimit","processQueue","_send","JSON","stringify","pack","item","shift","log","close","_emitDestroyed","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/client/websocket/WebSocketShard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocket = require('../../WebSocket');\nconst { Status, Events, ShardEvents, Opcodes, WSEvents } = require('../../util/Constants');\nconst Intents = require('../../util/Intents');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\n\nlet zlib;\n\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\n/**\n * Represents a Shard's WebSocket connection\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session id of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionId = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null,\n      },\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', { value: null, writable: true });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', { value: null, writable: true });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });\n\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const { gateway, client } = this.manager;\n\n    if (this.connection?.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection?.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({ emit: false });\n      }\n\n      const wsQuery = { v: client.options.ws.version };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : '',\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(\n        `[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`,\n      );\n\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n\n      this.connectedAt = Date.now();\n\n      const ws = (this.connection = WebSocket.create(gateway, wsQuery));\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage({ data }) {\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush =\n        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n    this.manager.client.emit(Events.RAW, packet, this.id);\n    if (packet.op === Opcodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event?.error ?? event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardId The shard that encountered this error\n     */\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n\n    this.status = Status.DISCONNECTED;\n\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(ShardEvents.CLOSE, event);\n  }\n\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n\n        this.sessionId = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionId}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case WSEvents.RESUMED: {\n        /**\n         * Emitted when the shard resumes successfully\n         * @event WebSocketShard#resumed\n         */\n        this.emit(ShardEvents.RESUMED);\n\n        this.status = Status.READY;\n        const replayed = packet.s - this.closeSequence;\n        this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ResumeHeartbeat');\n        break;\n      }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case Opcodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case Opcodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({ closeCode: 4000 });\n        break;\n      case Opcodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session id as it's invalid\n        this.sessionId = null;\n        // Set the status to reconnecting\n        this.status = Status.RECONNECTING;\n        // Finally, emit the INVALID_SESSION event\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n      case Opcodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n      case Opcodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    }\n    const hasGuildsIntent = new Intents(this.manager.client.options.intents).has(Intents.FLAGS.GUILDS);\n    // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n    this.readyTimeout = setTimeout(\n      () => {\n        this.debug(\n          `Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` +\n            `${hasGuildsIntent ? ' in 15 seconds' : ''}.\\n   Unavailable guild count: ${this.expectedGuilds.size}`,\n        );\n\n        this.readyTimeout = null;\n\n        this.status = Status.READY;\n\n        this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n      },\n      hasGuildsIntent ? 15000 : 0,\n    ).unref();\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({ reset: true, closeCode: 4009 });\n    }, 20000).unref();\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat(\n    tag = 'HeartbeatTimer',\n    ignoreHeartbeatAck = [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status),\n  ) {\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(\n        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,\n      );\n\n      this.destroy({ closeCode: 4009, reset: true });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({ op: Opcodes.HEARTBEAT, d: this.sequence }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionId ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const { client } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      intents: Intents.resolve(client.options.intents),\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)],\n    };\n\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);\n    this.send({ op: Opcodes.IDENTIFY, d }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionId) {\n      this.debug('[RESUME] No session id was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n\n    this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);\n\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionId,\n      seq: this.closeSequence,\n    };\n\n    this.send({ op: Opcodes.RESUME, d }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data, important = false) {\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (this.connection?.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({ closeCode: 4000 });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time).unref();\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy({ closeCode = 1000, reset = false, emit = true, log = true } = {}) {\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch {\n          // No-op\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to DISCONNECTED\n    this.status = Status.DISCONNECTED;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence and session id if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionId = null;\n    }\n\n    // Step 6: reset the ratelimit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n}\n\nmodule.exports = WebSocketShard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}