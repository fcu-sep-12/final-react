{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exact = exports.partial = void 0;\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst test_1 = require(\"../test\");\n\nconst base_predicate_1 = require(\"../predicates/base-predicate\");\n/**\nTest if the `object` matches the `shape` partially.\n\n@hidden\n\n@param object - Object to test against the provided shape.\n@param shape - Shape to test the object against.\n@param parent - Name of the parent property.\n*/\n\n\nfunction partial(object, shape, parent) {\n  try {\n    for (const key of Object.keys(shape)) {\n      const label = parent ? `${parent}.${key}` : key;\n\n      if (base_predicate_1.isPredicate(shape[key])) {\n        test_1.default(object[key], label, shape[key]);\n      } else if (is_1.default.plainObject(shape[key])) {\n        const result = partial(object[key], shape[key], label);\n\n        if (result !== true) {\n          return result;\n        }\n      }\n    }\n\n    return true;\n  } catch (error) {\n    return error.message;\n  }\n}\n\nexports.partial = partial;\n/**\nTest if the `object` matches the `shape` exactly.\n\n@hidden\n\n@param object - Object to test against the provided shape.\n@param shape - Shape to test the object against.\n@param parent - Name of the parent property.\n*/\n\nfunction exact(object, shape, parent, isArray) {\n  try {\n    const objectKeys = new Set(Object.keys(object));\n\n    for (const key of Object.keys(shape)) {\n      objectKeys.delete(key);\n      const label = parent ? `${parent}.${key}` : key;\n\n      if (base_predicate_1.isPredicate(shape[key])) {\n        test_1.default(object[key], label, shape[key]);\n      } else if (is_1.default.plainObject(shape[key])) {\n        if (!Object.prototype.hasOwnProperty.call(object, key)) {\n          return `Expected \\`${label}\\` to exist`;\n        }\n\n        const result = exact(object[key], shape[key], label);\n\n        if (result !== true) {\n          return result;\n        }\n      }\n    }\n\n    if (objectKeys.size > 0) {\n      const firstKey = [...objectKeys.keys()][0];\n      const label = parent ? `${parent}.${firstKey}` : firstKey;\n      return `Did not expect ${isArray ? 'element' : 'property'} \\`${label}\\` to exist, got \\`${object[firstKey]}\\``;\n    }\n\n    return true;\n  } catch (error) {\n    return error.message;\n  }\n}\n\nexports.exact = exact;","map":{"version":3,"names":["Object","defineProperty","exports","value","exact","partial","is_1","require","test_1","base_predicate_1","object","shape","parent","key","keys","label","isPredicate","default","plainObject","result","error","message","isArray","objectKeys","Set","delete","prototype","hasOwnProperty","call","size","firstKey"],"sources":["C:/Users/ROUSER6/node_modules/ow/dist/utils/match-shape.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.exact = exports.partial = void 0;\nconst is_1 = require(\"@sindresorhus/is\");\nconst test_1 = require(\"../test\");\nconst base_predicate_1 = require(\"../predicates/base-predicate\");\n/**\nTest if the `object` matches the `shape` partially.\n\n@hidden\n\n@param object - Object to test against the provided shape.\n@param shape - Shape to test the object against.\n@param parent - Name of the parent property.\n*/\nfunction partial(object, shape, parent) {\n    try {\n        for (const key of Object.keys(shape)) {\n            const label = parent ? `${parent}.${key}` : key;\n            if (base_predicate_1.isPredicate(shape[key])) {\n                test_1.default(object[key], label, shape[key]);\n            }\n            else if (is_1.default.plainObject(shape[key])) {\n                const result = partial(object[key], shape[key], label);\n                if (result !== true) {\n                    return result;\n                }\n            }\n        }\n        return true;\n    }\n    catch (error) {\n        return error.message;\n    }\n}\nexports.partial = partial;\n/**\nTest if the `object` matches the `shape` exactly.\n\n@hidden\n\n@param object - Object to test against the provided shape.\n@param shape - Shape to test the object against.\n@param parent - Name of the parent property.\n*/\nfunction exact(object, shape, parent, isArray) {\n    try {\n        const objectKeys = new Set(Object.keys(object));\n        for (const key of Object.keys(shape)) {\n            objectKeys.delete(key);\n            const label = parent ? `${parent}.${key}` : key;\n            if (base_predicate_1.isPredicate(shape[key])) {\n                test_1.default(object[key], label, shape[key]);\n            }\n            else if (is_1.default.plainObject(shape[key])) {\n                if (!Object.prototype.hasOwnProperty.call(object, key)) {\n                    return `Expected \\`${label}\\` to exist`;\n                }\n                const result = exact(object[key], shape[key], label);\n                if (result !== true) {\n                    return result;\n                }\n            }\n        }\n        if (objectKeys.size > 0) {\n            const firstKey = [...objectKeys.keys()][0];\n            const label = parent ? `${parent}.${firstKey}` : firstKey;\n            return `Did not expect ${isArray ? 'element' : 'property'} \\`${label}\\` to exist, got \\`${object[firstKey]}\\``;\n        }\n        return true;\n    }\n    catch (error) {\n        return error.message;\n    }\n}\nexports.exact = exact;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}