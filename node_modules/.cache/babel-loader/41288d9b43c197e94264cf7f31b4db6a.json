{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Predicate = exports.validatorSymbol = void 0;\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst argument_error_1 = require(\"../argument-error\");\n\nconst not_1 = require(\"../operators/not\");\n\nconst base_predicate_1 = require(\"./base-predicate\");\n\nconst generate_argument_error_message_1 = require(\"../utils/generate-argument-error-message\");\n/**\n@hidden\n*/\n\n\nexports.validatorSymbol = Symbol('validators');\n/**\n@hidden\n*/\n\nclass Predicate {\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Object.defineProperty(this, \"type\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: type\n    });\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: options\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        validators: []\n      }\n    });\n    this.context = { ...this.context,\n      ...this.options\n    };\n    const typeString = this.type.charAt(0).toLowerCase() + this.type.slice(1);\n    this.addValidator({\n      message: (value, label) => {\n        // We do not include type in this label as we do for other messages, because it would be redundant.\n        const label_ = label === null || label === void 0 ? void 0 : label.slice(this.type.length + 1); // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n        return `Expected ${label_ || 'argument'} to be of type \\`${this.type}\\` but received type \\`${is_1.default(value)}\\``;\n      },\n      validator: value => is_1.default[typeString](value)\n    });\n  }\n  /**\n  @hidden\n  */\n\n\n  [base_predicate_1.testSymbol](value, main, label, idLabel) {\n    // Create a map of labels -> received errors.\n    const errors = new Map();\n\n    for (const {\n      validator,\n      message\n    } of this.context.validators) {\n      if (this.options.optional === true && value === undefined) {\n        continue;\n      }\n\n      let result;\n\n      try {\n        result = validator(value);\n      } catch (error) {\n        // Any errors caught means validators couldn't process the input.\n        result = error;\n      }\n\n      if (result === true) {\n        continue;\n      }\n\n      const label2 = is_1.default.function_(label) ? label() : label;\n      const labelWithTick = label2 && idLabel ? `\\`${label2}\\`` : label2;\n      const label_ = labelWithTick ? `${this.type} ${labelWithTick}` : this.type;\n      const mapKey = label2 || this.type; // Get the current errors encountered for this label.\n\n      const currentErrors = errors.get(mapKey); // Pre-generate the error message that will be reported to the user.\n\n      const errorMessage = message(value, label_, result); // If we already have any errors for this label.\n\n      if (currentErrors) {\n        // If we don't already have this error logged, add it.\n        currentErrors.add(errorMessage);\n      } else {\n        // Set this label and error in the full map.\n        errors.set(mapKey, new Set([errorMessage]));\n      }\n    } // If we have any errors to report, throw.\n\n\n    if (errors.size > 0) {\n      // Generate the `error.message` property.\n      const message = generate_argument_error_message_1.generateArgumentErrorMessage(errors);\n      throw new argument_error_1.ArgumentError(message, main, errors);\n    }\n  }\n  /**\n  @hidden\n  */\n\n\n  get [exports.validatorSymbol]() {\n    return this.context.validators;\n  }\n  /**\n  Invert the following validators.\n  */\n\n\n  get not() {\n    return not_1.not(this);\n  }\n  /**\n  Test if the value matches a custom validation function. The validation function should return an object containing a `validator` and `message`. If the `validator` is `false`, the validation fails and the `message` will be used as error message. If the `message` is a function, the function is invoked with the `label` as argument to let you further customize the error message.\n   @param customValidator - Custom validation function.\n  */\n\n\n  validate(customValidator) {\n    return this.addValidator({\n      message: (_, label, error) => typeof error === 'string' ? `(${label}) ${error}` : error(label),\n      validator: value => {\n        const {\n          message,\n          validator\n        } = customValidator(value);\n\n        if (validator) {\n          return true;\n        }\n\n        return message;\n      }\n    });\n  }\n  /**\n  Test if the value matches a custom validation function. The validation function should return `true` if the value passes the function. If the function either returns `false` or a string, the function fails and the string will be used as error message.\n   @param validator - Validation function.\n  */\n\n\n  is(validator) {\n    return this.addValidator({\n      message: (value, label, error) => error ? `(${label}) ${error}` : `Expected ${label} \\`${value}\\` to pass custom validation function`,\n      validator\n    });\n  }\n  /**\n  Provide a new error message to be thrown when the validation fails.\n   @param newMessage - Either a string containing the new message or a function returning the new message.\n   @example\n  ```\n  ow('ðŸŒˆ', 'unicorn', ow.string.equals('ðŸ¦„').message('Expected unicorn, got rainbow'));\n  //=> ArgumentError: Expected unicorn, got rainbow\n  ```\n   @example\n  ```\n  ow('ðŸŒˆ', ow.string.minLength(5).message((value, label) => `Expected ${label}, to have a minimum length of 5, got \\`${value}\\``));\n  //=> ArgumentError: Expected string, to be have a minimum length of 5, got `ðŸŒˆ`\n  ```\n  */\n\n\n  message(newMessage) {\n    const {\n      validators\n    } = this.context;\n\n    validators[validators.length - 1].message = (value, label) => {\n      if (typeof newMessage === 'function') {\n        return newMessage(value, label);\n      }\n\n      return newMessage;\n    };\n\n    return this;\n  }\n  /**\n  Register a new validator.\n   @param validator - Validator to register.\n  */\n\n\n  addValidator(validator) {\n    this.context.validators.push(validator);\n    return this;\n  }\n\n}\n\nexports.Predicate = Predicate;","map":{"version":3,"names":["Object","defineProperty","exports","value","Predicate","validatorSymbol","is_1","require","argument_error_1","not_1","base_predicate_1","generate_argument_error_message_1","Symbol","constructor","type","options","enumerable","configurable","writable","validators","context","typeString","charAt","toLowerCase","slice","addValidator","message","label","label_","length","default","validator","testSymbol","main","idLabel","errors","Map","optional","undefined","result","error","label2","function_","labelWithTick","mapKey","currentErrors","get","errorMessage","add","set","Set","size","generateArgumentErrorMessage","ArgumentError","not","validate","customValidator","_","is","newMessage","push"],"sources":["C:/Users/ROUSER6/node_modules/ow/dist/predicates/predicate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Predicate = exports.validatorSymbol = void 0;\nconst is_1 = require(\"@sindresorhus/is\");\nconst argument_error_1 = require(\"../argument-error\");\nconst not_1 = require(\"../operators/not\");\nconst base_predicate_1 = require(\"./base-predicate\");\nconst generate_argument_error_message_1 = require(\"../utils/generate-argument-error-message\");\n/**\n@hidden\n*/\nexports.validatorSymbol = Symbol('validators');\n/**\n@hidden\n*/\nclass Predicate {\n    constructor(type, options = {}) {\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: type\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"context\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                validators: []\n            }\n        });\n        this.context = {\n            ...this.context,\n            ...this.options\n        };\n        const typeString = this.type.charAt(0).toLowerCase() + this.type.slice(1);\n        this.addValidator({\n            message: (value, label) => {\n                // We do not include type in this label as we do for other messages, because it would be redundant.\n                const label_ = label === null || label === void 0 ? void 0 : label.slice(this.type.length + 1);\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                return `Expected ${label_ || 'argument'} to be of type \\`${this.type}\\` but received type \\`${is_1.default(value)}\\``;\n            },\n            validator: value => is_1.default[typeString](value)\n        });\n    }\n    /**\n    @hidden\n    */\n    [base_predicate_1.testSymbol](value, main, label, idLabel) {\n        // Create a map of labels -> received errors.\n        const errors = new Map();\n        for (const { validator, message } of this.context.validators) {\n            if (this.options.optional === true && value === undefined) {\n                continue;\n            }\n            let result;\n            try {\n                result = validator(value);\n            }\n            catch (error) {\n                // Any errors caught means validators couldn't process the input.\n                result = error;\n            }\n            if (result === true) {\n                continue;\n            }\n            const label2 = is_1.default.function_(label) ? label() : label;\n            const labelWithTick = (label2 && idLabel) ? `\\`${label2}\\`` : label2;\n            const label_ = labelWithTick ?\n                `${this.type} ${labelWithTick}` :\n                this.type;\n            const mapKey = label2 || this.type;\n            // Get the current errors encountered for this label.\n            const currentErrors = errors.get(mapKey);\n            // Pre-generate the error message that will be reported to the user.\n            const errorMessage = message(value, label_, result);\n            // If we already have any errors for this label.\n            if (currentErrors) {\n                // If we don't already have this error logged, add it.\n                currentErrors.add(errorMessage);\n            }\n            else {\n                // Set this label and error in the full map.\n                errors.set(mapKey, new Set([errorMessage]));\n            }\n        }\n        // If we have any errors to report, throw.\n        if (errors.size > 0) {\n            // Generate the `error.message` property.\n            const message = generate_argument_error_message_1.generateArgumentErrorMessage(errors);\n            throw new argument_error_1.ArgumentError(message, main, errors);\n        }\n    }\n    /**\n    @hidden\n    */\n    get [exports.validatorSymbol]() {\n        return this.context.validators;\n    }\n    /**\n    Invert the following validators.\n    */\n    get not() {\n        return not_1.not(this);\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return an object containing a `validator` and `message`. If the `validator` is `false`, the validation fails and the `message` will be used as error message. If the `message` is a function, the function is invoked with the `label` as argument to let you further customize the error message.\n\n    @param customValidator - Custom validation function.\n    */\n    validate(customValidator) {\n        return this.addValidator({\n            message: (_, label, error) => typeof error === 'string' ?\n                `(${label}) ${error}` :\n                error(label),\n            validator: value => {\n                const { message, validator } = customValidator(value);\n                if (validator) {\n                    return true;\n                }\n                return message;\n            }\n        });\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return `true` if the value passes the function. If the function either returns `false` or a string, the function fails and the string will be used as error message.\n\n    @param validator - Validation function.\n    */\n    is(validator) {\n        return this.addValidator({\n            message: (value, label, error) => (error ?\n                `(${label}) ${error}` :\n                `Expected ${label} \\`${value}\\` to pass custom validation function`),\n            validator\n        });\n    }\n    /**\n    Provide a new error message to be thrown when the validation fails.\n\n    @param newMessage - Either a string containing the new message or a function returning the new message.\n\n    @example\n    ```\n    ow('ðŸŒˆ', 'unicorn', ow.string.equals('ðŸ¦„').message('Expected unicorn, got rainbow'));\n    //=> ArgumentError: Expected unicorn, got rainbow\n    ```\n\n    @example\n    ```\n    ow('ðŸŒˆ', ow.string.minLength(5).message((value, label) => `Expected ${label}, to have a minimum length of 5, got \\`${value}\\``));\n    //=> ArgumentError: Expected string, to be have a minimum length of 5, got `ðŸŒˆ`\n    ```\n    */\n    message(newMessage) {\n        const { validators } = this.context;\n        validators[validators.length - 1].message = (value, label) => {\n            if (typeof newMessage === 'function') {\n                return newMessage(value, label);\n            }\n            return newMessage;\n        };\n        return this;\n    }\n    /**\n    Register a new validator.\n\n    @param validator - Validator to register.\n    */\n    addValidator(validator) {\n        this.context.validators.push(validator);\n        return this;\n    }\n}\nexports.Predicate = Predicate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}