{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Collector = require('./interfaces/Collector');\n\nconst {\n  Events\n} = require('../util/Constants');\n\nconst {\n  InteractionTypes,\n  MessageComponentTypes\n} = require('../util/Constants');\n/**\n * @typedef {CollectorOptions} InteractionCollectorOptions\n * @property {TextBasedChannels} [channel] The channel to listen to interactions from\n * @property {MessageComponentType} [componentType] The type of component to listen for\n * @property {Guild} [guild] The guild to listen to interactions from\n * @property {InteractionType} [interactionType] The type of interaction to listen for\n * @property {number} [max] The maximum total amount of interactions to collect\n * @property {number} [maxComponents] The maximum number of components to collect\n * @property {number} [maxUsers] The maximum number of users to interact\n * @property {Message|APIMessage} [message] The message to listen to interactions from\n */\n\n/**\n * Collects interactions.\n * Will automatically stop if the message ({@link Client#messageDelete messageDelete}),\n * channel ({@link Client#channelDelete channelDelete}), or guild ({@link Client#guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\n\n\nclass InteractionCollector extends Collector {\n  /**\n   * @param {Client} client The client on which to collect interactions\n   * @param {InteractionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  constructor(client) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(client, options);\n    /**\n     * The message from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n\n    this.messageId = options.message?.id ?? null;\n    /**\n     * The channel from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n\n    this.channelId = this.client.channels.resolveId(options.message?.channel) ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);\n    /**\n     * The guild from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n\n    this.guildId = this.client.guilds.resolveId(options.message?.guild) ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);\n    /**\n     * The the type of interaction to collect\n     * @type {?InteractionType}\n     */\n\n    this.interactionType = typeof options.interactionType === 'number' ? InteractionTypes[options.interactionType] : options.interactionType ?? null;\n    /**\n     * The the type of component to collect\n     * @type {?MessageComponentType}\n     */\n\n    this.componentType = typeof options.componentType === 'number' ? MessageComponentTypes[options.componentType] : options.componentType ?? null;\n    /**\n     * The users which have interacted to this collector\n     * @type {Collection<Snowflake, User>}\n     */\n\n    this.users = new Collection();\n    /**\n     * The total number of interactions collected\n     * @type {number}\n     */\n\n    this.total = 0;\n    this.empty = this.empty.bind(this);\n    this.client.incrementMaxListeners();\n\n    if (this.messageId) {\n      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);\n      this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n    }\n\n    if (this.channelId) {\n      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n      this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    }\n\n    if (this.guildId) {\n      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n      this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    }\n\n    this.client.on(Events.INTERACTION_CREATE, this.handleCollect);\n    this.once('end', () => {\n      this.client.removeListener(Events.INTERACTION_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n    this.on('collect', interaction => {\n      this.total++;\n      this.users.set(interaction.user.id, interaction.user);\n    });\n  }\n  /**\n   * Handles an incoming interaction for possible collection.\n   * @param {Interaction} interaction The interaction to possibly collect\n   * @returns {?Snowflake}\n   * @private\n   */\n\n\n  collect(interaction) {\n    /**\n     * Emitted whenever an interaction is collected.\n     * @event InteractionCollector#collect\n     * @param {Interaction} interaction The interaction that was collected\n     */\n    if (this.interactionType && interaction.type !== this.interactionType) return null;\n    if (this.componentType && interaction.componentType !== this.componentType) return null;\n    if (this.messageId && interaction.message?.id !== this.messageId) return null;\n    if (this.channelId && interaction.channelId !== this.channelId) return null;\n    if (this.guildId && interaction.guildId !== this.guildId) return null;\n    return interaction.id;\n  }\n  /**\n   * Handles an interaction for possible disposal.\n   * @param {Interaction} interaction The interaction that could be disposed of\n   * @returns {?Snowflake}\n   */\n\n\n  dispose(interaction) {\n    /**\n     * Emitted whenever an interaction is disposed of.\n     * @event InteractionCollector#dispose\n     * @param {Interaction} interaction The interaction that was disposed of\n     */\n    if (this.type && interaction.type !== this.type) return null;\n    if (this.componentType && interaction.componentType !== this.componentType) return null;\n    if (this.messageId && interaction.message?.id !== this.messageId) return null;\n    if (this.channelId && interaction.channelId !== this.channelId) return null;\n    if (this.guildId && interaction.guildId !== this.guildId) return null;\n    return interaction.id;\n  }\n  /**\n   * Empties this interaction collector.\n   */\n\n\n  empty() {\n    this.total = 0;\n    this.collected.clear();\n    this.users.clear();\n    this.checkEnd();\n  }\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get endReason() {\n    if (this.options.max && this.total >= this.options.max) return 'limit';\n    if (this.options.maxComponents && this.collected.size >= this.options.maxComponents) return 'componentLimit';\n    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n   * @private\n   * @param {Message} message The message that was deleted\n   * @returns {void}\n   */\n\n\n  _handleMessageDeletion(message) {\n    if (message.id === this.messageId) {\n      this.stop('messageDelete');\n    }\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channelId) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.guildId) {\n      this.stop('guildDelete');\n    }\n  }\n\n}\n\nmodule.exports = InteractionCollector;","map":{"version":3,"names":["Collection","require","Collector","Events","InteractionTypes","MessageComponentTypes","InteractionCollector","constructor","client","options","messageId","message","id","channelId","channels","resolveId","channel","channel_id","guildId","guilds","guild","guild_id","interactionType","componentType","users","total","empty","bind","incrementMaxListeners","_handleMessageDeletion","on","MESSAGE_DELETE","_handleChannelDeletion","CHANNEL_DELETE","_handleGuildDeletion","GUILD_DELETE","INTERACTION_CREATE","handleCollect","once","removeListener","decrementMaxListeners","interaction","set","user","collect","type","dispose","collected","clear","checkEnd","endReason","max","maxComponents","size","maxUsers","stop","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/InteractionCollector.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\nconst { InteractionTypes, MessageComponentTypes } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} InteractionCollectorOptions\n * @property {TextBasedChannels} [channel] The channel to listen to interactions from\n * @property {MessageComponentType} [componentType] The type of component to listen for\n * @property {Guild} [guild] The guild to listen to interactions from\n * @property {InteractionType} [interactionType] The type of interaction to listen for\n * @property {number} [max] The maximum total amount of interactions to collect\n * @property {number} [maxComponents] The maximum number of components to collect\n * @property {number} [maxUsers] The maximum number of users to interact\n * @property {Message|APIMessage} [message] The message to listen to interactions from\n */\n\n/**\n * Collects interactions.\n * Will automatically stop if the message ({@link Client#messageDelete messageDelete}),\n * channel ({@link Client#channelDelete channelDelete}), or guild ({@link Client#guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\nclass InteractionCollector extends Collector {\n  /**\n   * @param {Client} client The client on which to collect interactions\n   * @param {InteractionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  constructor(client, options = {}) {\n    super(client, options);\n\n    /**\n     * The message from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n    this.messageId = options.message?.id ?? null;\n\n    /**\n     * The channel from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n    this.channelId =\n      this.client.channels.resolveId(options.message?.channel) ??\n      options.message?.channel_id ??\n      this.client.channels.resolveId(options.channel);\n\n    /**\n     * The guild from which to collect interactions, if provided\n     * @type {?Snowflake}\n     */\n    this.guildId =\n      this.client.guilds.resolveId(options.message?.guild) ??\n      options.message?.guild_id ??\n      this.client.guilds.resolveId(options.channel?.guild) ??\n      this.client.guilds.resolveId(options.guild);\n\n    /**\n     * The the type of interaction to collect\n     * @type {?InteractionType}\n     */\n    this.interactionType =\n      typeof options.interactionType === 'number'\n        ? InteractionTypes[options.interactionType]\n        : options.interactionType ?? null;\n\n    /**\n     * The the type of component to collect\n     * @type {?MessageComponentType}\n     */\n    this.componentType =\n      typeof options.componentType === 'number'\n        ? MessageComponentTypes[options.componentType]\n        : options.componentType ?? null;\n\n    /**\n     * The users which have interacted to this collector\n     * @type {Collection<Snowflake, User>}\n     */\n    this.users = new Collection();\n\n    /**\n     * The total number of interactions collected\n     * @type {number}\n     */\n    this.total = 0;\n\n    this.empty = this.empty.bind(this);\n    this.client.incrementMaxListeners();\n\n    if (this.messageId) {\n      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);\n      this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n    }\n\n    if (this.channelId) {\n      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n      this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    }\n\n    if (this.guildId) {\n      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n      this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    }\n\n    this.client.on(Events.INTERACTION_CREATE, this.handleCollect);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.INTERACTION_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n\n    this.on('collect', interaction => {\n      this.total++;\n      this.users.set(interaction.user.id, interaction.user);\n    });\n  }\n\n  /**\n   * Handles an incoming interaction for possible collection.\n   * @param {Interaction} interaction The interaction to possibly collect\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(interaction) {\n    /**\n     * Emitted whenever an interaction is collected.\n     * @event InteractionCollector#collect\n     * @param {Interaction} interaction The interaction that was collected\n     */\n    if (this.interactionType && interaction.type !== this.interactionType) return null;\n    if (this.componentType && interaction.componentType !== this.componentType) return null;\n    if (this.messageId && interaction.message?.id !== this.messageId) return null;\n    if (this.channelId && interaction.channelId !== this.channelId) return null;\n    if (this.guildId && interaction.guildId !== this.guildId) return null;\n\n    return interaction.id;\n  }\n\n  /**\n   * Handles an interaction for possible disposal.\n   * @param {Interaction} interaction The interaction that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(interaction) {\n    /**\n     * Emitted whenever an interaction is disposed of.\n     * @event InteractionCollector#dispose\n     * @param {Interaction} interaction The interaction that was disposed of\n     */\n    if (this.type && interaction.type !== this.type) return null;\n    if (this.componentType && interaction.componentType !== this.componentType) return null;\n    if (this.messageId && interaction.message?.id !== this.messageId) return null;\n    if (this.channelId && interaction.channelId !== this.channelId) return null;\n    if (this.guildId && interaction.guildId !== this.guildId) return null;\n\n    return interaction.id;\n  }\n\n  /**\n   * Empties this interaction collector.\n   */\n  empty() {\n    this.total = 0;\n    this.collected.clear();\n    this.users.clear();\n    this.checkEnd();\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.total >= this.options.max) return 'limit';\n    if (this.options.maxComponents && this.collected.size >= this.options.maxComponents) return 'componentLimit';\n    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n   * @private\n   * @param {Message} message The message that was deleted\n   * @returns {void}\n   */\n  _handleMessageDeletion(message) {\n    if (message.id === this.messageId) {\n      this.stop('messageDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channelId) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.guildId) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = InteractionCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}