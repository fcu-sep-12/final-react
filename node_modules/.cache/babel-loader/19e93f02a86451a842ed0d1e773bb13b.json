{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst Guild = require('../structures/Guild');\n\nconst GuildChannel = require('../structures/GuildChannel');\n\nconst GuildEmoji = require('../structures/GuildEmoji');\n\nconst GuildMember = require('../structures/GuildMember');\n\nconst Invite = require('../structures/Invite');\n\nconst OAuth2Guild = require('../structures/OAuth2Guild');\n\nconst Role = require('../structures/Role');\n\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotificationLevels,\n  ExplicitContentFilterLevels\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Permissions = require('../util/Permissions');\n\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\n\nconst {\n  resolveColor\n} = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\n\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n\n\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n\n    return super.resolve(guild);\n  }\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveId(guild.guild.id);\n    }\n\n    return super.resolveId(guild);\n  }\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {DefaultMessageNotificationLevel|number} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {ExplicitContentFilterLevel} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {BufferResolvable|Base64Resolvable} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {VerificationLevel} [verificationLevel] The verification level for the guild\n   */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {GuildCreateOptions} [options] Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n\n\n  async create(name) {\n    let {\n      afkChannelId,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      roles = [],\n      systemChannelId,\n      systemChannelFlags,\n      verificationLevel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    icon = await DataResolver.resolveImage(icon);\n\n    if (typeof verificationLevel === 'string') {\n      verificationLevel = VerificationLevels[verificationLevel];\n    }\n\n    if (typeof defaultMessageNotifications === 'string') {\n      defaultMessageNotifications = DefaultMessageNotificationLevels[defaultMessageNotifications];\n    }\n\n    if (typeof explicitContentFilter === 'string') {\n      explicitContentFilter = ExplicitContentFilterLevels[explicitContentFilter];\n    }\n\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      if (!channel.permissionOverwrites) continue;\n\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow).toString();\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny).toString();\n      }\n\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions).toString();\n    }\n\n    if (systemChannelFlags) systemChannelFlags = SystemChannelFlags.resolve(systemChannelFlags);\n    const data = await this.client.api.guilds.post({\n      data: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags\n      }\n    });\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10000).unref();\n    });\n  }\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit=200] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n\n\n  async fetch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api.guilds(id).get({\n        query: {\n          with_counts: options.withCounts ?? true\n        }\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api.users('@me').guilds.get({\n      query: options\n    });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n\n}\n\nmodule.exports = GuildManager;","map":{"version":3,"names":["Collection","require","CachedManager","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","OAuth2Guild","Role","ChannelTypes","Events","VerificationLevels","DefaultMessageNotificationLevels","ExplicitContentFilterLevels","DataResolver","Permissions","SystemChannelFlags","resolveColor","cacheWarningEmitted","GuildManager","constructor","client","iterable","_cache","name","process","emitWarning","resolve","guild","resolveId","id","create","afkChannelId","afkTimeout","channels","defaultMessageNotifications","explicitContentFilter","icon","roles","systemChannelId","systemChannelFlags","verificationLevel","resolveImage","channel","type","toUpperCase","parent_id","parentId","permissionOverwrites","overwrite","allow","toString","deny","permission_overwrites","role","color","permissions","data","api","guilds","post","verification_level","default_message_notifications","explicit_content_filter","afk_channel_id","afk_timeout","system_channel_id","system_channel_flags","cache","has","get","Promise","handleGuild","clearTimeout","timeout","removeListener","GUILD_CREATE","decrementMaxListeners","incrementMaxListeners","on","setTimeout","_add","unref","fetch","options","force","existing","query","with_counts","withCounts","users","reduce","coll","set","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst Guild = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst GuildMember = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst Role = require('../structures/Role');\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotificationLevels,\n  ExplicitContentFilterLevels,\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\nconst { resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {DefaultMessageNotificationLevel|number} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {ExplicitContentFilterLevel} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {BufferResolvable|Base64Resolvable} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {VerificationLevel} [verificationLevel] The verification level for the guild\n   */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {GuildCreateOptions} [options] Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(\n    name,\n    {\n      afkChannelId,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      roles = [],\n      systemChannelId,\n      systemChannelFlags,\n      verificationLevel,\n    } = {},\n  ) {\n    icon = await DataResolver.resolveImage(icon);\n    if (typeof verificationLevel === 'string') {\n      verificationLevel = VerificationLevels[verificationLevel];\n    }\n    if (typeof defaultMessageNotifications === 'string') {\n      defaultMessageNotifications = DefaultMessageNotificationLevels[defaultMessageNotifications];\n    }\n    if (typeof explicitContentFilter === 'string') {\n      explicitContentFilter = ExplicitContentFilterLevels[explicitContentFilter];\n    }\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow).toString();\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny).toString();\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions).toString();\n    }\n    if (systemChannelFlags) systemChannelFlags = SystemChannelFlags.resolve(systemChannelFlags);\n\n    const data = await this.client.api.guilds.post({\n      data: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags,\n      },\n    });\n\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit=200] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api.guilds(id).get({ query: { with_counts: options.withCounts ?? true } });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api.users('@me').guilds.get({ query: options });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}