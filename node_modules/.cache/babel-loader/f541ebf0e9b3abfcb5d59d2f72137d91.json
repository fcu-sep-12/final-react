{"ast":null,"code":"'use strict';\n\nconst MessagePayload = require('./MessagePayload');\n\nconst {\n  Error\n} = require('../errors');\n\nconst {\n  WebhookTypes\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n/**\n * Represents a webhook.\n */\n\n\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n\n    Object.defineProperty(this, 'token', {\n      value: data.token ?? null,\n      writable: true,\n      configurable: true\n    });\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n\n    this.avatar = data.avatar;\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The type of the webhook\n     * @type {WebhookType}\n     */\n\n    this.type = WebhookTypes[data.type];\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.guildId = data.guild_id;\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.channelId = data.channel_id;\n    /**\n     * The owner of the webhook\n     * @type {?(User|APIUser)}\n     */\n\n    this.owner = data.user ? this.client.users?._add(data.user) ?? data.user : null;\n    /**\n     * The source guild of the webhook\n     * @type {?(Guild|APIGuild)}\n     */\n\n    this.sourceGuild = data.source_guild ? this.client.guilds?._add(data.source_guild, false) ?? data.source_guild : null;\n    /**\n     * The source channel of the webhook\n     * @type {?(Channel|APIChannel)}\n     */\n\n    this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel ?? null;\n  }\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} WebhookEditMessageOptions\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] See {@link WebhookMessageOptions#embeds}\n   * @property {string} [content] See {@link BaseMessageOptions#content}\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] See {@link BaseMessageOptions#files}\n   * @property {MessageMentionOptions} [allowedMentions] See {@link BaseMessageOptions#allowedMentions}\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const {\n      data,\n      files\n    } = await messagePayload.resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: {\n        thread_id: messagePayload.options.threadId,\n        wait: true\n      },\n      auth: false\n    });\n    return this.client.channels?.cache.get(d.channel_id)?.messages._add(d, false) ?? d;\n  }\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n\n\n  async sendSlackMessage(body) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    const data = await this.client.api.webhooks(this.id, this.token).slack.post({\n      query: {\n        wait: true\n      },\n      auth: false,\n      data: body\n    });\n    return data.toString() === 'ok';\n  }\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {BufferResolvable} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @param {string} [reason] Reason for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n\n\n  async edit(_ref, reason) {\n    let {\n      name = this.name,\n      avatar,\n      channel\n    } = _ref;\n\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n\n    if (channel) channel = channel?.id ?? channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: {\n        name,\n        avatar,\n        channel_id: channel\n      },\n      reason\n    });\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {boolean} [cache=true] Whether to cache the message\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n\n\n  async fetchMessage(message) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    const data = await this.client.api.webhooks(this.id, this.token).messages(message).get();\n    return this.client.channels?.cache.get(data.channel_id)?.messages._add(data, cache) ?? data;\n  }\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n\n\n  async editMessage(message, options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      data,\n      files\n    } = await messagePayload.resolveData().resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).messages(typeof message === 'string' ? message : message.id).patch({\n      data,\n      files\n    });\n    const messageManager = this.client.channels?.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return d;\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n\n    const clone = existing._clone();\n\n    clone._patch(d);\n\n    return clone;\n  }\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(reason) {\n    await this.client.api.webhooks(this.id, this.token).delete({\n      reason\n    });\n  }\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @returns {Promise<void>}\n   */\n\n\n  async deleteMessage(message) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    await this.client.api.webhooks(this.id, this.token).messages(typeof message === 'string' ? message : message.id).delete();\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n  /**\n   * A link to the webhook's avatar.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  avatarURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    for (const prop of ['send', 'sendSlackMessage', 'fetchMessage', 'edit', 'editMessage', 'delete', 'deleteMessage', 'createdTimestamp', 'createdAt', 'url']) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = Webhook;","map":{"version":3,"names":["MessagePayload","require","Error","WebhookTypes","DataResolver","SnowflakeUtil","Webhook","constructor","client","data","Object","defineProperty","value","_patch","name","token","writable","configurable","avatar","id","type","guildId","guild_id","channelId","channel_id","owner","user","users","_add","sourceGuild","source_guild","guilds","sourceChannel","channels","resolve","source_channel","send","options","messagePayload","resolveData","create","files","resolveFiles","d","api","webhooks","post","query","thread_id","threadId","wait","auth","cache","get","messages","sendSlackMessage","body","slack","toString","edit","reason","channel","startsWith","resolveImage","undefined","patch","fetchMessage","message","editMessage","messageManager","existing","clone","_clone","delete","deleteMessage","createdTimestamp","deconstruct","timestamp","createdAt","Date","url","http","avatarURL","format","size","rest","cdn","Avatar","applyToClass","structure","ignore","prop","includes","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/Webhook.js"],"sourcesContent":["'use strict';\n\nconst MessagePayload = require('./MessagePayload');\nconst { Error } = require('../errors');\nconst { WebhookTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', { value: data.token ?? null, writable: true, configurable: true });\n\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n    this.avatar = data.avatar;\n\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The type of the webhook\n     * @type {WebhookType}\n     */\n    this.type = WebhookTypes[data.type];\n\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.guildId = data.guild_id;\n\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The owner of the webhook\n     * @type {?(User|APIUser)}\n     */\n    this.owner = data.user ? this.client.users?._add(data.user) ?? data.user : null;\n\n    /**\n     * The source guild of the webhook\n     * @type {?(Guild|APIGuild)}\n     */\n    this.sourceGuild = data.source_guild\n      ? this.client.guilds?._add(data.source_guild, false) ?? data.source_guild\n      : null;\n\n    /**\n     * The source channel of the webhook\n     * @type {?(Channel|APIChannel)}\n     */\n    this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel ?? null;\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} WebhookEditMessageOptions\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] See {@link WebhookMessageOptions#embeds}\n   * @property {string} [content] See {@link BaseMessageOptions#content}\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] See {@link BaseMessageOptions#files}\n   * @property {MessageMentionOptions} [allowedMentions] See {@link BaseMessageOptions#allowedMentions}\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const { data, files } = await messagePayload.resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: { thread_id: messagePayload.options.threadId, wait: true },\n      auth: false,\n    });\n    return this.client.channels?.cache.get(d.channel_id)?.messages._add(d, false) ?? d;\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n  async sendSlackMessage(body) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    const data = await this.client.api.webhooks(this.id, this.token).slack.post({\n      query: { wait: true },\n      auth: false,\n      data: body,\n    });\n    return data.toString() === 'ok';\n  }\n\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {BufferResolvable} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @param {string} [reason] Reason for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit({ name = this.name, avatar, channel }, reason) {\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    if (channel) channel = channel?.id ?? channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: { name, avatar, channel_id: channel },\n      reason,\n    });\n\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {boolean} [cache=true] Whether to cache the message\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n  async fetchMessage(message, cache = true) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    const data = await this.client.api.webhooks(this.id, this.token).messages(message).get();\n    return this.client.channels?.cache.get(data.channel_id)?.messages._add(data, cache) ?? data;\n  }\n\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n  async editMessage(message, options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { data, files } = await messagePayload.resolveData().resolveFiles();\n\n    const d = await this.client.api\n      .webhooks(this.id, this.token)\n      .messages(typeof message === 'string' ? message : message.id)\n      .patch({ data, files });\n\n    const messageManager = this.client.channels?.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return d;\n\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n\n    const clone = existing._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n  async delete(reason) {\n    await this.client.api.webhooks(this.id, this.token).delete({ reason });\n  }\n\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @returns {Promise<void>}\n   */\n  async deleteMessage(message) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    await this.client.api\n      .webhooks(this.id, this.token)\n      .messages(typeof message === 'string' ? message : message.id)\n      .delete();\n  }\n\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return SnowflakeUtil.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  static applyToClass(structure, ignore = []) {\n    for (const prop of [\n      'send',\n      'sendSlackMessage',\n      'fetchMessage',\n      'edit',\n      'editMessage',\n      'delete',\n      'deleteMessage',\n      'createdTimestamp',\n      'createdAt',\n      'url',\n    ]) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = Webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}