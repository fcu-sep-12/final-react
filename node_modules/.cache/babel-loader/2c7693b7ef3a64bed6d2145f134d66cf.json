{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapPredicate = void 0;\n\nconst isEqual = require(\"lodash.isequal\");\n\nconst has_items_1 = require(\"../utils/has-items\");\n\nconst of_type_1 = require(\"../utils/of-type\");\n\nconst predicate_1 = require(\"./predicate\");\n\nclass MapPredicate extends predicate_1.Predicate {\n  /**\n  @hidden\n  */\n  constructor(options) {\n    super('Map', options);\n  }\n  /**\n  Test a Map to have a specific size.\n   @param size - The size of the Map.\n  */\n\n\n  size(size) {\n    return this.addValidator({\n      message: (map, label) => `Expected ${label} to have size \\`${size}\\`, got \\`${map.size}\\``,\n      validator: map => map.size === size\n    });\n  }\n  /**\n  Test an Map to have a minimum size.\n   @param size - The minimum size of the Map.\n  */\n\n\n  minSize(size) {\n    return this.addValidator({\n      message: (map, label) => `Expected ${label} to have a minimum size of \\`${size}\\`, got \\`${map.size}\\``,\n      validator: map => map.size >= size,\n      negatedMessage: (map, label) => `Expected ${label} to have a maximum size of \\`${size - 1}\\`, got \\`${map.size}\\``\n    });\n  }\n  /**\n  Test an Map to have a maximum size.\n   @param size - The maximum size of the Map.\n  */\n\n\n  maxSize(size) {\n    return this.addValidator({\n      message: (map, label) => `Expected ${label} to have a maximum size of \\`${size}\\`, got \\`${map.size}\\``,\n      validator: map => map.size <= size,\n      negatedMessage: (map, label) => `Expected ${label} to have a minimum size of \\`${size + 1}\\`, got \\`${map.size}\\``\n    });\n  }\n  /**\n  Test a Map to include all the provided keys. The keys are tested by identity, not structure.\n   @param keys - The keys that should be a key in the Map.\n  */\n\n\n  hasKeys() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    return this.addValidator({\n      message: (_, label, missingKeys) => `Expected ${label} to have keys \\`${JSON.stringify(missingKeys)}\\``,\n      validator: map => has_items_1.default(map, keys)\n    });\n  }\n  /**\n  Test a Map to include any of the provided keys. The keys are tested by identity, not structure.\n   @param keys - The keys that could be a key in the Map.\n  */\n\n\n  hasAnyKeys() {\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n\n    return this.addValidator({\n      message: (_, label) => `Expected ${label} to have any key of \\`${JSON.stringify(keys)}\\``,\n      validator: map => keys.some(key => map.has(key))\n    });\n  }\n  /**\n  Test a Map to include all the provided values. The values are tested by identity, not structure.\n   @param values - The values that should be a value in the Map.\n  */\n\n\n  hasValues() {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return this.addValidator({\n      message: (_, label, missingValues) => `Expected ${label} to have values \\`${JSON.stringify(missingValues)}\\``,\n      validator: map => has_items_1.default(new Set(map.values()), values)\n    });\n  }\n  /**\n  Test a Map to include any of the provided values. The values are tested by identity, not structure.\n   @param values - The values that could be a value in the Map.\n  */\n\n\n  hasAnyValues() {\n    for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      values[_key4] = arguments[_key4];\n    }\n\n    return this.addValidator({\n      message: (_, label) => `Expected ${label} to have any value of \\`${JSON.stringify(values)}\\``,\n      validator: map => {\n        const valueSet = new Set(map.values());\n        return values.some(key => valueSet.has(key));\n      }\n    });\n  }\n  /**\n  Test all the keys in the Map to match the provided predicate.\n   @param predicate - The predicate that should be applied against every key in the Map.\n  */\n\n\n  keysOfType(predicate) {\n    return this.addValidator({\n      message: (_, label, error) => `(${label}) ${error}`,\n      validator: map => of_type_1.default(map.keys(), 'keys', predicate)\n    });\n  }\n  /**\n  Test all the values in the Map to match the provided predicate.\n   @param predicate - The predicate that should be applied against every value in the Map.\n  */\n\n\n  valuesOfType(predicate) {\n    return this.addValidator({\n      message: (_, label, error) => `(${label}) ${error}`,\n      validator: map => of_type_1.default(map.values(), 'values', predicate)\n    });\n  }\n  /**\n  Test a Map to be empty.\n  */\n\n\n  get empty() {\n    return this.addValidator({\n      message: (map, label) => `Expected ${label} to be empty, got \\`${JSON.stringify([...map])}\\``,\n      validator: map => map.size === 0\n    });\n  }\n  /**\n  Test a Map to be not empty.\n  */\n\n\n  get nonEmpty() {\n    return this.addValidator({\n      message: (_, label) => `Expected ${label} to not be empty`,\n      validator: map => map.size > 0\n    });\n  }\n  /**\n  Test a Map to be deeply equal to the provided Map.\n   @param expected - Expected Map to match.\n  */\n\n\n  deepEqual(expected) {\n    return this.addValidator({\n      message: (map, label) => `Expected ${label} to be deeply equal to \\`${JSON.stringify([...expected])}\\`, got \\`${JSON.stringify([...map])}\\``,\n      validator: map => isEqual(map, expected)\n    });\n  }\n\n}\n\nexports.MapPredicate = MapPredicate;","map":{"version":3,"names":["Object","defineProperty","exports","value","MapPredicate","isEqual","require","has_items_1","of_type_1","predicate_1","Predicate","constructor","options","size","addValidator","message","map","label","validator","minSize","negatedMessage","maxSize","hasKeys","keys","_","missingKeys","JSON","stringify","default","hasAnyKeys","some","key","has","hasValues","values","missingValues","Set","hasAnyValues","valueSet","keysOfType","predicate","error","valuesOfType","empty","nonEmpty","deepEqual","expected"],"sources":["C:/Users/ROUSER6/node_modules/ow/dist/predicates/map.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapPredicate = void 0;\nconst isEqual = require(\"lodash.isequal\");\nconst has_items_1 = require(\"../utils/has-items\");\nconst of_type_1 = require(\"../utils/of-type\");\nconst predicate_1 = require(\"./predicate\");\nclass MapPredicate extends predicate_1.Predicate {\n    /**\n    @hidden\n    */\n    constructor(options) {\n        super('Map', options);\n    }\n    /**\n    Test a Map to have a specific size.\n\n    @param size - The size of the Map.\n    */\n    size(size) {\n        return this.addValidator({\n            message: (map, label) => `Expected ${label} to have size \\`${size}\\`, got \\`${map.size}\\``,\n            validator: map => map.size === size\n        });\n    }\n    /**\n    Test an Map to have a minimum size.\n\n    @param size - The minimum size of the Map.\n    */\n    minSize(size) {\n        return this.addValidator({\n            message: (map, label) => `Expected ${label} to have a minimum size of \\`${size}\\`, got \\`${map.size}\\``,\n            validator: map => map.size >= size,\n            negatedMessage: (map, label) => `Expected ${label} to have a maximum size of \\`${size - 1}\\`, got \\`${map.size}\\``\n        });\n    }\n    /**\n    Test an Map to have a maximum size.\n\n    @param size - The maximum size of the Map.\n    */\n    maxSize(size) {\n        return this.addValidator({\n            message: (map, label) => `Expected ${label} to have a maximum size of \\`${size}\\`, got \\`${map.size}\\``,\n            validator: map => map.size <= size,\n            negatedMessage: (map, label) => `Expected ${label} to have a minimum size of \\`${size + 1}\\`, got \\`${map.size}\\``\n        });\n    }\n    /**\n    Test a Map to include all the provided keys. The keys are tested by identity, not structure.\n\n    @param keys - The keys that should be a key in the Map.\n    */\n    hasKeys(...keys) {\n        return this.addValidator({\n            message: (_, label, missingKeys) => `Expected ${label} to have keys \\`${JSON.stringify(missingKeys)}\\``,\n            validator: map => has_items_1.default(map, keys)\n        });\n    }\n    /**\n    Test a Map to include any of the provided keys. The keys are tested by identity, not structure.\n\n    @param keys - The keys that could be a key in the Map.\n    */\n    hasAnyKeys(...keys) {\n        return this.addValidator({\n            message: (_, label) => `Expected ${label} to have any key of \\`${JSON.stringify(keys)}\\``,\n            validator: map => keys.some(key => map.has(key))\n        });\n    }\n    /**\n    Test a Map to include all the provided values. The values are tested by identity, not structure.\n\n    @param values - The values that should be a value in the Map.\n    */\n    hasValues(...values) {\n        return this.addValidator({\n            message: (_, label, missingValues) => `Expected ${label} to have values \\`${JSON.stringify(missingValues)}\\``,\n            validator: map => has_items_1.default(new Set(map.values()), values)\n        });\n    }\n    /**\n    Test a Map to include any of the provided values. The values are tested by identity, not structure.\n\n    @param values - The values that could be a value in the Map.\n    */\n    hasAnyValues(...values) {\n        return this.addValidator({\n            message: (_, label) => `Expected ${label} to have any value of \\`${JSON.stringify(values)}\\``,\n            validator: map => {\n                const valueSet = new Set(map.values());\n                return values.some(key => valueSet.has(key));\n            }\n        });\n    }\n    /**\n    Test all the keys in the Map to match the provided predicate.\n\n    @param predicate - The predicate that should be applied against every key in the Map.\n    */\n    keysOfType(predicate) {\n        return this.addValidator({\n            message: (_, label, error) => `(${label}) ${error}`,\n            validator: map => of_type_1.default(map.keys(), 'keys', predicate)\n        });\n    }\n    /**\n    Test all the values in the Map to match the provided predicate.\n\n    @param predicate - The predicate that should be applied against every value in the Map.\n    */\n    valuesOfType(predicate) {\n        return this.addValidator({\n            message: (_, label, error) => `(${label}) ${error}`,\n            validator: map => of_type_1.default(map.values(), 'values', predicate)\n        });\n    }\n    /**\n    Test a Map to be empty.\n    */\n    get empty() {\n        return this.addValidator({\n            message: (map, label) => `Expected ${label} to be empty, got \\`${JSON.stringify([...map])}\\``,\n            validator: map => map.size === 0\n        });\n    }\n    /**\n    Test a Map to be not empty.\n    */\n    get nonEmpty() {\n        return this.addValidator({\n            message: (_, label) => `Expected ${label} to not be empty`,\n            validator: map => map.size > 0\n        });\n    }\n    /**\n    Test a Map to be deeply equal to the provided Map.\n\n    @param expected - Expected Map to match.\n    */\n    deepEqual(expected) {\n        return this.addValidator({\n            message: (map, label) => `Expected ${label} to be deeply equal to \\`${JSON.stringify([...expected])}\\`, got \\`${JSON.stringify([...map])}\\``,\n            validator: map => isEqual(map, expected)\n        });\n    }\n}\nexports.MapPredicate = MapPredicate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}