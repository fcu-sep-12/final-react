{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst MessageManager = require('../managers/MessageManager');\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIChannel} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data); // Override the channel type so partials have a known type\n\n    this.type = 'DM';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users._add(data.recipients[0]);\n    }\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n\n\n    this.lastMessageId = data.last_message_id;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.lastMessageId === 'undefined';\n  }\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.recipient.createDM(force);\n  }\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n\n\n  toString() {\n    return this.recipient.toString();\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendTyping() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentCollector() {}\n\n  awaitMessageComponent() {} // Doesn't work on DM channels; bulkDelete() {}\n\n\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\nmodule.exports = DMChannel;","map":{"version":3,"names":["Channel","require","TextBasedChannel","MessageManager","DMChannel","constructor","client","data","type","messages","_patch","recipients","recipient","users","_add","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","Date","getTime","partial","fetch","force","createDM","toString","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","applyToClass","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/DMChannel.js"],"sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIChannel} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data);\n\n    // Override the channel type so partials have a known type\n    this.type = 'DM';\n\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users._add(data.recipients[0]);\n    }\n\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageId = data.last_message_id;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.lastMessageId === 'undefined';\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch(force = true) {\n    return this.recipient.createDM(force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return this.recipient.toString();\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\n\nmodule.exports = DMChannel;\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,+BAAD,CAAhC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,4BAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,SAAN,SAAwBJ,OAAxB,CAAgC;EAC9B;AACF;AACA;AACA;EACEK,WAAW,CAACC,MAAD,EAASC,IAAT,EAAe;IACxB,MAAMD,MAAN,EAAcC,IAAd,EADwB,CAGxB;;IACA,KAAKC,IAAL,GAAY,IAAZ;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,QAAL,GAAgB,IAAIN,cAAJ,CAAmB,IAAnB,CAAhB;EACD;;EAEDO,MAAM,CAACH,IAAD,EAAO;IACX,MAAMG,MAAN,CAAaH,IAAb;;IAEA,IAAIA,IAAI,CAACI,UAAT,EAAqB;MACnB;AACN;AACA;AACA;MACM,KAAKC,SAAL,GAAiB,KAAKN,MAAL,CAAYO,KAAZ,CAAkBC,IAAlB,CAAuBP,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAvB,CAAjB;IACD;IAED;AACJ;AACA;AACA;;;IACI,KAAKI,aAAL,GAAqBR,IAAI,CAACS,eAA1B;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,gBAAL,GAAwBV,IAAI,CAACW,kBAAL,GAA0B,IAAIC,IAAJ,CAASZ,IAAI,CAACW,kBAAd,EAAkCE,OAAlC,EAA1B,GAAwE,IAAhG;EACD;EAED;AACF;AACA;AACA;AACA;;;EACa,IAAPC,OAAO,GAAG;IACZ,OAAO,OAAO,KAAKN,aAAZ,KAA8B,WAArC;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEO,KAAK,GAAe;IAAA,IAAdC,KAAc,uEAAN,IAAM;IAClB,OAAO,KAAKX,SAAL,CAAeY,QAAf,CAAwBD,KAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEE,QAAQ,GAAG;IACT,OAAO,KAAKb,SAAL,CAAea,QAAf,EAAP;EACD,CAtE6B,CAwE9B;;EACA;;;EACe,IAAXC,WAAW,GAAG,CAAE;;EACP,IAATC,SAAS,GAAG,CAAE;;EAClBC,IAAI,GAAG,CAAE;;EACTC,UAAU,GAAG,CAAE;;EACfC,sBAAsB,GAAG,CAAE;;EAC3BC,aAAa,GAAG,CAAE;;EAClBC,+BAA+B,GAAG,CAAE;;EACpCC,qBAAqB,GAAG,CAAE,CAjFI,CAkF9B;;;AAlF8B;;AAqFhC/B,gBAAgB,CAACgC,YAAjB,CAA8B9B,SAA9B,EAAyC,IAAzC,EAA+C,CAAC,YAAD,CAA/C;AAEA+B,MAAM,CAACC,OAAP,GAAiBhC,SAAjB"},"metadata":{},"sourceType":"script"}