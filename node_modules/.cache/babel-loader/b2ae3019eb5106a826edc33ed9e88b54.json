{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst path = require('path');\n\nconst {\n  Error\n} = require('../errors');\n\nconst Util = require('../util/Util');\n\nlet childProcess = null;\nlet Worker = null;\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends EventEmitter\n */\n\nclass Shard extends EventEmitter {\n  /**\n   * @param {ShardingManager} manager Manager that is creating this shard\n   * @param {number} id The shard's id\n   */\n  constructor(manager, id) {\n    super();\n    if (manager.mode === 'process') childProcess = require('child_process');else if (manager.mode === 'worker') Worker = require('worker_threads').Worker;\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n\n    this.id = id;\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.args = manager.shardArgs ?? [];\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.execArgv = manager.execArgv;\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token\n    });\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n\n    this.ready = false;\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n\n    this.process = null;\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n\n    this.worker = null;\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n\n    this._evals = new Map();\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n\n    this._fetches = new Map();\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n\n    this._exitListener = this._handleExit.bind(this, undefined);\n  }\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n\n\n  spawn() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30000;\n    if (this.process) throw new Error('SHARDING_PROCESS_EXISTS', this.id);\n    if (this.worker) throw new Error('SHARDING_WORKER_EXISTS', this.id);\n\n    if (this.manager.mode === 'process') {\n      this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {\n        env: this.env,\n        execArgv: this.execArgv\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), {\n        workerData: this.env\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    }\n\n    this._evals.clear();\n\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n\n    this.emit('spawn', child);\n    if (timeout === -1 || timeout === Infinity) return child;\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DISCONNECTED', this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DIED', this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_TIMEOUT', this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n\n\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n\n\n  async respawn() {\n    let {\n      delay = 500,\n      timeout = 30000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.kill();\n    if (delay > 0) await Util.delayFor(delay);\n    return this.spawn(timeout);\n  }\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n\n\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id)); // Cached promise from previous call\n\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n\n        this._fetches.delete(prop);\n\n        resolve(message._result);\n      };\n\n      child.on('message', listener);\n      this.send({\n        _fetchProp: prop\n      }).catch(err => {\n        child.removeListener('message', listener);\n\n        this._fetches.delete(prop);\n\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n\n    return promise;\n  }\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @returns {Promise<*>} Result of the script execution\n   */\n\n\n  eval(script) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id)); // Cached promise from previous call\n\n    if (this._evals.has(script)) return this._evals.get(script);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== script) return;\n        child.removeListener('message', listener);\n\n        this._evals.delete(script);\n\n        if (!message._error) resolve(message._result);else reject(Util.makeError(message._error));\n      };\n\n      child.on('message', listener);\n\n      const _eval = typeof script === 'function' ? `(${script})(this)` : script;\n\n      this.send({\n        _eval\n      }).catch(err => {\n        child.removeListener('message', listener);\n\n        this._evals.delete(script);\n\n        reject(err);\n      });\n    });\n\n    this._evals.set(script, promise);\n\n    return promise;\n  }\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n\n\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#ready} event.\n         * @event Shard#ready\n         */\n\n        this.emit('ready');\n        return;\n      } // Shard has disconnected\n\n\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#disconnect} event.\n         * @event Shard#disconnect\n         */\n\n        this.emit('disconnect');\n        return;\n      } // Shard is attempting to reconnect\n\n\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#reconnecting} event.\n         * @event Shard#reconnecting\n         */\n\n        this.emit('reconnecting');\n        return;\n      } // Shard is requesting a property fetch\n\n\n      if (message._sFetchProp) {\n        const resp = {\n          _sFetchProp: message._sFetchProp,\n          _sFetchPropShard: message._sFetchPropShard\n        };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(results => this.send({ ...resp,\n          _result: results\n        }), err => this.send({ ...resp,\n          _error: Util.makePlainError(err)\n        }));\n        return;\n      } // Shard is requesting an eval broadcast\n\n\n      if (message._sEval) {\n        const resp = {\n          _sEval: message._sEval,\n          _sEvalShard: message._sEvalShard\n        };\n\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(results => this.send({ ...resp,\n          _result: results\n        }), err => this.send({ ...resp,\n          _error: Util.makePlainError(err)\n        }));\n\n        return;\n      } // Shard is requesting a respawn of all shards\n\n\n      if (message._sRespawnAll) {\n        const {\n          shardDelay,\n          respawnDelay,\n          timeout\n        } = message._sRespawnAll;\n        this.manager.respawnAll({\n          shardDelay,\n          respawnDelay,\n          timeout\n        }).catch(() => {// Do nothing\n        });\n        return;\n      }\n    }\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n\n\n    this.emit('message', message);\n  }\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @private\n   */\n\n\n  _handleExit() {\n    let respawn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.manager.respawn;\n\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit('death', this.process ?? this.worker);\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n\n    this._evals.clear();\n\n    this._fetches.clear();\n\n    if (respawn) this.spawn().catch(err => this.emit('error', err));\n  }\n\n}\n\nmodule.exports = Shard;","map":{"version":3,"names":["EventEmitter","require","path","Error","Util","childProcess","Worker","Shard","constructor","manager","id","mode","args","shardArgs","execArgv","env","Object","assign","process","SHARDING_MANAGER","SHARDS","SHARD_COUNT","totalShards","DISCORD_TOKEN","token","ready","worker","_evals","Map","_fetches","_exitListener","_handleExit","bind","undefined","spawn","timeout","fork","resolve","file","on","_handleMessage","workerData","clear","child","emit","Infinity","Promise","reject","cleanup","clearTimeout","spawnTimeoutTimer","off","onReady","onDisconnect","onDeath","onTimeout","setTimeout","once","kill","removeListener","terminate","respawn","delay","delayFor","send","message","err","postMessage","fetchClientValue","prop","has","get","promise","listener","_fetchProp","delete","_result","catch","set","eval","script","_eval","_error","makeError","_ready","_disconnect","_reconnecting","_sFetchProp","resp","_sFetchPropShard","fetchClientValues","then","results","makePlainError","_sEval","_sEvalShard","_performOnShards","_sRespawnAll","shardDelay","respawnDelay","respawnAll","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/sharding/Shard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst path = require('path');\nconst { Error } = require('../errors');\nconst Util = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends EventEmitter\n */\nclass Shard extends EventEmitter {\n  /**\n   * @param {ShardingManager} manager Manager that is creating this shard\n   * @param {number} id The shard's id\n   */\n  constructor(manager, id) {\n    super();\n\n    if (manager.mode === 'process') childProcess = require('child_process');\n    else if (manager.mode === 'worker') Worker = require('worker_threads').Worker;\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token,\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = this._handleExit.bind(this, undefined);\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn(timeout = 30000) {\n    if (this.process) throw new Error('SHARDING_PROCESS_EXISTS', this.id);\n    if (this.worker) throw new Error('SHARDING_WORKER_EXISTS', this.id);\n\n    if (this.manager.mode === 'process') {\n      this.process = childProcess\n        .fork(path.resolve(this.manager.file), this.args, {\n          env: this.env,\n          execArgv: this.execArgv,\n        })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    }\n\n    this._evals.clear();\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit('spawn', child);\n\n    if (timeout === -1 || timeout === Infinity) return child;\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DISCONNECTED', this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DIED', this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_TIMEOUT', this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn({ delay = 500, timeout = 30000 } = {}) {\n    this.kill();\n    if (delay > 0) await Util.delayFor(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);\n          else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id));\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this._fetches.delete(prop);\n        resolve(message._result);\n      };\n      child.on('message', listener);\n\n      this.send({ _fetchProp: prop }).catch(err => {\n        child.removeListener('message', listener);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id));\n\n    // Cached promise from previous call\n    if (this._evals.has(script)) return this._evals.get(script);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== script) return;\n        child.removeListener('message', listener);\n        this._evals.delete(script);\n        if (!message._error) resolve(message._result);\n        else reject(Util.makeError(message._error));\n      };\n      child.on('message', listener);\n\n      const _eval = typeof script === 'function' ? `(${script})(this)` : script;\n      this.send({ _eval }).catch(err => {\n        child.removeListener('message', listener);\n        this._evals.delete(script);\n        reject(err);\n      });\n    });\n\n    this._evals.set(script, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#ready} event.\n         * @event Shard#ready\n         */\n        this.emit('ready');\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#disconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit('disconnect');\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#reconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit('reconnecting');\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: Util.makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: Util.makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;\n        this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit('message', message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @private\n   */\n  _handleExit(respawn = this.manager.respawn) {\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit('death', this.process ?? this.worker);\n\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n\n    if (respawn) this.spawn().catch(err => this.emit('error', err));\n  }\n}\n\nmodule.exports = Shard;\n"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAM;EAAEE;AAAF,IAAYF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,cAAD,CAApB;;AACA,IAAII,YAAY,GAAG,IAAnB;AACA,IAAIC,MAAM,GAAG,IAAb;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,KAAN,SAAoBP,YAApB,CAAiC;EAC/B;AACF;AACA;AACA;EACEQ,WAAW,CAACC,OAAD,EAAUC,EAAV,EAAc;IACvB;IAEA,IAAID,OAAO,CAACE,IAAR,KAAiB,SAArB,EAAgCN,YAAY,GAAGJ,OAAO,CAAC,eAAD,CAAtB,CAAhC,KACK,IAAIQ,OAAO,CAACE,IAAR,KAAiB,QAArB,EAA+BL,MAAM,GAAGL,OAAO,CAAC,gBAAD,CAAP,CAA0BK,MAAnC;IAEpC;AACJ;AACA;AACA;;IACI,KAAKG,OAAL,GAAeA,OAAf;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,EAAL,GAAUA,EAAV;IAEA;AACJ;AACA;AACA;;IACI,KAAKE,IAAL,GAAYH,OAAO,CAACI,SAAR,IAAqB,EAAjC;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,QAAL,GAAgBL,OAAO,CAACK,QAAxB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,GAAL,GAAWC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBC,OAAO,CAACH,GAA1B,EAA+B;MACxCI,gBAAgB,EAAE,IADsB;MAExCC,MAAM,EAAE,KAAKV,EAF2B;MAGxCW,WAAW,EAAE,KAAKZ,OAAL,CAAaa,WAHc;MAIxCC,aAAa,EAAE,KAAKd,OAAL,CAAae;IAJY,CAA/B,CAAX;IAOA;AACJ;AACA;AACA;;IACI,KAAKC,KAAL,GAAa,KAAb;IAEA;AACJ;AACA;AACA;;IACI,KAAKP,OAAL,GAAe,IAAf;IAEA;AACJ;AACA;AACA;;IACI,KAAKQ,MAAL,GAAc,IAAd;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,QAAL,GAAgB,IAAID,GAAJ,EAAhB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKE,aAAL,GAAqB,KAAKC,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,EAA4BC,SAA5B,CAArB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEC,KAAK,GAAkB;IAAA,IAAjBC,OAAiB,uEAAP,KAAO;IACrB,IAAI,KAAKjB,OAAT,EAAkB,MAAM,IAAIf,KAAJ,CAAU,yBAAV,EAAqC,KAAKO,EAA1C,CAAN;IAClB,IAAI,KAAKgB,MAAT,EAAiB,MAAM,IAAIvB,KAAJ,CAAU,wBAAV,EAAoC,KAAKO,EAAzC,CAAN;;IAEjB,IAAI,KAAKD,OAAL,CAAaE,IAAb,KAAsB,SAA1B,EAAqC;MACnC,KAAKO,OAAL,GAAeb,YAAY,CACxB+B,IADY,CACPlC,IAAI,CAACmC,OAAL,CAAa,KAAK5B,OAAL,CAAa6B,IAA1B,CADO,EAC0B,KAAK1B,IAD/B,EACqC;QAChDG,GAAG,EAAE,KAAKA,GADsC;QAEhDD,QAAQ,EAAE,KAAKA;MAFiC,CADrC,EAKZyB,EALY,CAKT,SALS,EAKE,KAAKC,cAAL,CAAoBR,IAApB,CAAyB,IAAzB,CALF,EAMZO,EANY,CAMT,MANS,EAMD,KAAKT,aANJ,CAAf;IAOD,CARD,MAQO,IAAI,KAAKrB,OAAL,CAAaE,IAAb,KAAsB,QAA1B,EAAoC;MACzC,KAAKe,MAAL,GAAc,IAAIpB,MAAJ,CAAWJ,IAAI,CAACmC,OAAL,CAAa,KAAK5B,OAAL,CAAa6B,IAA1B,CAAX,EAA4C;QAAEG,UAAU,EAAE,KAAK1B;MAAnB,CAA5C,EACXwB,EADW,CACR,SADQ,EACG,KAAKC,cAAL,CAAoBR,IAApB,CAAyB,IAAzB,CADH,EAEXO,EAFW,CAER,MAFQ,EAEA,KAAKT,aAFL,CAAd;IAGD;;IAED,KAAKH,MAAL,CAAYe,KAAZ;;IACA,KAAKb,QAAL,CAAca,KAAd;;IAEA,MAAMC,KAAK,GAAG,KAAKzB,OAAL,IAAgB,KAAKQ,MAAnC;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKkB,IAAL,CAAU,OAAV,EAAmBD,KAAnB;IAEA,IAAIR,OAAO,KAAK,CAAC,CAAb,IAAkBA,OAAO,KAAKU,QAAlC,EAA4C,OAAOF,KAAP;IAC5C,OAAO,IAAIG,OAAJ,CAAY,CAACT,OAAD,EAAUU,MAAV,KAAqB;MACtC,MAAMC,OAAO,GAAG,MAAM;QACpBC,YAAY,CAACC,iBAAD,CAAZ;QACA,KAAKC,GAAL,CAAS,OAAT,EAAkBC,OAAlB;QACA,KAAKD,GAAL,CAAS,YAAT,EAAuBE,YAAvB;QACA,KAAKF,GAAL,CAAS,OAAT,EAAkBG,OAAlB;MACD,CALD;;MAOA,MAAMF,OAAO,GAAG,MAAM;QACpBJ,OAAO;QACPX,OAAO,CAACM,KAAD,CAAP;MACD,CAHD;;MAKA,MAAMU,YAAY,GAAG,MAAM;QACzBL,OAAO;QACPD,MAAM,CAAC,IAAI5C,KAAJ,CAAU,6BAAV,EAAyC,KAAKO,EAA9C,CAAD,CAAN;MACD,CAHD;;MAKA,MAAM4C,OAAO,GAAG,MAAM;QACpBN,OAAO;QACPD,MAAM,CAAC,IAAI5C,KAAJ,CAAU,qBAAV,EAAiC,KAAKO,EAAtC,CAAD,CAAN;MACD,CAHD;;MAKA,MAAM6C,SAAS,GAAG,MAAM;QACtBP,OAAO;QACPD,MAAM,CAAC,IAAI5C,KAAJ,CAAU,wBAAV,EAAoC,KAAKO,EAAzC,CAAD,CAAN;MACD,CAHD;;MAKA,MAAMwC,iBAAiB,GAAGM,UAAU,CAACD,SAAD,EAAYpB,OAAZ,CAApC;MACA,KAAKsB,IAAL,CAAU,OAAV,EAAmBL,OAAnB;MACA,KAAKK,IAAL,CAAU,YAAV,EAAwBJ,YAAxB;MACA,KAAKI,IAAL,CAAU,OAAV,EAAmBH,OAAnB;IACD,CAhCM,CAAP;EAiCD;EAED;AACF;AACA;;;EACEI,IAAI,GAAG;IACL,IAAI,KAAKxC,OAAT,EAAkB;MAChB,KAAKA,OAAL,CAAayC,cAAb,CAA4B,MAA5B,EAAoC,KAAK7B,aAAzC;MACA,KAAKZ,OAAL,CAAawC,IAAb;IACD,CAHD,MAGO;MACL,KAAKhC,MAAL,CAAYiC,cAAZ,CAA2B,MAA3B,EAAmC,KAAK7B,aAAxC;MACA,KAAKJ,MAAL,CAAYkC,SAAZ;IACD;;IAED,KAAK7B,WAAL,CAAiB,KAAjB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;;EACe,MAAP8B,OAAO,GAAwC;IAAA,IAAvC;MAAEC,KAAK,GAAG,GAAV;MAAe3B,OAAO,GAAG;IAAzB,CAAuC,uEAAJ,EAAI;IACnD,KAAKuB,IAAL;IACA,IAAII,KAAK,GAAG,CAAZ,EAAe,MAAM1D,IAAI,CAAC2D,QAAL,CAAcD,KAAd,CAAN;IACf,OAAO,KAAK5B,KAAL,CAAWC,OAAX,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACE6B,IAAI,CAACC,OAAD,EAAU;IACZ,OAAO,IAAInB,OAAJ,CAAY,CAACT,OAAD,EAAUU,MAAV,KAAqB;MACtC,IAAI,KAAK7B,OAAT,EAAkB;QAChB,KAAKA,OAAL,CAAa8C,IAAb,CAAkBC,OAAlB,EAA2BC,GAAG,IAAI;UAChC,IAAIA,GAAJ,EAASnB,MAAM,CAACmB,GAAD,CAAN,CAAT,KACK7B,OAAO,CAAC,IAAD,CAAP;QACN,CAHD;MAID,CALD,MAKO;QACL,KAAKX,MAAL,CAAYyC,WAAZ,CAAwBF,OAAxB;QACA5B,OAAO,CAAC,IAAD,CAAP;MACD;IACF,CAVM,CAAP;EAWD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE+B,gBAAgB,CAACC,IAAD,EAAO;IACrB;IACA,IAAI,CAAC,KAAKnD,OAAN,IAAiB,CAAC,KAAKQ,MAA3B,EAAmC,OAAOoB,OAAO,CAACC,MAAR,CAAe,IAAI5C,KAAJ,CAAU,0BAAV,EAAsC,KAAKO,EAA3C,CAAf,CAAP,CAFd,CAIrB;;IACA,IAAI,KAAKmB,QAAL,CAAcyC,GAAd,CAAkBD,IAAlB,CAAJ,EAA6B,OAAO,KAAKxC,QAAL,CAAc0C,GAAd,CAAkBF,IAAlB,CAAP;IAE7B,MAAMG,OAAO,GAAG,IAAI1B,OAAJ,CAAY,CAACT,OAAD,EAAUU,MAAV,KAAqB;MAC/C,MAAMJ,KAAK,GAAG,KAAKzB,OAAL,IAAgB,KAAKQ,MAAnC;;MAEA,MAAM+C,QAAQ,GAAGR,OAAO,IAAI;QAC1B,IAAIA,OAAO,EAAES,UAAT,KAAwBL,IAA5B,EAAkC;QAClC1B,KAAK,CAACgB,cAAN,CAAqB,SAArB,EAAgCc,QAAhC;;QACA,KAAK5C,QAAL,CAAc8C,MAAd,CAAqBN,IAArB;;QACAhC,OAAO,CAAC4B,OAAO,CAACW,OAAT,CAAP;MACD,CALD;;MAMAjC,KAAK,CAACJ,EAAN,CAAS,SAAT,EAAoBkC,QAApB;MAEA,KAAKT,IAAL,CAAU;QAAEU,UAAU,EAAEL;MAAd,CAAV,EAAgCQ,KAAhC,CAAsCX,GAAG,IAAI;QAC3CvB,KAAK,CAACgB,cAAN,CAAqB,SAArB,EAAgCc,QAAhC;;QACA,KAAK5C,QAAL,CAAc8C,MAAd,CAAqBN,IAArB;;QACAtB,MAAM,CAACmB,GAAD,CAAN;MACD,CAJD;IAKD,CAhBe,CAAhB;;IAkBA,KAAKrC,QAAL,CAAciD,GAAd,CAAkBT,IAAlB,EAAwBG,OAAxB;;IACA,OAAOA,OAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEO,IAAI,CAACC,MAAD,EAAS;IACX;IACA,IAAI,CAAC,KAAK9D,OAAN,IAAiB,CAAC,KAAKQ,MAA3B,EAAmC,OAAOoB,OAAO,CAACC,MAAR,CAAe,IAAI5C,KAAJ,CAAU,0BAAV,EAAsC,KAAKO,EAA3C,CAAf,CAAP,CAFxB,CAIX;;IACA,IAAI,KAAKiB,MAAL,CAAY2C,GAAZ,CAAgBU,MAAhB,CAAJ,EAA6B,OAAO,KAAKrD,MAAL,CAAY4C,GAAZ,CAAgBS,MAAhB,CAAP;IAE7B,MAAMR,OAAO,GAAG,IAAI1B,OAAJ,CAAY,CAACT,OAAD,EAAUU,MAAV,KAAqB;MAC/C,MAAMJ,KAAK,GAAG,KAAKzB,OAAL,IAAgB,KAAKQ,MAAnC;;MAEA,MAAM+C,QAAQ,GAAGR,OAAO,IAAI;QAC1B,IAAIA,OAAO,EAAEgB,KAAT,KAAmBD,MAAvB,EAA+B;QAC/BrC,KAAK,CAACgB,cAAN,CAAqB,SAArB,EAAgCc,QAAhC;;QACA,KAAK9C,MAAL,CAAYgD,MAAZ,CAAmBK,MAAnB;;QACA,IAAI,CAACf,OAAO,CAACiB,MAAb,EAAqB7C,OAAO,CAAC4B,OAAO,CAACW,OAAT,CAAP,CAArB,KACK7B,MAAM,CAAC3C,IAAI,CAAC+E,SAAL,CAAelB,OAAO,CAACiB,MAAvB,CAAD,CAAN;MACN,CAND;;MAOAvC,KAAK,CAACJ,EAAN,CAAS,SAAT,EAAoBkC,QAApB;;MAEA,MAAMQ,KAAK,GAAG,OAAOD,MAAP,KAAkB,UAAlB,GAAgC,IAAGA,MAAO,SAA1C,GAAqDA,MAAnE;;MACA,KAAKhB,IAAL,CAAU;QAAEiB;MAAF,CAAV,EAAqBJ,KAArB,CAA2BX,GAAG,IAAI;QAChCvB,KAAK,CAACgB,cAAN,CAAqB,SAArB,EAAgCc,QAAhC;;QACA,KAAK9C,MAAL,CAAYgD,MAAZ,CAAmBK,MAAnB;;QACAjC,MAAM,CAACmB,GAAD,CAAN;MACD,CAJD;IAKD,CAlBe,CAAhB;;IAoBA,KAAKvC,MAAL,CAAYmD,GAAZ,CAAgBE,MAAhB,EAAwBR,OAAxB;;IACA,OAAOA,OAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEhC,cAAc,CAACyB,OAAD,EAAU;IACtB,IAAIA,OAAJ,EAAa;MACX;MACA,IAAIA,OAAO,CAACmB,MAAZ,EAAoB;QAClB,KAAK3D,KAAL,GAAa,IAAb;QACA;AACR;AACA;AACA;;QACQ,KAAKmB,IAAL,CAAU,OAAV;QACA;MACD,CAVU,CAYX;;;MACA,IAAIqB,OAAO,CAACoB,WAAZ,EAAyB;QACvB,KAAK5D,KAAL,GAAa,KAAb;QACA;AACR;AACA;AACA;;QACQ,KAAKmB,IAAL,CAAU,YAAV;QACA;MACD,CArBU,CAuBX;;;MACA,IAAIqB,OAAO,CAACqB,aAAZ,EAA2B;QACzB,KAAK7D,KAAL,GAAa,KAAb;QACA;AACR;AACA;AACA;;QACQ,KAAKmB,IAAL,CAAU,cAAV;QACA;MACD,CAhCU,CAkCX;;;MACA,IAAIqB,OAAO,CAACsB,WAAZ,EAAyB;QACvB,MAAMC,IAAI,GAAG;UAAED,WAAW,EAAEtB,OAAO,CAACsB,WAAvB;UAAoCE,gBAAgB,EAAExB,OAAO,CAACwB;QAA9D,CAAb;QACA,KAAKhF,OAAL,CAAaiF,iBAAb,CAA+BzB,OAAO,CAACsB,WAAvC,EAAoDtB,OAAO,CAACwB,gBAA5D,EAA8EE,IAA9E,CACEC,OAAO,IAAI,KAAK5B,IAAL,CAAU,EAAE,GAAGwB,IAAL;UAAWZ,OAAO,EAAEgB;QAApB,CAAV,CADb,EAEE1B,GAAG,IAAI,KAAKF,IAAL,CAAU,EAAE,GAAGwB,IAAL;UAAWN,MAAM,EAAE9E,IAAI,CAACyF,cAAL,CAAoB3B,GAApB;QAAnB,CAAV,CAFT;QAIA;MACD,CA1CU,CA4CX;;;MACA,IAAID,OAAO,CAAC6B,MAAZ,EAAoB;QAClB,MAAMN,IAAI,GAAG;UAAEM,MAAM,EAAE7B,OAAO,CAAC6B,MAAlB;UAA0BC,WAAW,EAAE9B,OAAO,CAAC8B;QAA/C,CAAb;;QACA,KAAKtF,OAAL,CAAauF,gBAAb,CAA8B,MAA9B,EAAsC,CAAC/B,OAAO,CAAC6B,MAAT,CAAtC,EAAwD7B,OAAO,CAAC8B,WAAhE,EAA6EJ,IAA7E,CACEC,OAAO,IAAI,KAAK5B,IAAL,CAAU,EAAE,GAAGwB,IAAL;UAAWZ,OAAO,EAAEgB;QAApB,CAAV,CADb,EAEE1B,GAAG,IAAI,KAAKF,IAAL,CAAU,EAAE,GAAGwB,IAAL;UAAWN,MAAM,EAAE9E,IAAI,CAACyF,cAAL,CAAoB3B,GAApB;QAAnB,CAAV,CAFT;;QAIA;MACD,CApDU,CAsDX;;;MACA,IAAID,OAAO,CAACgC,YAAZ,EAA0B;QACxB,MAAM;UAAEC,UAAF;UAAcC,YAAd;UAA4BhE;QAA5B,IAAwC8B,OAAO,CAACgC,YAAtD;QACA,KAAKxF,OAAL,CAAa2F,UAAb,CAAwB;UAAEF,UAAF;UAAcC,YAAd;UAA4BhE;QAA5B,CAAxB,EAA+D0C,KAA/D,CAAqE,MAAM,CACzE;QACD,CAFD;QAGA;MACD;IACF;IAED;AACJ;AACA;AACA;AACA;;;IACI,KAAKjC,IAAL,CAAU,SAAV,EAAqBqB,OAArB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACElC,WAAW,GAAiC;IAAA,IAAhC8B,OAAgC,uEAAtB,KAAKpD,OAAL,CAAaoD,OAAS;;IAC1C;AACJ;AACA;AACA;AACA;IACI,KAAKjB,IAAL,CAAU,OAAV,EAAmB,KAAK1B,OAAL,IAAgB,KAAKQ,MAAxC;IAEA,KAAKD,KAAL,GAAa,KAAb;IACA,KAAKP,OAAL,GAAe,IAAf;IACA,KAAKQ,MAAL,GAAc,IAAd;;IACA,KAAKC,MAAL,CAAYe,KAAZ;;IACA,KAAKb,QAAL,CAAca,KAAd;;IAEA,IAAImB,OAAJ,EAAa,KAAK3B,KAAL,GAAa2C,KAAb,CAAmBX,GAAG,IAAI,KAAKtB,IAAL,CAAU,OAAV,EAAmBsB,GAAnB,CAA1B;EACd;;AAjY8B;;AAoYjCmC,MAAM,CAACC,OAAP,GAAiB/F,KAAjB"},"metadata":{},"sourceType":"script"}