{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  TypeError\n} = require('../../errors');\n\nconst Util = require('../../util/Util');\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\n\n\nclass Collector extends EventEmitter {\n  constructor(client) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n\n    this.filter = options.filter ?? (() => true);\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n\n\n    this.options = options;\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n\n    this.collected = new Collection();\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n\n    this.ended = false;\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n\n    this._timeout = null;\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n\n    this._idletimeout = null;\n\n    if (typeof this.filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'options.filter', 'function');\n    }\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n  }\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n\n\n  async handleCollect() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const collect = await this.collect(...args);\n\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n\n      this.emit('collect', ...args);\n\n      if (this._idletimeout) {\n        clearTimeout(this._idletimeout);\n        this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n      }\n    }\n\n    this.checkEnd();\n  }\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n\n\n  async handleDispose() {\n    if (!this.options.dispose) return;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n\n\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n\n\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n    if (this.ended) return;\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n\n    this.ended = true;\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n\n    this.emit('end', this.collected, reason);\n  }\n  /**\n   * Options used to reset timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for reseting\n   */\n\n\n  resetTimer() {\n    let {\n      time,\n      idle\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n\n\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n\n\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n\n    const onCollect = item => queue.push(item);\n\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n  /* eslint-disable no-empty-function */\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   * @abstract\n   */\n\n\n  get endReason() {}\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n\n\n  collect() {}\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n\n\n  dispose() {}\n  /* eslint-enable no-empty-function */\n\n\n}\n\nmodule.exports = Collector;","map":{"version":3,"names":["EventEmitter","require","Collection","TypeError","Util","Collector","constructor","client","options","Object","defineProperty","value","filter","collected","ended","_timeout","_idletimeout","handleCollect","bind","handleDispose","time","setTimeout","stop","unref","idle","args","collect","set","emit","clearTimeout","checkEnd","dispose","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Boolean","Symbol","asyncIterator","queue","push","length","shift","tick","toJSON","flatten","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/interfaces/Collector.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst { Collection } = require('@discordjs/collection');\nconst { TypeError } = require('../../errors');\nconst Util = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    if (typeof this.filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'options.filter', 'function');\n    }\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collect = await this.collect(...args);\n\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n      this.emit('collect', ...args);\n\n      if (this._idletimeout) {\n        clearTimeout(this._idletimeout);\n        this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for reseting\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = item => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   * @abstract\n   */\n  get endReason() {}\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}