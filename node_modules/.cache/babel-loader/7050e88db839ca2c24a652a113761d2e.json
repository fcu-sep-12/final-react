{"ast":null,"code":"'use strict';\n\nconst {\n  Error\n} = require('../errors');\n\nconst {\n  Events\n} = require('../util/Constants');\n\nconst Util = require('../util/Util');\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\n\n\nclass ShardClientUtil {\n  /**\n   * @param {Client} client Client of the current shard\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   */\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n\n    this.mode = mode;\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n\n    this.parentPort = null;\n\n    if (mode === 'process') {\n      process.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        process.send({\n          _ready: true\n        });\n      });\n      client.on('disconnect', () => {\n        process.send({\n          _disconnect: true\n        });\n      });\n      client.on('reconnecting', () => {\n        process.send({\n          _reconnecting: true\n        });\n      });\n    } else if (mode === 'worker') {\n      this.parentPort = require('worker_threads').parentPort;\n      this.parentPort.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        this.parentPort.postMessage({\n          _ready: true\n        });\n      });\n      client.on('disconnect', () => {\n        this.parentPort.postMessage({\n          _disconnect: true\n        });\n      });\n      client.on('reconnecting', () => {\n        this.parentPort.postMessage({\n          _reconnecting: true\n        });\n      });\n    }\n  }\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n\n\n  get ids() {\n    return this.client.options.shards;\n  }\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n\n\n  get count() {\n    return this.client.options.shardCount;\n  }\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n\n\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.mode === 'process') {\n        process.send(message, err => {\n          if (err) reject(err);else resolve();\n        });\n      } else if (this.mode === 'worker') {\n        this.parentPort.postMessage(message);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n\n\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        if (!message._error) resolve(message._result);else reject(Util.makeError(message._error));\n      };\n\n      parent.on('message', listener);\n      this.send({\n        _sFetchProp: prop,\n        _sFetchPropShard: shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n\n\n  broadcastEval(script) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n\n      if (typeof script !== 'function') {\n        reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n        return;\n      }\n\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        if (!message._error) resolve(message._result);else reject(Util.makeError(message._error));\n      };\n\n      parent.on('message', listener);\n      this.send({\n        _sEval: script,\n        _sEvalShard: options.shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n\n\n  respawnAll() {\n    let {\n      shardDelay = 5000,\n      respawnDelay = 500,\n      timeout = 30000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.send({\n      _sRespawnAll: {\n        shardDelay,\n        respawnDelay,\n        timeout\n      }\n    });\n  }\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n\n\n  async _handleMessage(message) {\n    if (!message) return;\n\n    if (message._fetchProp) {\n      const props = message._fetchProp.split('.');\n\n      let value = this.client;\n\n      for (const prop of props) value = value[prop];\n\n      this._respond('fetchProp', {\n        _fetchProp: message._fetchProp,\n        _result: value\n      });\n    } else if (message._eval) {\n      try {\n        this._respond('eval', {\n          _eval: message._eval,\n          _result: await this.client._eval(message._eval)\n        });\n      } catch (err) {\n        this._respond('eval', {\n          _eval: message._eval,\n          _error: Util.makePlainError(err)\n        });\n      }\n    }\n  }\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n\n\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n\n      this.client.emit(Events.ERROR, error);\n    });\n  }\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n\n\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(Events.WARN, 'Multiple clients created in child process/worker; only the first will handle sharding helpers.');\n    }\n\n    return this._singleton;\n  }\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n\n\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = Number(BigInt(guildId) >> 22n) % shardCount;\n    if (shard < 0) throw new Error('SHARDING_SHARD_MISCALCULATION', shard, guildId, shardCount);\n    return shard;\n  }\n\n}\n\nmodule.exports = ShardClientUtil;","map":{"version":3,"names":["Error","require","Events","Util","ShardClientUtil","constructor","client","mode","parentPort","process","on","_handleMessage","bind","send","_ready","_disconnect","_reconnecting","postMessage","ids","options","shards","count","shardCount","message","Promise","resolve","reject","err","fetchClientValues","prop","shard","parent","listener","_sFetchProp","_sFetchPropShard","removeListener","_error","_result","makeError","catch","broadcastEval","script","TypeError","JSON","stringify","context","_sEval","_sEvalShard","respawnAll","shardDelay","respawnDelay","timeout","_sRespawnAll","_fetchProp","props","split","value","_respond","_eval","makePlainError","type","error","stack","emit","ERROR","singleton","_singleton","WARN","shardIdForGuildId","guildId","Number","BigInt","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/sharding/ShardClientUtil.js"],"sourcesContent":["'use strict';\n\nconst { Error } = require('../errors');\nconst { Events } = require('../util/Constants');\nconst Util = require('../util/Util');\n\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\nclass ShardClientUtil {\n  /**\n   * @param {Client} client Client of the current shard\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   */\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = mode;\n\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n    this.parentPort = null;\n\n    if (mode === 'process') {\n      process.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        process.send({ _ready: true });\n      });\n      client.on('disconnect', () => {\n        process.send({ _disconnect: true });\n      });\n      client.on('reconnecting', () => {\n        process.send({ _reconnecting: true });\n      });\n    } else if (mode === 'worker') {\n      this.parentPort = require('worker_threads').parentPort;\n      this.parentPort.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        this.parentPort.postMessage({ _ready: true });\n      });\n      client.on('disconnect', () => {\n        this.parentPort.postMessage({ _disconnect: true });\n      });\n      client.on('reconnecting', () => {\n        this.parentPort.postMessage({ _reconnecting: true });\n      });\n    }\n  }\n\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n  get ids() {\n    return this.client.options.shards;\n  }\n\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n  get count() {\n    return this.client.options.shardCount;\n  }\n\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.mode === 'process') {\n        process.send(message, err => {\n          if (err) reject(err);\n          else resolve();\n        });\n      } else if (this.mode === 'worker') {\n        this.parentPort.postMessage(message);\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        if (!message._error) resolve(message._result);\n        else reject(Util.makeError(message._error));\n      };\n      parent.on('message', listener);\n\n      this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch(err => {\n        parent.removeListener('message', listener);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n  broadcastEval(script, options = {}) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      if (typeof script !== 'function') {\n        reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n        return;\n      }\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        if (!message._error) resolve(message._result);\n        else reject(Util.makeError(message._error));\n      };\n      parent.on('message', listener);\n\n      this.send({ _sEval: script, _sEvalShard: options.shard }).catch(err => {\n        parent.removeListener('message', listener);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n  respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {\n    return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });\n  }\n\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n  async _handleMessage(message) {\n    if (!message) return;\n    if (message._fetchProp) {\n      const props = message._fetchProp.split('.');\n      let value = this.client;\n      for (const prop of props) value = value[prop];\n      this._respond('fetchProp', { _fetchProp: message._fetchProp, _result: value });\n    } else if (message._eval) {\n      try {\n        this._respond('eval', { _eval: message._eval, _result: await this.client._eval(message._eval) });\n      } catch (err) {\n        this._respond('eval', { _eval: message._eval, _error: Util.makePlainError(err) });\n      }\n    }\n  }\n\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n      this.client.emit(Events.ERROR, error);\n    });\n  }\n\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(\n        Events.WARN,\n        'Multiple clients created in child process/worker; only the first will handle sharding helpers.',\n      );\n    }\n    return this._singleton;\n  }\n\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = Number(BigInt(guildId) >> 22n) % shardCount;\n    if (shard < 0) throw new Error('SHARDING_SHARD_MISCALCULATION', shard, guildId, shardCount);\n    return shard;\n  }\n}\n\nmodule.exports = ShardClientUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}