{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst BaseGuildEmojiManager = require('./BaseGuildEmojiManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst DataResolver = require('../util/DataResolver');\n/**\n * Manages API methods for GuildEmojis and stores their cache.\n * @extends {BaseGuildEmojiManager}\n */\n\n\nclass GuildEmojiManager extends BaseGuildEmojiManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Options used for creating an emoji in a guild.\n   * @typedef {Object} GuildEmojiCreateOptions\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to\n   * @property {string} [reason] The reason for creating the emoji\n   */\n\n  /**\n   * Creates a new custom emoji in the guild.\n   * @param {BufferResolvable|Base64Resolvable} attachment The image for the emoji\n   * @param {string} name The name for the emoji\n   * @param {GuildEmojiCreateOptions} [options] Options for creating the emoji\n   * @returns {Promise<Emoji>} The created emoji\n   * @example\n   * // Create a new emoji from a url\n   * guild.emojis.create('https://i.imgur.com/w3duR07.png', 'rip')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new emoji from a file on your computer\n   * guild.emojis.create('./memes/banana.png', 'banana')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   */\n\n\n  async create(attachment, name) {\n    let {\n      roles,\n      reason\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    attachment = await DataResolver.resolveImage(attachment);\n    if (!attachment) throw new TypeError('REQ_RESOURCE_TYPE');\n    const data = {\n      image: attachment,\n      name\n    };\n\n    if (roles) {\n      if (!Array.isArray(roles) && !(roles instanceof Collection)) {\n        throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      data.roles = [];\n\n      for (const role of roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'options.roles', role);\n        data.roles.push(resolvedRole);\n      }\n    }\n\n    const emoji = await this.client.api.guilds(this.guild.id).emojis.post({\n      data,\n      reason\n    });\n    return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;\n  }\n  /**\n   * Obtains one or more emojis from Discord, or the emoji cache if they're already available.\n   * @param {Snowflake} [id] The emoji's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}\n   * @example\n   * // Fetch all emojis from the guild\n   * message.guild.emojis.fetch()\n   *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single emoji\n   * message.guild.emojis.fetch('222078108977594368')\n   *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const emoji = await this.client.api.guilds(this.guild.id).emojis(id).get();\n      return this._add(emoji, cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).emojis.get();\n    const emojis = new Collection();\n\n    for (const emoji of data) emojis.set(emoji.id, this._add(emoji, cache));\n\n    return emojis;\n  }\n\n}\n\nmodule.exports = GuildEmojiManager;","map":{"version":3,"names":["Collection","require","BaseGuildEmojiManager","TypeError","DataResolver","GuildEmojiManager","constructor","guild","iterable","client","_add","data","cache","extras","create","attachment","name","roles","reason","resolveImage","image","Array","isArray","role","values","resolvedRole","resolveId","push","emoji","api","guilds","id","emojis","post","actions","GuildEmojiCreate","handle","fetch","force","existing","get","set","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/GuildEmojiManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst BaseGuildEmojiManager = require('./BaseGuildEmojiManager');\nconst { TypeError } = require('../errors');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildEmojis and stores their cache.\n * @extends {BaseGuildEmojiManager}\n */\nclass GuildEmojiManager extends BaseGuildEmojiManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options used for creating an emoji in a guild.\n   * @typedef {Object} GuildEmojiCreateOptions\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to\n   * @property {string} [reason] The reason for creating the emoji\n   */\n\n  /**\n   * Creates a new custom emoji in the guild.\n   * @param {BufferResolvable|Base64Resolvable} attachment The image for the emoji\n   * @param {string} name The name for the emoji\n   * @param {GuildEmojiCreateOptions} [options] Options for creating the emoji\n   * @returns {Promise<Emoji>} The created emoji\n   * @example\n   * // Create a new emoji from a url\n   * guild.emojis.create('https://i.imgur.com/w3duR07.png', 'rip')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new emoji from a file on your computer\n   * guild.emojis.create('./memes/banana.png', 'banana')\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   */\n  async create(attachment, name, { roles, reason } = {}) {\n    attachment = await DataResolver.resolveImage(attachment);\n    if (!attachment) throw new TypeError('REQ_RESOURCE_TYPE');\n\n    const data = { image: attachment, name };\n    if (roles) {\n      if (!Array.isArray(roles) && !(roles instanceof Collection)) {\n        throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      data.roles = [];\n      for (const role of roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) throw new TypeError('INVALID_ELEMENT', 'Array or Collection', 'options.roles', role);\n        data.roles.push(resolvedRole);\n      }\n    }\n\n    const emoji = await this.client.api.guilds(this.guild.id).emojis.post({ data, reason });\n    return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;\n  }\n\n  /**\n   * Obtains one or more emojis from Discord, or the emoji cache if they're already available.\n   * @param {Snowflake} [id] The emoji's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}\n   * @example\n   * // Fetch all emojis from the guild\n   * message.guild.emojis.fetch()\n   *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single emoji\n   * message.guild.emojis.fetch('222078108977594368')\n   *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const emoji = await this.client.api.guilds(this.guild.id).emojis(id).get();\n      return this._add(emoji, cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).emojis.get();\n    const emojis = new Collection();\n    for (const emoji of data) emojis.set(emoji.id, this._add(emoji, cache));\n    return emojis;\n  }\n}\n\nmodule.exports = GuildEmojiManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}