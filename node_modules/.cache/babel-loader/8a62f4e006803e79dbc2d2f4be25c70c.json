{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst BaseManager = require('./BaseManager');\n\nconst {\n  Error,\n  TypeError\n} = require('../errors');\n\nconst {\n  ApplicationCommandPermissionTypes,\n  APIErrors\n} = require('../util/Constants');\n/**\n * Manages API methods for permissions of Application Commands.\n * @extends {BaseManager}\n */\n\n\nclass ApplicationCommandPermissionsManager extends BaseManager {\n  constructor(manager) {\n    super(manager.client);\n    /**\n     * The manager or command that this manager belongs to\n     * @type {ApplicationCommandManager|ApplicationCommand}\n     * @private\n     */\n\n    this.manager = manager;\n    /**\n     * The guild that this manager acts on\n     * @type {?Guild}\n     */\n\n    this.guild = manager.guild ?? null;\n    /**\n     * The id of the guild that this manager acts on\n     * @type {?Snowflake}\n     */\n\n    this.guildId = manager.guildId ?? manager.guild?.id ?? null;\n    /**\n     * The id of the command this manager acts on\n     * @type {?Snowflake}\n     */\n\n    this.commandId = manager.id ?? null;\n  }\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} guildId The guild's id to use in the path,\n   * @param {Snowflake} [commandId] The application command's id\n   * @returns {Object}\n   * @private\n   */\n\n\n  permissionsPath(guildId, commandId) {\n    return this.client.api.applications(this.client.application.id).guilds(guildId).commands(commandId).permissions;\n  }\n  /**\n   * Data for setting the permissions of an application command.\n   * @typedef {Object} ApplicationCommandPermissionData\n   * @property {Snowflake} id The role or user's id\n   * @property {ApplicationCommandPermissionType|number} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n\n  /**\n   * The object returned when fetching permissions for an application command.\n   * @typedef {Object} ApplicationCommandPermissions\n   * @property {Snowflake} id The role or user's id\n   * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n\n  /**\n   * Options for managing permissions for one or more Application Commands\n   * <warn>When passing these options to a manager where `guildId` is `null`,\n   * `guild` is a required parameter</warn>\n   * @typedef {Object} BaseApplicationCommandPermissionsOptions\n   * @param {GuildResolvable} [guild] The guild to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `guildId` property</warn>\n   * @param {ApplicationCommandResolvable} [command] The command to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `commandId` property</warn>\n   */\n\n  /**\n   * Fetches the permissions for one or multiple commands.\n   * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Fetch permissions for one command\n   * guild.commands.permissions.fetch({ command: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.length} users`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch permissions for all commands in a guild\n   * client.application.commands.permissions.fetch({ guild: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch() {\n    let {\n      guild,\n      command\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n\n    if (commandId) {\n      const data = await this.permissionsPath(guildId, commandId).get();\n      return data.permissions.map(perm => this.constructor.transformPermissions(perm, true));\n    }\n\n    const data = await this.permissionsPath(guildId).get();\n    return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions.map(p => this.constructor.transformPermissions(p, true))), new Collection());\n  }\n  /**\n   * Data used for overwriting the permissions for all application commands in a guild.\n   * @typedef {Object} GuildApplicationCommandPermissionData\n   * @property {Snowflake} id The command's id\n   * @property {ApplicationCommandPermissionData[]} permissions The permissions for this command\n   */\n\n  /**\n   * Options used to set permissions for one or more Application Commands in a guild\n   * <warn>One of `command` AND `permissions`, OR `fullPermissions` is required.\n   * `fullPermissions` is not a valid option when passing to a manager where `commandId` is non-null</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} SetApplicationCommandPermissionsOptions\n   * @param {ApplicationCommandPermissionData[]} [permissions] The new permissions for the command\n   * @param {GuildApplicationCommandPermissionData[]} [fullPermissions] The new permissions for all commands\n   * in a guild <warn>When this parameter is set, `permissions` and `command` are ignored</warn>\n   */\n\n  /**\n   * Sets the permissions for one or more commands.\n   * @param {SetApplicationCommandPermissionsOptions} options Options used to set permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Set the permissions for one command\n   * client.application.commands.permissions.set({ command: '123456789012345678', permissions: [\n   *   {\n   *     id: '876543210987654321',\n   *     type: 'USER',\n   *     permission: false,\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Set the permissions for all commands\n   * guild.commands.permissions.set({ fullPermissions: [\n   *   {\n   *     id: '123456789012345678',\n   *     permissions: [{\n   *       id: '876543210987654321',\n   *       type: 'USER',\n   *       permission: false,\n   *     }],\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async set() {\n    let {\n      guild,\n      command,\n      permissions,\n      fullPermissions\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n\n    if (commandId) {\n      if (!Array.isArray(permissions)) {\n        throw new TypeError('INVALID_TYPE', 'permissions', 'Array of ApplicationCommandPermissionData', true);\n      }\n\n      const data = await this.permissionsPath(guildId, commandId).put({\n        data: {\n          permissions: permissions.map(perm => this.constructor.transformPermissions(perm))\n        }\n      });\n      return data.permissions.map(perm => this.constructor.transformPermissions(perm, true));\n    }\n\n    if (!Array.isArray(fullPermissions)) {\n      throw new TypeError('INVALID_TYPE', 'fullPermissions', 'Array of GuildApplicationCommandPermissionData', true);\n    }\n\n    const APIPermissions = [];\n\n    for (const perm of fullPermissions) {\n      if (!Array.isArray(perm.permissions)) throw new TypeError('INVALID_ELEMENT', 'Array', 'fullPermissions', perm);\n      APIPermissions.push({\n        id: perm.id,\n        permissions: perm.permissions.map(p => this.constructor.transformPermissions(p))\n      });\n    }\n\n    const data = await this.permissionsPath(guildId).put({\n      data: APIPermissions\n    });\n    return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions.map(p => this.constructor.transformPermissions(p, true))), new Collection());\n  }\n  /**\n   * Options used to add permissions to a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} AddApplicationCommandPermissionsOptions\n   * @param {ApplicationCommandPermissionData[]} permissions The permissions to add to the command\n   */\n\n  /**\n   * Add permissions to a command.\n   * @param {AddApplicationCommandPermissionsOptions} options Options used to add permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Block a role from the command permissions\n   * guild.commands.permissions.add({ command: '123456789012345678', permissions: [\n   *   {\n   *     id: '876543211234567890',\n   *     type: 'ROLE',\n   *     permission: false\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async add(_ref) {\n    let {\n      guild,\n      command,\n      permissions\n    } = _ref;\n\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n\n    if (!Array.isArray(permissions)) {\n      throw new TypeError('INVALID_TYPE', 'permissions', 'Array of ApplicationCommandPermissionData', true);\n    }\n\n    let existing = [];\n\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    const newPermissions = permissions.slice();\n\n    for (const perm of existing) {\n      if (!newPermissions.some(x => x.id === perm.id)) {\n        newPermissions.push(perm);\n      }\n    }\n\n    return this.set({\n      guild: guildId,\n      command: commandId,\n      permissions: newPermissions\n    });\n  }\n  /**\n   * Options used to remove permissions from a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions\n   * @param {UserResolvable|UserResolvable[]} [users] The user(s) to remove from the command permissions\n   * <warn>One of `users` or `roles` is required</warn>\n   * @param {RoleResolvable|RoleResolvable[]} [roles] The role(s) to remove from the command permissions\n   * <warn>One of `users` or `roles` is required</warn>\n   */\n\n  /**\n   * Remove permissions from a command.\n   * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Remove a user permission from this command\n   * guild.commands.permissions.remove({ command: '123456789012345678', users: '876543210123456789' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove multiple roles from this command\n   * guild.commands.permissions.remove({\n   *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890']\n   * })\n   *    .then(console.log)\n   *    .catch(console.error);\n   */\n\n\n  async remove(_ref2) {\n    let {\n      guild,\n      command,\n      users,\n      roles\n    } = _ref2;\n\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n    if (!users && !roles) throw new TypeError('INVALID_TYPE', 'users OR roles', 'Array or Resolvable', true);\n    let resolvedIds = [];\n\n    if (Array.isArray(users)) {\n      users.forEach(user => {\n        const userId = this.client.users.resolveId(user);\n        if (!userId) throw new TypeError('INVALID_ELEMENT', 'Array', 'users', user);\n        resolvedIds.push(userId);\n      });\n    } else if (users) {\n      const userId = this.client.users.resolveId(users);\n\n      if (!userId) {\n        throw new TypeError('INVALID_TYPE', 'users', 'Array or UserResolvable');\n      }\n\n      resolvedIds.push(userId);\n    }\n\n    if (Array.isArray(roles)) {\n      roles.forEach(role => {\n        if (typeof role === 'string') {\n          resolvedIds.push(role);\n          return;\n        }\n\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        const roleId = this.guild.roles.resolveId(role);\n        if (!roleId) throw new TypeError('INVALID_ELEMENT', 'Array', 'users', role);\n        resolvedIds.push(roleId);\n      });\n    } else if (roles) {\n      if (typeof roles === 'string') {\n        resolvedIds.push(roles);\n      } else {\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        const roleId = this.guild.roles.resolveId(roles);\n\n        if (!roleId) {\n          throw new TypeError('INVALID_TYPE', 'users', 'Array or RoleResolvable');\n        }\n\n        resolvedIds.push(roleId);\n      }\n    }\n\n    let existing = [];\n\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    const permissions = existing.filter(perm => !resolvedIds.includes(perm.id));\n    return this.set({\n      guild: guildId,\n      command: commandId,\n      permissions\n    });\n  }\n  /**\n   * Options used to check existance of permissions on a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions\n   * @param {UserResolvable|RoleResolvable} permissionId The user or role to check if a permission exists for\n   * on this command.\n   */\n\n  /**\n   * Check whether a permission exists for a user or role\n   * @param {AddApplicationCommandPermissionsOptions} options Options used to check permissions\n   * @returns {Promise<boolean>}\n   * @example\n   * // Check whether a user has permission to use a command\n   * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })\n   *  .then(console.log)\n   *  .catch(console.error);\n   */\n\n\n  async has(_ref3) {\n    let {\n      guild,\n      command,\n      permissionId\n    } = _ref3;\n\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n    if (!permissionId) throw new TypeError('INVALID_TYPE', 'permissionId', 'UserResolvable or RoleResolvable');\n    let resolvedId = permissionId;\n\n    if (typeof permissionId !== 'string') {\n      resolvedId = this.client.users.resolveId(permissionId);\n\n      if (!resolvedId) {\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        resolvedId = this.guild.roles.resolveId(permissionId);\n      }\n\n      if (!resolvedId) {\n        throw new TypeError('INVALID_TYPE', 'permissionId', 'UserResolvable or RoleResolvable');\n      }\n    }\n\n    let existing = [];\n\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    return existing.some(perm => perm.id === resolvedId);\n  }\n\n  _validateOptions(guild, command) {\n    const guildId = this.guildId ?? this.client.guilds.resolveId(guild);\n    if (!guildId) throw new Error('GLOBAL_COMMAND_PERMISSIONS');\n    let commandId = this.commandId;\n\n    if (command && !commandId) {\n      commandId = this.manager.resolveId?.(command);\n\n      if (!commandId && this.guild) {\n        commandId = this.guild.commands.resolveId(command);\n      }\n\n      if (!commandId) {\n        commandId = this.client.application?.commands.resolveId(command);\n      }\n\n      if (!commandId) {\n        throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable', true);\n      }\n    }\n\n    return {\n      guildId,\n      commandId\n    };\n  }\n  /**\n   * Transforms an {@link ApplicationCommandPermissionData} object into something that can be used with the API.\n   * @param {ApplicationCommandPermissionData} permissions The permissions to transform\n   * @param {boolean} [received] Whether these permissions have been received from Discord\n   * @returns {APIApplicationCommandPermissions}\n   * @private\n   */\n\n\n  static transformPermissions(permissions, received) {\n    return {\n      id: permissions.id,\n      permission: permissions.permission,\n      type: typeof permissions.type === 'number' && !received ? permissions.type : ApplicationCommandPermissionTypes[permissions.type]\n    };\n  }\n\n}\n\nmodule.exports = ApplicationCommandPermissionsManager;\n/* eslint-disable max-len */\n\n/**\n * @external APIApplicationCommandPermissions\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-structure}\n */","map":{"version":3,"names":["Collection","require","BaseManager","Error","TypeError","ApplicationCommandPermissionTypes","APIErrors","ApplicationCommandPermissionsManager","constructor","manager","client","guild","guildId","id","commandId","permissionsPath","api","applications","application","guilds","commands","permissions","fetch","command","_validateOptions","data","get","map","perm","transformPermissions","reduce","coll","set","p","fullPermissions","Array","isArray","put","APIPermissions","push","add","existing","error","code","UNKNOWN_APPLICATION_COMMAND_PERMISSIONS","newPermissions","slice","some","x","remove","users","roles","resolvedIds","forEach","user","userId","resolveId","role","roleId","filter","includes","has","permissionId","resolvedId","received","permission","type","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst BaseManager = require('./BaseManager');\nconst { Error, TypeError } = require('../errors');\nconst { ApplicationCommandPermissionTypes, APIErrors } = require('../util/Constants');\n\n/**\n * Manages API methods for permissions of Application Commands.\n * @extends {BaseManager}\n */\nclass ApplicationCommandPermissionsManager extends BaseManager {\n  constructor(manager) {\n    super(manager.client);\n\n    /**\n     * The manager or command that this manager belongs to\n     * @type {ApplicationCommandManager|ApplicationCommand}\n     * @private\n     */\n    this.manager = manager;\n\n    /**\n     * The guild that this manager acts on\n     * @type {?Guild}\n     */\n    this.guild = manager.guild ?? null;\n\n    /**\n     * The id of the guild that this manager acts on\n     * @type {?Snowflake}\n     */\n    this.guildId = manager.guildId ?? manager.guild?.id ?? null;\n\n    /**\n     * The id of the command this manager acts on\n     * @type {?Snowflake}\n     */\n    this.commandId = manager.id ?? null;\n  }\n\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} guildId The guild's id to use in the path,\n   * @param {Snowflake} [commandId] The application command's id\n   * @returns {Object}\n   * @private\n   */\n  permissionsPath(guildId, commandId) {\n    return this.client.api.applications(this.client.application.id).guilds(guildId).commands(commandId).permissions;\n  }\n\n  /**\n   * Data for setting the permissions of an application command.\n   * @typedef {Object} ApplicationCommandPermissionData\n   * @property {Snowflake} id The role or user's id\n   * @property {ApplicationCommandPermissionType|number} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n\n  /**\n   * The object returned when fetching permissions for an application command.\n   * @typedef {Object} ApplicationCommandPermissions\n   * @property {Snowflake} id The role or user's id\n   * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n\n  /**\n   * Options for managing permissions for one or more Application Commands\n   * <warn>When passing these options to a manager where `guildId` is `null`,\n   * `guild` is a required parameter</warn>\n   * @typedef {Object} BaseApplicationCommandPermissionsOptions\n   * @param {GuildResolvable} [guild] The guild to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `guildId` property</warn>\n   * @param {ApplicationCommandResolvable} [command] The command to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `commandId` property</warn>\n   */\n\n  /**\n   * Fetches the permissions for one or multiple commands.\n   * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Fetch permissions for one command\n   * guild.commands.permissions.fetch({ command: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.length} users`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch permissions for all commands in a guild\n   * client.application.commands.permissions.fetch({ guild: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))\n   *   .catch(console.error);\n   */\n  async fetch({ guild, command } = {}) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (commandId) {\n      const data = await this.permissionsPath(guildId, commandId).get();\n      return data.permissions.map(perm => this.constructor.transformPermissions(perm, true));\n    }\n\n    const data = await this.permissionsPath(guildId).get();\n    return data.reduce(\n      (coll, perm) =>\n        coll.set(\n          perm.id,\n          perm.permissions.map(p => this.constructor.transformPermissions(p, true)),\n        ),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Data used for overwriting the permissions for all application commands in a guild.\n   * @typedef {Object} GuildApplicationCommandPermissionData\n   * @property {Snowflake} id The command's id\n   * @property {ApplicationCommandPermissionData[]} permissions The permissions for this command\n   */\n\n  /**\n   * Options used to set permissions for one or more Application Commands in a guild\n   * <warn>One of `command` AND `permissions`, OR `fullPermissions` is required.\n   * `fullPermissions` is not a valid option when passing to a manager where `commandId` is non-null</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} SetApplicationCommandPermissionsOptions\n   * @param {ApplicationCommandPermissionData[]} [permissions] The new permissions for the command\n   * @param {GuildApplicationCommandPermissionData[]} [fullPermissions] The new permissions for all commands\n   * in a guild <warn>When this parameter is set, `permissions` and `command` are ignored</warn>\n   */\n\n  /**\n   * Sets the permissions for one or more commands.\n   * @param {SetApplicationCommandPermissionsOptions} options Options used to set permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Set the permissions for one command\n   * client.application.commands.permissions.set({ command: '123456789012345678', permissions: [\n   *   {\n   *     id: '876543210987654321',\n   *     type: 'USER',\n   *     permission: false,\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Set the permissions for all commands\n   * guild.commands.permissions.set({ fullPermissions: [\n   *   {\n   *     id: '123456789012345678',\n   *     permissions: [{\n   *       id: '876543210987654321',\n   *       type: 'USER',\n   *       permission: false,\n   *     }],\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async set({ guild, command, permissions, fullPermissions } = {}) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n\n    if (commandId) {\n      if (!Array.isArray(permissions)) {\n        throw new TypeError('INVALID_TYPE', 'permissions', 'Array of ApplicationCommandPermissionData', true);\n      }\n      const data = await this.permissionsPath(guildId, commandId).put({\n        data: { permissions: permissions.map(perm => this.constructor.transformPermissions(perm)) },\n      });\n      return data.permissions.map(perm => this.constructor.transformPermissions(perm, true));\n    }\n\n    if (!Array.isArray(fullPermissions)) {\n      throw new TypeError('INVALID_TYPE', 'fullPermissions', 'Array of GuildApplicationCommandPermissionData', true);\n    }\n\n    const APIPermissions = [];\n    for (const perm of fullPermissions) {\n      if (!Array.isArray(perm.permissions)) throw new TypeError('INVALID_ELEMENT', 'Array', 'fullPermissions', perm);\n      APIPermissions.push({\n        id: perm.id,\n        permissions: perm.permissions.map(p => this.constructor.transformPermissions(p)),\n      });\n    }\n    const data = await this.permissionsPath(guildId).put({\n      data: APIPermissions,\n    });\n    return data.reduce(\n      (coll, perm) =>\n        coll.set(\n          perm.id,\n          perm.permissions.map(p => this.constructor.transformPermissions(p, true)),\n        ),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Options used to add permissions to a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} AddApplicationCommandPermissionsOptions\n   * @param {ApplicationCommandPermissionData[]} permissions The permissions to add to the command\n   */\n\n  /**\n   * Add permissions to a command.\n   * @param {AddApplicationCommandPermissionsOptions} options Options used to add permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Block a role from the command permissions\n   * guild.commands.permissions.add({ command: '123456789012345678', permissions: [\n   *   {\n   *     id: '876543211234567890',\n   *     type: 'ROLE',\n   *     permission: false\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async add({ guild, command, permissions }) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n    if (!Array.isArray(permissions)) {\n      throw new TypeError('INVALID_TYPE', 'permissions', 'Array of ApplicationCommandPermissionData', true);\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    const newPermissions = permissions.slice();\n    for (const perm of existing) {\n      if (!newPermissions.some(x => x.id === perm.id)) {\n        newPermissions.push(perm);\n      }\n    }\n\n    return this.set({ guild: guildId, command: commandId, permissions: newPermissions });\n  }\n\n  /**\n   * Options used to remove permissions from a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions\n   * @param {UserResolvable|UserResolvable[]} [users] The user(s) to remove from the command permissions\n   * <warn>One of `users` or `roles` is required</warn>\n   * @param {RoleResolvable|RoleResolvable[]} [roles] The role(s) to remove from the command permissions\n   * <warn>One of `users` or `roles` is required</warn>\n   */\n\n  /**\n   * Remove permissions from a command.\n   * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Remove a user permission from this command\n   * guild.commands.permissions.remove({ command: '123456789012345678', users: '876543210123456789' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove multiple roles from this command\n   * guild.commands.permissions.remove({\n   *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890']\n   * })\n   *    .then(console.log)\n   *    .catch(console.error);\n   */\n  async remove({ guild, command, users, roles }) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n\n    if (!users && !roles) throw new TypeError('INVALID_TYPE', 'users OR roles', 'Array or Resolvable', true);\n\n    let resolvedIds = [];\n    if (Array.isArray(users)) {\n      users.forEach(user => {\n        const userId = this.client.users.resolveId(user);\n        if (!userId) throw new TypeError('INVALID_ELEMENT', 'Array', 'users', user);\n        resolvedIds.push(userId);\n      });\n    } else if (users) {\n      const userId = this.client.users.resolveId(users);\n      if (!userId) {\n        throw new TypeError('INVALID_TYPE', 'users', 'Array or UserResolvable');\n      }\n      resolvedIds.push(userId);\n    }\n\n    if (Array.isArray(roles)) {\n      roles.forEach(role => {\n        if (typeof role === 'string') {\n          resolvedIds.push(role);\n          return;\n        }\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        const roleId = this.guild.roles.resolveId(role);\n        if (!roleId) throw new TypeError('INVALID_ELEMENT', 'Array', 'users', role);\n        resolvedIds.push(roleId);\n      });\n    } else if (roles) {\n      if (typeof roles === 'string') {\n        resolvedIds.push(roles);\n      } else {\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        const roleId = this.guild.roles.resolveId(roles);\n        if (!roleId) {\n          throw new TypeError('INVALID_TYPE', 'users', 'Array or RoleResolvable');\n        }\n        resolvedIds.push(roleId);\n      }\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    const permissions = existing.filter(perm => !resolvedIds.includes(perm.id));\n\n    return this.set({ guild: guildId, command: commandId, permissions });\n  }\n\n  /**\n   * Options used to check existance of permissions on a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions\n   * @param {UserResolvable|RoleResolvable} permissionId The user or role to check if a permission exists for\n   * on this command.\n   */\n\n  /**\n   * Check whether a permission exists for a user or role\n   * @param {AddApplicationCommandPermissionsOptions} options Options used to check permissions\n   * @returns {Promise<boolean>}\n   * @example\n   * // Check whether a user has permission to use a command\n   * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })\n   *  .then(console.log)\n   *  .catch(console.error);\n   */\n  async has({ guild, command, permissionId }) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable');\n\n    if (!permissionId) throw new TypeError('INVALID_TYPE', 'permissionId', 'UserResolvable or RoleResolvable');\n    let resolvedId = permissionId;\n    if (typeof permissionId !== 'string') {\n      resolvedId = this.client.users.resolveId(permissionId);\n      if (!resolvedId) {\n        if (!this.guild) throw new Error('GUILD_UNCACHED_ROLE_RESOLVE');\n        resolvedId = this.guild.roles.resolveId(permissionId);\n      }\n      if (!resolvedId) {\n        throw new TypeError('INVALID_TYPE', 'permissionId', 'UserResolvable or RoleResolvable');\n      }\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error;\n    }\n\n    return existing.some(perm => perm.id === resolvedId);\n  }\n\n  _validateOptions(guild, command) {\n    const guildId = this.guildId ?? this.client.guilds.resolveId(guild);\n    if (!guildId) throw new Error('GLOBAL_COMMAND_PERMISSIONS');\n    let commandId = this.commandId;\n    if (command && !commandId) {\n      commandId = this.manager.resolveId?.(command);\n      if (!commandId && this.guild) {\n        commandId = this.guild.commands.resolveId(command);\n      }\n      if (!commandId) {\n        commandId = this.client.application?.commands.resolveId(command);\n      }\n      if (!commandId) {\n        throw new TypeError('INVALID_TYPE', 'command', 'ApplicationCommandResolvable', true);\n      }\n    }\n    return { guildId, commandId };\n  }\n\n  /**\n   * Transforms an {@link ApplicationCommandPermissionData} object into something that can be used with the API.\n   * @param {ApplicationCommandPermissionData} permissions The permissions to transform\n   * @param {boolean} [received] Whether these permissions have been received from Discord\n   * @returns {APIApplicationCommandPermissions}\n   * @private\n   */\n  static transformPermissions(permissions, received) {\n    return {\n      id: permissions.id,\n      permission: permissions.permission,\n      type:\n        typeof permissions.type === 'number' && !received\n          ? permissions.type\n          : ApplicationCommandPermissionTypes[permissions.type],\n    };\n  }\n}\n\nmodule.exports = ApplicationCommandPermissionsManager;\n\n/* eslint-disable max-len */\n/**\n * @external APIApplicationCommandPermissions\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-structure}\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}