{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  _cleanupSymbol\n} = require('./Constants.js');\n\nconst {\n  TypeError\n} = require('../errors/DJSError.js');\n/**\n * @typedef {Function} SweepFilter\n * @param {LimitedCollection} collection The collection being swept\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * Options for defining the behavior of a LimitedCollection\n * @typedef {Object} LimitedCollectionOptions\n * @property {?number} [maxSize=Infinity] The maximum size of the Collection\n * @property {?Function} [keepOverLimit=null] A function, which is passed the value and key of an entry, ran to decide\n * to keep an entry past the maximum size\n * @property {?SweepFilter} [sweepFilter=null] A function ran every `sweepInterval` to determine how to sweep\n * @property {?number} [sweepInterval=0] How frequently, in seconds, to sweep the collection.\n */\n\n/**\n * A Collection which holds a max amount of entries and sweeps periodically.\n * @extends {Collection}\n * @param {LimitedCollectionOptions} [options={}] Options for constructing the Collection.\n * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.\n */\n\n\nclass LimitedCollection extends Collection {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    }\n\n    const {\n      maxSize = Infinity,\n      keepOverLimit = null,\n      sweepInterval = 0,\n      sweepFilter = null\n    } = options;\n\n    if (typeof maxSize !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'maxSize', 'number');\n    }\n\n    if (keepOverLimit !== null && typeof keepOverLimit !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'keepOverLimit', 'function');\n    }\n\n    if (typeof sweepInterval !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'sweepInterval', 'number');\n    }\n\n    if (sweepFilter !== null && typeof sweepFilter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'sweepFilter', 'function');\n    }\n\n    super(iterable);\n    /**\n     * The max size of the Collection.\n     * @type {number}\n     */\n\n    this.maxSize = maxSize;\n    /**\n     * A function called to check if an entry should be kept when the Collection is at max size.\n     * @type {?Function}\n     */\n\n    this.keepOverLimit = keepOverLimit;\n    /**\n     * A function called every sweep interval that returns a function passed to `sweep`.\n     * @type {?SweepFilter}\n     */\n\n    this.sweepFilter = sweepFilter;\n    /**\n     * The id of the interval being used to sweep.\n     * @type {?Timeout}\n     */\n\n    this.interval = sweepInterval > 0 && sweepInterval !== Infinity && sweepFilter ? setInterval(() => {\n      const sweepFn = this.sweepFilter(this);\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n      this.sweep(sweepFn);\n    }, sweepInterval * 1000).unref() : null;\n  }\n\n  set(key, value) {\n    if (this.maxSize === 0) return this;\n\n    if (this.size >= this.maxSize && !this.has(key)) {\n      for (const [k, v] of this.entries()) {\n        const keep = this.keepOverLimit?.(v, k, this) ?? false;\n\n        if (!keep) {\n          this.delete(k);\n          break;\n        }\n      }\n    }\n\n    return super.set(key, value);\n  }\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {SweepFilter}\n   */\n\n\n  static filterByLifetime() {\n    let {\n      lifetime = 14400,\n      getComparisonTimestamp = e => e?.createdTimestamp,\n      excludeFromSweep = () => false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof lifetime !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'getComparisonTimestamp', 'function');\n    }\n\n    if (typeof excludeFromSweep !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'excludeFromSweep', 'function');\n    }\n\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n\n  [_cleanupSymbol]() {\n    return this.interval ? () => clearInterval(this.interval) : null;\n  }\n\n  static get [Symbol.species]() {\n    return Collection;\n  }\n\n}\n\nmodule.exports = LimitedCollection;","map":{"version":3,"names":["Collection","require","_cleanupSymbol","TypeError","LimitedCollection","constructor","options","iterable","maxSize","Infinity","keepOverLimit","sweepInterval","sweepFilter","interval","setInterval","sweepFn","sweep","unref","set","key","value","size","has","k","v","entries","keep","delete","filterByLifetime","lifetime","getComparisonTimestamp","e","createdTimestamp","excludeFromSweep","lifetimeMs","now","Date","entry","coll","comparisonTimestamp","clearInterval","Symbol","species","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/util/LimitedCollection.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { _cleanupSymbol } = require('./Constants.js');\nconst { TypeError } = require('../errors/DJSError.js');\n\n/**\n * @typedef {Function} SweepFilter\n * @param {LimitedCollection} collection The collection being swept\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * Options for defining the behavior of a LimitedCollection\n * @typedef {Object} LimitedCollectionOptions\n * @property {?number} [maxSize=Infinity] The maximum size of the Collection\n * @property {?Function} [keepOverLimit=null] A function, which is passed the value and key of an entry, ran to decide\n * to keep an entry past the maximum size\n * @property {?SweepFilter} [sweepFilter=null] A function ran every `sweepInterval` to determine how to sweep\n * @property {?number} [sweepInterval=0] How frequently, in seconds, to sweep the collection.\n */\n\n/**\n * A Collection which holds a max amount of entries and sweeps periodically.\n * @extends {Collection}\n * @param {LimitedCollectionOptions} [options={}] Options for constructing the Collection.\n * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.\n */\nclass LimitedCollection extends Collection {\n  constructor(options = {}, iterable) {\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    }\n    const { maxSize = Infinity, keepOverLimit = null, sweepInterval = 0, sweepFilter = null } = options;\n\n    if (typeof maxSize !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'maxSize', 'number');\n    }\n    if (keepOverLimit !== null && typeof keepOverLimit !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'keepOverLimit', 'function');\n    }\n    if (typeof sweepInterval !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'sweepInterval', 'number');\n    }\n    if (sweepFilter !== null && typeof sweepFilter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'sweepFilter', 'function');\n    }\n\n    super(iterable);\n\n    /**\n     * The max size of the Collection.\n     * @type {number}\n     */\n    this.maxSize = maxSize;\n\n    /**\n     * A function called to check if an entry should be kept when the Collection is at max size.\n     * @type {?Function}\n     */\n    this.keepOverLimit = keepOverLimit;\n\n    /**\n     * A function called every sweep interval that returns a function passed to `sweep`.\n     * @type {?SweepFilter}\n     */\n    this.sweepFilter = sweepFilter;\n\n    /**\n     * The id of the interval being used to sweep.\n     * @type {?Timeout}\n     */\n    this.interval =\n      sweepInterval > 0 && sweepInterval !== Infinity && sweepFilter\n        ? setInterval(() => {\n            const sweepFn = this.sweepFilter(this);\n            if (sweepFn === null) return;\n            if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n            this.sweep(sweepFn);\n          }, sweepInterval * 1000).unref()\n        : null;\n  }\n\n  set(key, value) {\n    if (this.maxSize === 0) return this;\n    if (this.size >= this.maxSize && !this.has(key)) {\n      for (const [k, v] of this.entries()) {\n        const keep = this.keepOverLimit?.(v, k, this) ?? false;\n        if (!keep) {\n          this.delete(k);\n          break;\n        }\n      }\n    }\n    return super.set(key, value);\n  }\n\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {SweepFilter}\n   */\n  static filterByLifetime({\n    lifetime = 14400,\n    getComparisonTimestamp = e => e?.createdTimestamp,\n    excludeFromSweep = () => false,\n  } = {}) {\n    if (typeof lifetime !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'getComparisonTimestamp', 'function');\n    }\n    if (typeof excludeFromSweep !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'excludeFromSweep', 'function');\n    }\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n\n  [_cleanupSymbol]() {\n    return this.interval ? () => clearInterval(this.interval) : null;\n  }\n\n  static get [Symbol.species]() {\n    return Collection;\n  }\n}\n\nmodule.exports = LimitedCollection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}