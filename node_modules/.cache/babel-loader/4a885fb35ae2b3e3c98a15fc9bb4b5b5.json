{"ast":null,"code":"'use strict';\n\nconst {\n  Presence\n} = require('./Presence');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst {\n  ActivityTypes,\n  Opcodes\n} = require('../util/Constants');\n\nclass ClientPresence extends Presence {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIPresence} [data={}] The data for the client presence\n   */\n  constructor(client) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(client, Object.assign(data, {\n      status: data.status ?? 'online',\n      user: {\n        id: null\n      }\n    }));\n  }\n\n  set(presence) {\n    const packet = this._parse(presence);\n\n    this._patch(packet);\n\n    if (typeof presence.shardId === 'undefined') {\n      this.client.ws.broadcast({\n        op: Opcodes.STATUS_UPDATE,\n        d: packet\n      });\n    } else if (Array.isArray(presence.shardId)) {\n      for (const shardId of presence.shardId) {\n        this.client.ws.shards.get(shardId).send({\n          op: Opcodes.STATUS_UPDATE,\n          d: packet\n        });\n      }\n    } else {\n      this.client.ws.shards.get(presence.shardId).send({\n        op: Opcodes.STATUS_UPDATE,\n        d: packet\n      });\n    }\n\n    return this;\n  }\n\n  _parse(_ref) {\n    let {\n      status,\n      since,\n      afk,\n      activities\n    } = _ref;\n    const data = {\n      activities: [],\n      afk: typeof afk === 'boolean' ? afk : false,\n      since: typeof since === 'number' && !Number.isNaN(since) ? since : null,\n      status: status ?? this.status\n    };\n\n    if (activities?.length) {\n      for (const [i, activity] of activities.entries()) {\n        if (typeof activity.name !== 'string') throw new TypeError('INVALID_TYPE', `activities[${i}].name`, 'string');\n        if (!activity.type) activity.type = 0;\n        data.activities.push({\n          type: typeof activity.type === 'number' ? activity.type : ActivityTypes[activity.type],\n          name: activity.name,\n          url: activity.url\n        });\n      }\n    } else if (!activities && (status || afk || since) && this.activities.length) {\n      data.activities.push(...this.activities.map(a => ({\n        name: a.name,\n        type: ActivityTypes[a.type],\n        url: a.url ?? undefined\n      })));\n    }\n\n    return data;\n  }\n\n}\n\nmodule.exports = ClientPresence;","map":{"version":3,"names":["Presence","require","TypeError","ActivityTypes","Opcodes","ClientPresence","constructor","client","data","Object","assign","status","user","id","set","presence","packet","_parse","_patch","shardId","ws","broadcast","op","STATUS_UPDATE","d","Array","isArray","shards","get","send","since","afk","activities","Number","isNaN","length","i","activity","entries","name","type","push","url","map","a","undefined","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/ClientPresence.js"],"sourcesContent":["'use strict';\n\nconst { Presence } = require('./Presence');\nconst { TypeError } = require('../errors');\nconst { ActivityTypes, Opcodes } = require('../util/Constants');\n\nclass ClientPresence extends Presence {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIPresence} [data={}] The data for the client presence\n   */\n  constructor(client, data = {}) {\n    super(client, Object.assign(data, { status: data.status ?? 'online', user: { id: null } }));\n  }\n\n  set(presence) {\n    const packet = this._parse(presence);\n    this._patch(packet);\n    if (typeof presence.shardId === 'undefined') {\n      this.client.ws.broadcast({ op: Opcodes.STATUS_UPDATE, d: packet });\n    } else if (Array.isArray(presence.shardId)) {\n      for (const shardId of presence.shardId) {\n        this.client.ws.shards.get(shardId).send({ op: Opcodes.STATUS_UPDATE, d: packet });\n      }\n    } else {\n      this.client.ws.shards.get(presence.shardId).send({ op: Opcodes.STATUS_UPDATE, d: packet });\n    }\n    return this;\n  }\n\n  _parse({ status, since, afk, activities }) {\n    const data = {\n      activities: [],\n      afk: typeof afk === 'boolean' ? afk : false,\n      since: typeof since === 'number' && !Number.isNaN(since) ? since : null,\n      status: status ?? this.status,\n    };\n    if (activities?.length) {\n      for (const [i, activity] of activities.entries()) {\n        if (typeof activity.name !== 'string') throw new TypeError('INVALID_TYPE', `activities[${i}].name`, 'string');\n        if (!activity.type) activity.type = 0;\n\n        data.activities.push({\n          type: typeof activity.type === 'number' ? activity.type : ActivityTypes[activity.type],\n          name: activity.name,\n          url: activity.url,\n        });\n      }\n    } else if (!activities && (status || afk || since) && this.activities.length) {\n      data.activities.push(\n        ...this.activities.map(a => ({\n          name: a.name,\n          type: ActivityTypes[a.type],\n          url: a.url ?? undefined,\n        })),\n      );\n    }\n\n    return data;\n  }\n}\n\nmodule.exports = ClientPresence;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}