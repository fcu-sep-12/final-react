{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Base = require('./Base');\n\nconst BaseMessageComponent = require('./BaseMessageComponent');\n\nconst ClientApplication = require('./ClientApplication');\n\nconst InteractionCollector = require('./InteractionCollector');\n\nconst MessageAttachment = require('./MessageAttachment');\n\nconst Embed = require('./MessageEmbed');\n\nconst Mentions = require('./MessageMentions');\n\nconst MessagePayload = require('./MessagePayload');\n\nconst ReactionCollector = require('./ReactionCollector');\n\nconst Sticker = require('./Sticker');\n\nconst {\n  Error\n} = require('../errors');\n\nconst ReactionManager = require('../managers/ReactionManager');\n\nconst {\n  InteractionTypes,\n  MessageTypes,\n  SystemMessageTypes\n} = require('../util/Constants');\n\nconst MessageFlags = require('../util/MessageFlags');\n\nconst Permissions = require('../util/Permissions');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\nconst Util = require('../util/Util');\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\n\n\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIMessage} data The data for the message\n   */\n  constructor(client, data) {\n    super(client);\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n\n    this.channelId = data.channel_id;\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n\n      this.system = SystemMessageTypes.includes(this.type);\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n\n    if (!partial) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = 'nonce' in data ? data.nonce : null;\n    }\n\n    if ('embeds' in data || !partial) {\n      /**\n       * A list of embeds in the message - e.g. YouTube Player\n       * @type {MessageEmbed[]}\n       */\n      this.embeds = data.embeds?.map(e => new Embed(e, true)) ?? [];\n    } else {\n      this.embeds = this.embeds.slice();\n    }\n\n    if ('components' in data || !partial) {\n      /**\n       * A list of MessageActionRows in the message\n       * @type {MessageActionRow[]}\n       */\n      this.components = data.components?.map(c => BaseMessageComponent.create(c, this.client)) ?? [];\n    } else {\n      this.components = this.components.slice();\n    }\n\n    if ('attachments' in data || !partial) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids\n       * @type {Collection<Snowflake, MessageAttachment>}\n       */\n      this.attachments = new Collection();\n\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachemnts);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data || !partial) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]));\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n\n    if (!partial) {\n      /**\n       * The timestamp the message was sent at\n       * @type {number}\n       */\n      this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n    }\n\n    if ('edited_timestamp' in data || !partial) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;\n    }\n\n    if ('reactions' in data || !partial) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    }\n\n    if (!partial) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);\n    } else {\n      this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);\n    }\n\n    if ('webhook_id' in data || !partial) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id ?? null;\n    }\n\n    if ('application' in data || !partial) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = data.application ? new ClientApplication(this.client, data.application) : null;\n    }\n\n    if ('application_id' in data || !partial) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id ?? null;\n    }\n\n    if ('activity' in data || !partial) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = data.activity ? {\n        partyId: data.activity.party_id,\n        type: data.activity.type\n      } : null;\n    }\n\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n\n    if ('flags' in data || !partial) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlags>}\n       */\n      this.flags = new MessageFlags(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlags(this.flags).freeze();\n    }\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n\n    if ('message_reference' in data || !partial) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = data.message_reference ? {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id\n      } : null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({\n        guild_id: data.message_reference?.guild_id,\n        ...data.referenced_message\n      });\n    }\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command\n     * @property {User} user The user that invoked the interaction\n     */\n\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: InteractionTypes[data.interaction.type],\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user)\n      };\n    } else if (!this.interaction) {\n      this.interaction = null;\n    }\n  }\n\n  _update(data) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const clone = this._clone();\n\n    this._patch(data, partial);\n\n    return clone;\n  }\n  /**\n   * The channel that the message was sent in\n   * @type {TextChannel|DMChannel|NewsChannel|ThreadChannel}\n   * @readonly\n   */\n\n\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get hasThread() {\n    return this.flags.has(MessageFlags.FLAGS.HAS_THREAD);\n  }\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n\n\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return `https://discord.com/channels/${this.guildId ?? '@me'}/${this.channelId}/${this.id}`;\n  }\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this.channel) : null;\n  }\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createReactionCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new ReactionCollector(this, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n\n\n  awaitReactions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {MessageComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageComponentCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new InteractionCollector(this.client, { ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      message: this\n    });\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {MessageComponentType} [componentType] The type of component interaction to collect\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n\n\n  awaitMessageComponent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const _options = { ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return Boolean(!this.deleted && (this.author.id === this.client.user.id || this.channel.permissionsFor?.(this.client.user)?.has(Permissions.FLAGS.MANAGE_MESSAGES)));\n  }\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get pinnable() {\n    return this.type === 'DEFAULT' && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n  }\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n\n\n  async fetchReference() {\n    if (!this.reference) throw new Error('MESSAGE_REFERENCE_MISSING');\n    const {\n      channelId,\n      messageId\n    } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get crosspostable() {\n    return this.channel.type === 'GUILD_NEWS' && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === 'DEFAULT' && this.channel.viewable && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) && (this.author.id === this.client.user.id || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));\n  }\n  /**\n   * Options that can be passed into {@link Message#edit}.\n   * @typedef {Object} MessageEditOptions\n   * @property {?string} [content] Content to be edited\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] Embeds to be added/edited\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be edited.\n   * @property {MessageAttachment[]} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to add to the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(options) {\n    return this.channel.messages.edit(this, options);\n  }\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'GUILD_NEWS') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n\n\n  crosspost() {\n    return this.channel.messages.crosspost(this.id);\n  }\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async pin() {\n    await this.channel.messages.pin(this.id);\n    return this;\n  }\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async unpin() {\n    await this.channel.messages.unpin(this.id);\n    return this;\n  }\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    await this.channel.messages.react(this.id, emoji);\n    return this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: Util.parseEmoji(emoji)\n    }).reaction;\n  }\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n\n\n  async delete() {\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageOptions} ReplyMessageOptions\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|ReplyMessageOptions} options The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n\n\n  reply(options) {\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists\n        }\n      });\n    }\n\n    return this.channel.send(data);\n  }\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see ThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  startThread() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!['GUILD_TEXT', 'GUILD_NEWS'].includes(this.channel.type)) {\n      return Promise.reject(new Error('MESSAGE_THREAD_PARENT'));\n    }\n\n    if (this.hasThread) return Promise.reject(new Error('MESSAGE_EXISTING_THREAD'));\n    return this.channel.threads.create({ ...options,\n      startMessage: this\n    });\n  }\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.channel.messages.fetch(this.id, {\n      force\n    });\n  }\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n\n\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n\n\n  suppressEmbeds() {\n    let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({\n      flags\n    });\n  }\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n\n\n  removeAttachments() {\n    return this.edit({\n      attachments: []\n    });\n  }\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n\n\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n\n\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n\n}\n\nmodule.exports = Message;","map":{"version":3,"names":["Collection","require","Base","BaseMessageComponent","ClientApplication","InteractionCollector","MessageAttachment","Embed","Mentions","MessagePayload","ReactionCollector","Sticker","Error","ReactionManager","InteractionTypes","MessageTypes","SystemMessageTypes","MessageFlags","Permissions","SnowflakeUtil","Util","Message","constructor","client","data","channelId","channel_id","guildId","guild_id","channel","guild","id","deleted","_patch","partial","type","system","includes","content","author","users","_add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","slice","components","c","create","attachments","attachment","set","url","filename","attachemnts","stickers","sticker_items","s","createdTimestamp","deconstruct","timestamp","editedTimestamp","edited_timestamp","Date","getTime","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","referenced_message","roles","everyone","crosspostedChannels","repliedUser","webhookId","groupActivityApplication","application","applicationId","application_id","activity","partyId","party_id","channels","thread","member","members","Object","assign","user","flags","freeze","reference","message_reference","messageId","message_id","messages","interaction","commandName","name","_update","clone","_clone","resolve","createdAt","editedAt","guilds","hasThread","has","FLAGS","HAS_THREAD","threads","cleanContent","createReactionCollector","options","awaitReactions","Promise","reject","collector","once","reason","errors","createMessageComponentCollector","interactionType","MESSAGE_COMPONENT","message","awaitMessageComponent","_options","max","interactions","first","editable","deletable","permissionsFor","MANAGE_MESSAGES","pinnable","fetchReference","fetch","crosspostable","CROSSPOSTED","viewable","SEND_MESSAGES","edit","crosspost","pin","unpin","react","emoji","emojis","resolveIdentifier","actions","MessageReactionAdd","handle","parseEmoji","delete","reply","messageReference","failIfNotExists","send","startThread","startMessage","force","fetchWebhook","suppressEmbeds","suppress","bitfield","add","SUPPRESS_EMBEDS","remove","removeAttachments","equals","rawData","embedUpdate","equal","toString","toJSON","module","exports"],"sources":["C:/Users/ROUSER6/node_modules/discord.js/src/structures/Message.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst Base = require('./Base');\nconst BaseMessageComponent = require('./BaseMessageComponent');\nconst ClientApplication = require('./ClientApplication');\nconst InteractionCollector = require('./InteractionCollector');\nconst MessageAttachment = require('./MessageAttachment');\nconst Embed = require('./MessageEmbed');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst Sticker = require('./Sticker');\nconst { Error } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst { InteractionTypes, MessageTypes, SystemMessageTypes } = require('../util/Constants');\nconst MessageFlags = require('../util/MessageFlags');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {APIMessage} data The data for the message\n   */\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data, partial = false) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = SystemMessageTypes.includes(this.type);\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n\n    if (!partial) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = 'nonce' in data ? data.nonce : null;\n    }\n\n    if ('embeds' in data || !partial) {\n      /**\n       * A list of embeds in the message - e.g. YouTube Player\n       * @type {MessageEmbed[]}\n       */\n      this.embeds = data.embeds?.map(e => new Embed(e, true)) ?? [];\n    } else {\n      this.embeds = this.embeds.slice();\n    }\n\n    if ('components' in data || !partial) {\n      /**\n       * A list of MessageActionRows in the message\n       * @type {MessageActionRow[]}\n       */\n      this.components = data.components?.map(c => BaseMessageComponent.create(c, this.client)) ?? [];\n    } else {\n      this.components = this.components.slice();\n    }\n\n    if ('attachments' in data || !partial) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids\n       * @type {Collection<Snowflake, MessageAttachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachemnts);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data || !partial) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection(\n        (data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]),\n      );\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n\n    if (!partial) {\n      /**\n       * The timestamp the message was sent at\n       * @type {number}\n       */\n      this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n    }\n\n    if ('edited_timestamp' in data || !partial) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;\n    }\n\n    if ('reactions' in data || !partial) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    }\n\n    if (!partial) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(\n        this,\n        data.mentions,\n        data.mention_roles,\n        data.mention_everyone,\n        data.mention_channels,\n        data.referenced_message?.author,\n      );\n    } else {\n      this.mentions = new Mentions(\n        this,\n        data.mentions ?? this.mentions.users,\n        data.mention_roles ?? this.mentions.roles,\n        data.mention_everyone ?? this.mentions.everyone,\n        data.mention_channels ?? this.mentions.crosspostedChannels,\n        data.referenced_message?.author ?? this.mentions.repliedUser,\n      );\n    }\n\n    if ('webhook_id' in data || !partial) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id ?? null;\n    }\n\n    if ('application' in data || !partial) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = data.application ? new ClientApplication(this.client, data.application) : null;\n    }\n\n    if ('application_id' in data || !partial) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id ?? null;\n    }\n\n    if ('activity' in data || !partial) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = data.activity\n        ? {\n            partyId: data.activity.party_id,\n            type: data.activity.type,\n          }\n        : null;\n    }\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, { user: this.author }));\n    }\n\n    if ('flags' in data || !partial) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlags>}\n       */\n      this.flags = new MessageFlags(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlags(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data || !partial) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = data.message_reference\n        ? {\n            channelId: data.message_reference.channel_id,\n            guildId: data.message_reference.guild_id,\n            messageId: data.message_reference.message_id,\n          }\n        : null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: InteractionTypes[data.interaction.type],\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user),\n      };\n    } else if (!this.interaction) {\n      this.interaction = null;\n    }\n  }\n\n  _update(data, partial = false) {\n    const clone = this._clone();\n    this._patch(data, partial);\n    return clone;\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextChannel|DMChannel|NewsChannel|ThreadChannel}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.FLAGS.HAS_THREAD);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return `https://discord.com/channels/${this.guildId ?? '@me'}/${this.channelId}/${this.id}`;\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(options = {}) {\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {MessageComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      message: this,\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {MessageComponentType} [componentType] The type of component interaction to collect\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return Boolean(\n      !this.deleted &&\n        (this.author.id === this.client.user.id ||\n          this.channel.permissionsFor?.(this.client.user)?.has(Permissions.FLAGS.MANAGE_MESSAGES)),\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    return (\n      this.type === 'DEFAULT' &&\n      (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false))\n    );\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new Error('MESSAGE_REFERENCE_MISSING');\n    const { channelId, messageId } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    return (\n      this.channel.type === 'GUILD_NEWS' &&\n      !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) &&\n      this.type === 'DEFAULT' &&\n      this.channel.viewable &&\n      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) &&\n      (this.author.id === this.client.user.id ||\n        this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES))\n    );\n  }\n\n  /**\n   * Options that can be passed into {@link Message#edit}.\n   * @typedef {Object} MessageEditOptions\n   * @property {?string} [content] Content to be edited\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] Embeds to be added/edited\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be edited.\n   * @property {MessageAttachment[]} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to add to the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'GUILD_NEWS') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin() {\n    await this.channel.messages.pin(this.id);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin() {\n    await this.channel.messages.unpin(this.id);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    await this.channel.messages.react(this.id, emoji);\n    return this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: Util.parseEmoji(emoji),\n    }).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageOptions} ReplyMessageOptions\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|ReplyMessageOptions} options The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists,\n        },\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see ThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread(options = {}) {\n    if (!['GUILD_TEXT', 'GUILD_NEWS'].includes(this.channel.type)) {\n      return Promise.reject(new Error('MESSAGE_THREAD_PARENT'));\n    }\n    if (this.hasThread) return Promise.reject(new Error('MESSAGE_EXISTING_THREAD'));\n    return this.channel.threads.create({ ...options, startMessage: this });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = true) {\n    return this.channel.messages.fetch(this.id, { force });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({ attachments: [] });\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&\n        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nmodule.exports = Message;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}